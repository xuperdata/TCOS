From f8beae4e9a321603c4166e22b30e09e636506c5d Mon Sep 17 00:00:00 2001
From: duanbing <hibduan@gmail.com>
Date: Thu, 6 Aug 2020 17:01:43 +0000
Subject: [PATCH] add mutual att

---
 src/Enclave.edl                               |   7 +
 src/libos/Cargo.lock                          | 641 +++++++++++-
 src/libos/Cargo.toml                          |   1 +
 src/libos/src/entry.rs                        |  27 +
 .../src/util/sgx/sgx_attestation_agent.rs     |  26 +-
 src/pal/include/occlum_pal_api.h              |   2 +
 src/pal/src/ocalls/attestation.c              |   7 +
 src/pal/src/ocalls/env.c                      |   5 +
 src/pal/src/ocalls/net.c                      |  27 +
 trusted-mesatee-sdk/keys/README.md            |  11 +
 .../albus_dumbledore.private.pem              |  51 +
 .../albus_dumbledore.public.der               | Bin 0 -> 526 bytes
 .../auditors/godzilla/godzilla.private.pem    |  51 +
 .../auditors/godzilla/godzilla.public.der     | Bin 0 -> 526 bytes
 .../optimus_prime/optimus_prime.private.pem   |  51 +
 .../optimus_prime/optimus_prime.public.der    | Bin 0 -> 526 bytes
 .../keys/enclave_signing_key.pem              |  39 +
 trusted-mesatee-sdk/keys/ias_root_ca_cert.pem |  31 +
 trusted-mesatee-sdk/mesatee_core/Cargo.lock   | 958 ++++++++++++++++++
 trusted-mesatee-sdk/mesatee_core/Cargo.toml   |  81 ++
 .../mesatee_core/ipc_attribute/Cargo.toml     |  12 +
 .../mesatee_core/ipc_attribute/src/lib.rs     |  76 ++
 .../mesatee_core/src/config/mod.rs            | 106 ++
 trusted-mesatee-sdk/mesatee_core/src/db.rs    |  62 ++
 trusted-mesatee-sdk/mesatee_core/src/error.rs | 551 ++++++++++
 .../mesatee_core/src/ipc/channel/app_dep.rs   | 147 +++
 .../mesatee_core/src/ipc/channel/mod.rs       |  21 +
 .../mesatee_core/src/ipc/channel/tee_dep.rs   |  52 +
 .../mesatee_core/src/ipc/macros.rs            | 129 +++
 .../mesatee_core/src/ipc/mod.rs               |  65 ++
 .../mesatee_core/src/ipc/protos/command.rs    |  51 +
 .../mesatee_core/src/ipc/protos/ecall.rs      |  71 ++
 .../mesatee_core/src/ipc/protos/mod.rs        |  21 +
 .../mesatee_core/src/ipc/sgx.rs               |  20 +
 trusted-mesatee-sdk/mesatee_core/src/lib.rs   |  76 ++
 .../mesatee_core/src/prelude.rs               |  57 ++
 .../mesatee_core/src/rpc/channel.rs           |  66 ++
 .../mesatee_core/src/rpc/mod.rs               | 135 +++
 .../mesatee_core/src/rpc/sendrecv.rs          |  76 ++
 .../mesatee_core/src/rpc/server.rs            |  69 ++
 .../mesatee_core/src/rpc/sgx/client.rs        | 120 +++
 .../mesatee_core/src/rpc/sgx/mod.rs           | 170 ++++
 .../mesatee_core/src/rpc/sgx/ra.rs            | 179 ++++
 .../mesatee_core/src/rpc/sgx/server.rs        |  93 ++
 .../mesatee_core/src/rpc/unix/mod.rs          | 175 ++++
 trusted-mesatee-sdk/mesatee_sdk/Cargo.toml    |  19 +
 .../mesatee_sdk/c_sdk/Cargo.toml              |  19 +
 .../c_sdk/include/mesatee/mesatee.h           |  79 ++
 .../c_sdk/include/mesatee/visibility.h        |  32 +
 .../mesatee_sdk/c_sdk/src/auditor_set.rs      |  85 ++
 .../mesatee_sdk/c_sdk/src/context.rs          | 142 +++
 .../mesatee_sdk/c_sdk/src/enclave_info.rs     |  79 ++
 .../mesatee_sdk/c_sdk/src/lib.rs              |  82 ++
 .../mesatee_sdk/c_sdk/src/task.rs             | 112 ++
 trusted-mesatee-sdk/mesatee_sdk/src/lib.rs    | 121 +++
 .../mesatee_services/fns/client/Cargo.toml    |  18 +
 .../fns/client/src/fns_client.rs              |  54 +
 .../mesatee_services/fns/client/src/lib.rs    |  24 +
 .../mesatee_services/fns/proto/Cargo.toml     |  26 +
 .../mesatee_services/fns/proto/src/lib.rs     |  31 +
 .../mesatee_services/fns/proto/src/proto.rs   |  59 ++
 .../teaclave_attestation/Cargo.lock           | 909 +++++++++++++++++
 .../teaclave_attestation/Cargo.toml           |  68 ++
 .../teaclave_attestation/src/cert.rs          | 402 ++++++++
 .../teaclave_attestation/src/ias.rs           | 215 ++++
 .../teaclave_attestation/src/key.rs           | 184 ++++
 .../teaclave_attestation/src/lib.rs           |  52 +
 .../teaclave_attestation/src/quote.rs         | 370 +++++++
 .../teaclave_attestation/src/report.rs        | 199 ++++
 .../teaclave_attestation/src/verifier.rs      | 153 +++
 .../teaclave_config/Cargo.lock                | 242 +++++
 .../teaclave_config/Cargo.toml                |  24 +
 .../teaclave_config/build.config.toml         |  14 +
 trusted-mesatee-sdk/teaclave_config/build.rs  |  35 +
 .../teaclave_config/config_gen/Cargo.lock     |  73 ++
 .../teaclave_config/config_gen/Cargo.toml     |  16 +
 .../teaclave_config/config_gen/main.rs        |  83 ++
 .../teaclave_config/runtime.config.toml       |  36 +
 .../teaclave_config/src/lib.rs                | 138 +++
 trusted-mesatee-sdk/teaclave_utils/Cargo.toml |  26 +
 trusted-mesatee-sdk/teaclave_utils/src/lib.rs | 163 +++
 81 files changed, 8971 insertions(+), 29 deletions(-)
 create mode 100644 src/pal/src/ocalls/env.c
 create mode 100644 trusted-mesatee-sdk/keys/README.md
 create mode 100644 trusted-mesatee-sdk/keys/auditors/albus_dumbledore/albus_dumbledore.private.pem
 create mode 100644 trusted-mesatee-sdk/keys/auditors/albus_dumbledore/albus_dumbledore.public.der
 create mode 100644 trusted-mesatee-sdk/keys/auditors/godzilla/godzilla.private.pem
 create mode 100644 trusted-mesatee-sdk/keys/auditors/godzilla/godzilla.public.der
 create mode 100644 trusted-mesatee-sdk/keys/auditors/optimus_prime/optimus_prime.private.pem
 create mode 100644 trusted-mesatee-sdk/keys/auditors/optimus_prime/optimus_prime.public.der
 create mode 100644 trusted-mesatee-sdk/keys/enclave_signing_key.pem
 create mode 100644 trusted-mesatee-sdk/keys/ias_root_ca_cert.pem
 create mode 100644 trusted-mesatee-sdk/mesatee_core/Cargo.lock
 create mode 100644 trusted-mesatee-sdk/mesatee_core/Cargo.toml
 create mode 100644 trusted-mesatee-sdk/mesatee_core/ipc_attribute/Cargo.toml
 create mode 100644 trusted-mesatee-sdk/mesatee_core/ipc_attribute/src/lib.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/config/mod.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/db.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/error.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/ipc/channel/app_dep.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/ipc/channel/mod.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/ipc/channel/tee_dep.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/ipc/macros.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/ipc/mod.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/ipc/protos/command.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/ipc/protos/ecall.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/ipc/protos/mod.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/ipc/sgx.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/lib.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/prelude.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/rpc/channel.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/rpc/mod.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/rpc/sendrecv.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/rpc/server.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/rpc/sgx/client.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/rpc/sgx/mod.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/rpc/sgx/ra.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/rpc/sgx/server.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_core/src/rpc/unix/mod.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_sdk/Cargo.toml
 create mode 100644 trusted-mesatee-sdk/mesatee_sdk/c_sdk/Cargo.toml
 create mode 100644 trusted-mesatee-sdk/mesatee_sdk/c_sdk/include/mesatee/mesatee.h
 create mode 100644 trusted-mesatee-sdk/mesatee_sdk/c_sdk/include/mesatee/visibility.h
 create mode 100644 trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/auditor_set.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/context.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/enclave_info.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/lib.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/task.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_sdk/src/lib.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_services/fns/client/Cargo.toml
 create mode 100644 trusted-mesatee-sdk/mesatee_services/fns/client/src/fns_client.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_services/fns/client/src/lib.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_services/fns/proto/Cargo.toml
 create mode 100644 trusted-mesatee-sdk/mesatee_services/fns/proto/src/lib.rs
 create mode 100644 trusted-mesatee-sdk/mesatee_services/fns/proto/src/proto.rs
 create mode 100644 trusted-mesatee-sdk/teaclave_attestation/Cargo.lock
 create mode 100644 trusted-mesatee-sdk/teaclave_attestation/Cargo.toml
 create mode 100644 trusted-mesatee-sdk/teaclave_attestation/src/cert.rs
 create mode 100644 trusted-mesatee-sdk/teaclave_attestation/src/ias.rs
 create mode 100644 trusted-mesatee-sdk/teaclave_attestation/src/key.rs
 create mode 100644 trusted-mesatee-sdk/teaclave_attestation/src/lib.rs
 create mode 100644 trusted-mesatee-sdk/teaclave_attestation/src/quote.rs
 create mode 100644 trusted-mesatee-sdk/teaclave_attestation/src/report.rs
 create mode 100644 trusted-mesatee-sdk/teaclave_attestation/src/verifier.rs
 create mode 100644 trusted-mesatee-sdk/teaclave_config/Cargo.lock
 create mode 100644 trusted-mesatee-sdk/teaclave_config/Cargo.toml
 create mode 100644 trusted-mesatee-sdk/teaclave_config/build.config.toml
 create mode 100644 trusted-mesatee-sdk/teaclave_config/build.rs
 create mode 100644 trusted-mesatee-sdk/teaclave_config/config_gen/Cargo.lock
 create mode 100644 trusted-mesatee-sdk/teaclave_config/config_gen/Cargo.toml
 create mode 100644 trusted-mesatee-sdk/teaclave_config/config_gen/main.rs
 create mode 100644 trusted-mesatee-sdk/teaclave_config/runtime.config.toml
 create mode 100644 trusted-mesatee-sdk/teaclave_config/src/lib.rs
 create mode 100644 trusted-mesatee-sdk/teaclave_utils/Cargo.toml
 create mode 100644 trusted-mesatee-sdk/teaclave_utils/src/lib.rs

diff --git a/src/Enclave.edl b/src/Enclave.edl
index c1ada32..080bf87 100644
--- a/src/Enclave.edl
+++ b/src/Enclave.edl
@@ -204,5 +204,12 @@ enclave {
         ) propagate_errno;
 
         int occlum_ocall_tkill(int tid, int signum) propagate_errno;
+	char * u_getenv_ocall([in, string] const char *name);
+        sgx_status_t occlum_ocall_sgx_calc_quote_size (
+            [in, size=sig_rl_size] uint8_t * p_sig_rl,
+	    uint32_t sig_rl_size,
+	    [out] uint32_t* p_quote_size
+	);
+	int ocall_sgx_get_ias_socket();
     };
 };
diff --git a/src/libos/Cargo.lock b/src/libos/Cargo.lock
index be5764f..3668782 100644
--- a/src/libos/Cargo.lock
+++ b/src/libos/Cargo.lock
@@ -8,21 +8,39 @@ dependencies = [
  "bitvec",
  "derive_builder",
  "lazy_static",
- "log",
+ "log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "mesatee_sdk",
  "rcore-fs",
  "rcore-fs-mountfs",
  "rcore-fs-ramfs",
  "rcore-fs-sefs",
- "serde",
- "serde_json",
- "sgx_tcrypto",
- "sgx_trts",
- "sgx_tse",
+ "serde 1.0.104",
+ "serde_json 1.0.40",
+ "sgx_tcrypto 1.1.2",
+ "sgx_trts 1.1.2",
+ "sgx_tse 1.1.2",
  "sgx_tstd",
- "sgx_types",
+ "sgx_types 1.1.2",
  "xmas-elf",
 ]
 
+[[package]]
+name = "aho-corasick"
+version = "0.7.10"
+source = "git+https://github.com/mesalock-linux/aho-corasick-sgx#ae5c0d76d21a127af6c61015d5fc6299fc119c15"
+dependencies = [
+ "memchr",
+ "sgx_tstd",
+]
+
+[[package]]
+name = "anyhow"
+version = "1.0.28"
+source = "git+https://github.com/mesalock-linux/anyhow-sgx#b78ca3528c24fb2e37aa33f3b76c030ad3c1d719"
+dependencies = [
+ "sgx_tstd",
+]
+
 [[package]]
 name = "autocfg"
 version = "0.1.7"
@@ -35,6 +53,20 @@ version = "1.0.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "f8aac770f1885fd7e387acedd76065302551364496e46b3dd00860b2f8359b9d"
 
+[[package]]
+name = "base64"
+version = "0.10.1"
+source = "git+https://github.com/mesalock-linux/rust-base64-sgx#cdc4f4ab79522f75e4d178c3dcc0b1f0770c6a86"
+dependencies = [
+ "sgx_tstd",
+]
+
+[[package]]
+name = "bit-vec"
+version = "0.6.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5f0dc55f2d8a1a85650ac47858bb001b4c0dd73d79e3c455a842925e68d29cd3"
+
 [[package]]
 name = "bitflags"
 version = "1.2.1"
@@ -51,6 +83,24 @@ dependencies = [
  "radium",
 ]
 
+[[package]]
+name = "byteorder"
+version = "1.3.4"
+source = "git+https://github.com/mesalock-linux/byteorder-sgx#46ab71b0753dd29ec4f1b3834f78ae26cf47422e"
+dependencies = [
+ "sgx_tstd",
+]
+
+[[package]]
+name = "c2-chacha"
+version = "0.2.3"
+source = "git+https://github.com/mesalock-linux/cryptocorrosion-sgx#b31e8668ee0d09678a239a01e6dbcad033e1197f"
+dependencies = [
+ "byteorder",
+ "ppv-lite86",
+ "stream-cipher",
+]
+
 [[package]]
 name = "cc"
 version = "1.0.52"
@@ -63,6 +113,16 @@ version = "0.1.10"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822"
 
+[[package]]
+name = "chrono"
+version = "0.4.11"
+source = "git+https://github.com/mesalock-linux/chrono-sgx#43d452d9dc6fc3d2ef90bf1901486d7093cdb804"
+dependencies = [
+ "num-integer",
+ "num-traits",
+ "sgx_tstd",
+]
+
 [[package]]
 name = "cloudabi"
 version = "0.0.3"
@@ -138,6 +198,38 @@ version = "1.5.3"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "bb1f6b1ce1c140482ea30ddd3335fc0024ac7ee112895426e0a629a6c20adfe3"
 
+[[package]]
+name = "env_logger"
+version = "0.7.1"
+source = "git+https://github.com/mesalock-linux/env_logger-sgx#fbc36d64535561b3aa10a24f367bb21c9287232d"
+dependencies = [
+ "humantime",
+ "log 0.4.8 (git+https://github.com/mesalock-linux/log-sgx)",
+ "regex",
+ "sgx_tstd",
+ "termcolor",
+]
+
+[[package]]
+name = "fns_client"
+version = "0.1.0"
+dependencies = [
+ "cfg-if",
+ "fns_proto",
+ "mesatee_core",
+ "sgx_tstd",
+]
+
+[[package]]
+name = "fns_proto"
+version = "0.1.0"
+dependencies = [
+ "cfg-if",
+ "serde 1.0.106",
+ "serde_derive 1.0.106",
+ "sgx_tstd",
+]
+
 [[package]]
 name = "fnv"
 version = "1.0.6"
@@ -150,6 +242,26 @@ version = "0.1.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "a06f77d526c1a601b7c4cdd98f54b5eaabffc14d5f2f0296febdc7f357c6d3ba"
 
+[[package]]
+name = "generic-array"
+version = "0.12.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c68f0274ae0e023facc3c97b2e00f076be70e254bc851d972503b328db79b2ec"
+dependencies = [
+ "typenum",
+]
+
+[[package]]
+name = "getrandom"
+version = "0.1.14"
+source = "git+https://github.com/mesalock-linux/getrandom-sgx.git#66a998d6a06ef0a91a14921a322fe7fa621c6a6e"
+dependencies = [
+ "cfg-if",
+ "sgx_libc 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+ "sgx_trts 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+ "sgx_tstd",
+]
+
 [[package]]
 name = "hashbrown_tstd"
 version = "0.7.1"
@@ -157,12 +269,43 @@ dependencies = [
  "autocfg 1.0.0",
 ]
 
+[[package]]
+name = "httparse"
+version = "1.3.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cd179ae861f0c2e53da70d892f5f3029f9594be0c41dc5269cd371691b1dc2f9"
+
+[[package]]
+name = "humantime"
+version = "1.3.0"
+source = "git+https://github.com/mesalock-linux/humantime-sgx#d50b0b4461f07dd8b44236a6d69b335357689436"
+dependencies = [
+ "quick-error",
+ "sgx_tstd",
+]
+
 [[package]]
 name = "ident_case"
 version = "1.0.1"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "b9e0384b61958566e926dc50660321d12159025e767c18e043daf26b70104c39"
 
+[[package]]
+name = "ipc_attribute"
+version = "0.1.0"
+dependencies = [
+ "quote 0.6.13",
+ "syn 0.15.44",
+]
+
+[[package]]
+name = "itoa"
+version = "0.4.5"
+source = "git+https://github.com/mesalock-linux/itoa-sgx.git#a49118cf1bc9ab4599c1f2b2cccc4f3f8c0ec38a"
+dependencies = [
+ "sgx_tstd",
+]
+
 [[package]]
 name = "itoa"
 version = "0.4.5"
@@ -185,6 +328,15 @@ version = "0.2.69"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "99e85c08494b21a9054e7fe1374a732aeadaff3980b6990b94bfd3a70f690005"
 
+[[package]]
+name = "log"
+version = "0.4.8"
+source = "git+https://github.com/mesalock-linux/log-sgx#d08c18ff0585d2d4948e658e55c516b404ebdecf"
+dependencies = [
+ "cfg-if",
+ "sgx_tstd",
+]
+
 [[package]]
 name = "log"
 version = "0.4.8"
@@ -194,6 +346,108 @@ dependencies = [
  "cfg-if",
 ]
 
+[[package]]
+name = "memchr"
+version = "2.2.1"
+source = "git+https://github.com/mesalock-linux/rust-memchr-sgx#44e36be54075a1afdf8180e443fd7f8cbd9d4c7b"
+dependencies = [
+ "sgx_libc 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+ "sgx_tstd",
+ "sgx_types 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+]
+
+[[package]]
+name = "mesatee_core"
+version = "0.1.0"
+dependencies = [
+ "base64",
+ "bit-vec",
+ "cfg-if",
+ "chrono",
+ "env_logger",
+ "httparse",
+ "ipc_attribute",
+ "lazy_static",
+ "log 0.4.8 (git+https://github.com/mesalock-linux/log-sgx)",
+ "net2",
+ "num-bigint",
+ "ring",
+ "rustls",
+ "serde 1.0.106",
+ "serde_derive 1.0.106",
+ "serde_json 1.0.51",
+ "sgx_rand",
+ "sgx_tcrypto 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+ "sgx_tse 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+ "sgx_tstd",
+ "sgx_types 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+ "sgx_urts",
+ "teaclave_attestation",
+ "teaclave_config",
+ "teaclave_utils",
+ "toml",
+ "uuid 0.8.1",
+ "webpki",
+ "webpki-roots",
+ "yasna",
+]
+
+[[package]]
+name = "mesatee_sdk"
+version = "0.1.0"
+dependencies = [
+ "fns_client",
+ "mesatee_core",
+ "sgx_tstd",
+ "teaclave_utils",
+ "uuid 0.8.1",
+]
+
+[[package]]
+name = "net2"
+version = "0.2.33"
+source = "git+https://github.com/mesalock-linux/net2-rs-sgx#058ec06a9473af4259ff9c7d3dbe234ea915a42f"
+dependencies = [
+ "cfg-if",
+ "sgx_libc 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+ "sgx_tstd",
+]
+
+[[package]]
+name = "num-bigint"
+version = "0.2.5"
+source = "git+https://github.com/mesalock-linux/num-bigint-sgx#377ecfb8bfac838418e80af9ed6cc74a627ca9c9"
+dependencies = [
+ "autocfg 1.0.0",
+ "num-integer",
+ "num-traits",
+ "sgx_tstd",
+]
+
+[[package]]
+name = "num-integer"
+version = "0.1.41"
+source = "git+https://github.com/mesalock-linux/num-integer-sgx#0ece2da7c01233749769a1574f61236d1569b2b9"
+dependencies = [
+ "autocfg 0.1.7",
+ "num-traits",
+ "sgx_tstd",
+]
+
+[[package]]
+name = "num-traits"
+version = "0.2.10"
+source = "git+https://github.com/mesalock-linux/num-traits-sgx#7551dca0b9f9fb86375bf1a84048d53f72d5ad79"
+dependencies = [
+ "autocfg 0.1.7",
+ "sgx_tstd",
+]
+
+[[package]]
+name = "ppv-lite86"
+version = "0.2.6"
+source = "git+https://github.com/mesalock-linux/cryptocorrosion-sgx#b31e8668ee0d09678a239a01e6dbcad033e1197f"
+
 [[package]]
 name = "proc-macro2"
 version = "0.4.30"
@@ -212,6 +466,11 @@ dependencies = [
  "unicode-xid 0.2.0",
 ]
 
+[[package]]
+name = "quick-error"
+version = "1.2.2"
+source = "git+https://github.com/mesalock-linux/quick-error-sgx#c77b8867336fff708f5567c7e051227af07139ea"
+
 [[package]]
 name = "quote"
 version = "0.6.13"
@@ -244,7 +503,7 @@ checksum = "6d71dacdc3c88c1fde3885a3be3fbab9f35724e6ce99467f7d9c5026132184ca"
 dependencies = [
  "autocfg 0.1.7",
  "libc",
- "rand_chacha",
+ "rand_chacha 0.1.1",
  "rand_core 0.4.2",
  "rand_hc",
  "rand_isaac",
@@ -255,6 +514,17 @@ dependencies = [
  "winapi",
 ]
 
+[[package]]
+name = "rand"
+version = "0.7.3"
+source = "git+https://github.com/mesalock-linux/rand-sgx?tag=v0.7.3_sgx1.1.2#a6a7eccfd4f574b9dc87fec88ca779a12cae1ab0"
+dependencies = [
+ "getrandom",
+ "rand_chacha 0.2.1",
+ "rand_core 0.5.1",
+ "sgx_tstd",
+]
+
 [[package]]
 name = "rand_chacha"
 version = "0.1.1"
@@ -265,6 +535,16 @@ dependencies = [
  "rand_core 0.3.1",
 ]
 
+[[package]]
+name = "rand_chacha"
+version = "0.2.1"
+source = "git+https://github.com/mesalock-linux/rand-sgx?tag=v0.7.3_sgx1.1.2#a6a7eccfd4f574b9dc87fec88ca779a12cae1ab0"
+dependencies = [
+ "c2-chacha",
+ "rand_core 0.5.1",
+ "sgx_tstd",
+]
+
 [[package]]
 name = "rand_core"
 version = "0.3.1"
@@ -280,6 +560,15 @@ version = "0.4.2"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "9c33a3c44ca05fa6f1807d8e6743f3824e8509beca625669633be0acbdf509dc"
 
+[[package]]
+name = "rand_core"
+version = "0.5.1"
+source = "git+https://github.com/mesalock-linux/rand-sgx?tag=v0.7.3_sgx1.1.2#a6a7eccfd4f574b9dc87fec88ca779a12cae1ab0"
+dependencies = [
+ "getrandom",
+ "sgx_tstd",
+]
+
 [[package]]
 name = "rand_hc"
 version = "0.1.0"
@@ -354,7 +643,7 @@ name = "rcore-fs-mountfs"
 version = "0.1.0"
 dependencies = [
  "lazy_static",
- "log",
+ "log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
  "rcore-fs",
  "spin",
 ]
@@ -363,7 +652,7 @@ dependencies = [
 name = "rcore-fs-ramfs"
 version = "0.1.0"
 dependencies = [
- "log",
+ "log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
  "rcore-fs",
  "spin",
 ]
@@ -373,11 +662,11 @@ name = "rcore-fs-sefs"
 version = "0.1.0"
 dependencies = [
  "bitvec",
- "log",
+ "log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
  "rcore-fs",
  "spin",
  "static_assertions",
- "uuid",
+ "uuid 0.7.4",
 ]
 
 [[package]]
@@ -389,17 +678,80 @@ dependencies = [
  "rand_core 0.3.1",
 ]
 
+[[package]]
+name = "regex"
+version = "1.3.1"
+source = "git+https://github.com/mesalock-linux/regex-sgx#cf45cc1a0c0472300fea7dc353c660e531ba5f2c"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-syntax",
+ "sgx_tstd",
+ "thread_local",
+]
+
+[[package]]
+name = "regex-syntax"
+version = "0.6.12"
+source = "git+https://github.com/mesalock-linux/regex-sgx#cf45cc1a0c0472300fea7dc353c660e531ba5f2c"
+dependencies = [
+ "sgx_tstd",
+]
+
+[[package]]
+name = "ring"
+version = "0.16.11"
+source = "git+https://github.com/mesalock-linux/ring-sgx?tag=v0.16.5#5311ddb2d335ddabf7a00f94efd8e7a5f7a9f728"
+dependencies = [
+ "cc",
+ "sgx_tstd",
+ "spin",
+ "untrusted",
+]
+
+[[package]]
+name = "rustls"
+version = "0.16.0"
+source = "git+https://github.com/mesalock-linux/rustls?branch=mesalock_sgx#ce26c885355fde79d45a27a6bbca490d9e8fcc0e"
+dependencies = [
+ "base64",
+ "log 0.4.8 (git+https://github.com/mesalock-linux/log-sgx)",
+ "ring",
+ "sct",
+ "sgx_tstd",
+ "webpki",
+]
+
 [[package]]
 name = "ryu"
 version = "1.0.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "ed3d612bc64430efeb3f7ee6ef26d590dce0c43249217bddc62112540c7941e1"
 
+[[package]]
+name = "sct"
+version = "0.6.0"
+source = "git+https://github.com/mesalock-linux/sct.rs?branch=mesalock_sgx#b16fb044362e6722566dbeb171e537c50dcb0501"
+dependencies = [
+ "ring",
+ "sgx_tstd",
+ "untrusted",
+]
+
 [[package]]
 name = "serde"
 version = "1.0.104"
 dependencies = [
- "serde_derive",
+ "serde_derive 1.0.104",
+ "sgx_tstd",
+]
+
+[[package]]
+name = "serde"
+version = "1.0.106"
+source = "git+https://github.com/mesalock-linux/serde-sgx#58ff0793d46f96124132110880d0f4d44050d6ee"
+dependencies = [
+ "serde_derive 1.0.106",
  "sgx_tstd",
 ]
 
@@ -412,13 +764,34 @@ dependencies = [
  "syn 1.0.19",
 ]
 
+[[package]]
+name = "serde_derive"
+version = "1.0.106"
+source = "git+https://github.com/mesalock-linux/serde-sgx#58ff0793d46f96124132110880d0f4d44050d6ee"
+dependencies = [
+ "proc-macro2 1.0.12",
+ "quote 1.0.4",
+ "syn 1.0.19",
+]
+
 [[package]]
 name = "serde_json"
 version = "1.0.40"
 dependencies = [
- "itoa",
+ "itoa 0.4.5",
+ "ryu",
+ "serde 1.0.104",
+ "sgx_tstd",
+]
+
+[[package]]
+name = "serde_json"
+version = "1.0.51"
+source = "git+https://github.com/mesalock-linux/serde-json-sgx#3fe8bd43ff5627f410efba9c67bb3d31f22b3bec"
+dependencies = [
+ "itoa 0.4.5 (git+https://github.com/mesalock-linux/itoa-sgx.git)",
  "ryu",
- "serde",
+ "serde 1.0.106",
  "sgx_tstd",
 ]
 
@@ -432,7 +805,7 @@ version = "1.1.2"
 dependencies = [
  "cc",
  "sgx_build_helper",
- "sgx_libc",
+ "sgx_libc 1.1.2",
 ]
 
 [[package]]
@@ -446,38 +819,81 @@ version = "1.1.2"
 [[package]]
 name = "sgx_libc"
 version = "1.1.2"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2#8f065be7a442157bf16dc7106feb795ea1c578eb"
 dependencies = [
- "sgx_types",
+ "sgx_types 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+]
+
+[[package]]
+name = "sgx_libc"
+version = "1.1.2"
+dependencies = [
+ "sgx_types 1.1.2",
+]
+
+[[package]]
+name = "sgx_rand"
+version = "1.1.2"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2#8f065be7a442157bf16dc7106feb795ea1c578eb"
+dependencies = [
+ "sgx_trts 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+ "sgx_tstd",
+ "sgx_types 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+]
+
+[[package]]
+name = "sgx_tcrypto"
+version = "1.1.2"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2#8f065be7a442157bf16dc7106feb795ea1c578eb"
+dependencies = [
+ "sgx_types 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
 ]
 
 [[package]]
 name = "sgx_tcrypto"
 version = "1.1.2"
 dependencies = [
- "sgx_types",
+ "sgx_types 1.1.2",
 ]
 
 [[package]]
 name = "sgx_tprotected_fs"
 version = "1.1.2"
 dependencies = [
- "sgx_trts",
- "sgx_types",
+ "sgx_trts 1.1.2",
+ "sgx_types 1.1.2",
 ]
 
 [[package]]
 name = "sgx_trts"
 version = "1.1.2"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2#8f065be7a442157bf16dc7106feb795ea1c578eb"
 dependencies = [
- "sgx_libc",
- "sgx_types",
+ "sgx_libc 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+ "sgx_types 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+]
+
+[[package]]
+name = "sgx_trts"
+version = "1.1.2"
+dependencies = [
+ "sgx_libc 1.1.2",
+ "sgx_types 1.1.2",
+]
+
+[[package]]
+name = "sgx_tse"
+version = "1.1.2"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2#8f065be7a442157bf16dc7106feb795ea1c578eb"
+dependencies = [
+ "sgx_types 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
 ]
 
 [[package]]
 name = "sgx_tse"
 version = "1.1.2"
 dependencies = [
- "sgx_types",
+ "sgx_types 1.1.2",
 ]
 
 [[package]]
@@ -488,13 +904,18 @@ dependencies = [
  "sgx_alloc",
  "sgx_backtrace_sys",
  "sgx_demangle",
- "sgx_libc",
+ "sgx_libc 1.1.2",
  "sgx_tprotected_fs",
- "sgx_trts",
- "sgx_types",
+ "sgx_trts 1.1.2",
+ "sgx_types 1.1.2",
  "sgx_unwind",
 ]
 
+[[package]]
+name = "sgx_types"
+version = "1.1.2"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2#8f065be7a442157bf16dc7106feb795ea1c578eb"
+
 [[package]]
 name = "sgx_types"
 version = "1.1.2"
@@ -506,6 +927,15 @@ dependencies = [
  "sgx_build_helper",
 ]
 
+[[package]]
+name = "sgx_urts"
+version = "1.1.2"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2#8f065be7a442157bf16dc7106feb795ea1c578eb"
+dependencies = [
+ "libc",
+ "sgx_types 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+]
+
 [[package]]
 name = "spin"
 version = "0.5.2"
@@ -518,6 +948,14 @@ version = "0.3.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "7f3eb36b47e512f8f1c9e3d10c2c1965bc992bd9cdb024fa581e2194501c83d3"
 
+[[package]]
+name = "stream-cipher"
+version = "0.3.2"
+source = "git+https://github.com/mesalock-linux/rustcrypto-traits-sgx#1046ef3f5d20e6dc8030cca5e60faa37884c3814"
+dependencies = [
+ "generic-array",
+]
+
 [[package]]
 name = "strsim"
 version = "0.7.0"
@@ -546,6 +984,110 @@ dependencies = [
  "unicode-xid 0.2.0",
 ]
 
+[[package]]
+name = "teaclave_attestation"
+version = "0.1.0"
+dependencies = [
+ "anyhow",
+ "base64",
+ "bit-vec",
+ "cfg-if",
+ "chrono",
+ "env_logger",
+ "httparse",
+ "log 0.4.8 (git+https://github.com/mesalock-linux/log-sgx)",
+ "num-bigint",
+ "rustls",
+ "serde_json 1.0.51",
+ "sgx_rand",
+ "sgx_tcrypto 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+ "sgx_tse 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+ "sgx_tstd",
+ "sgx_types 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+ "teaclave_config",
+ "teaclave_utils",
+ "thiserror",
+ "uuid 0.8.1",
+ "webpki",
+ "webpki-roots",
+ "yasna",
+]
+
+[[package]]
+name = "teaclave_config"
+version = "0.1.0"
+dependencies = [
+ "lazy_static",
+ "log 0.4.8 (git+https://github.com/mesalock-linux/log-sgx)",
+ "serde 1.0.106",
+ "serde_derive 1.0.106",
+ "sgx_tstd",
+ "toml",
+]
+
+[[package]]
+name = "teaclave_utils"
+version = "0.1.0"
+dependencies = [
+ "ring",
+ "serde 1.0.106",
+ "serde_derive 1.0.106",
+ "sgx_tstd",
+ "sgx_types 1.1.2 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.2)",
+ "toml",
+]
+
+[[package]]
+name = "termcolor"
+version = "1.0.5"
+source = "git+https://github.com/mesalock-linux/termcolor-sgx#d8866cb995f79c598bc292303bb3bb4fffe5e724"
+dependencies = [
+ "sgx_tstd",
+]
+
+[[package]]
+name = "thiserror"
+version = "1.0.9"
+source = "git+https://github.com/mesalock-linux/thiserror-sgx#123039095d673a6761954c7f6ad753efe227783a"
+dependencies = [
+ "sgx_tstd",
+ "thiserror-impl",
+]
+
+[[package]]
+name = "thiserror-impl"
+version = "1.0.9"
+source = "git+https://github.com/mesalock-linux/thiserror-sgx#123039095d673a6761954c7f6ad753efe227783a"
+dependencies = [
+ "proc-macro2 1.0.12",
+ "quote 1.0.4",
+ "syn 1.0.19",
+]
+
+[[package]]
+name = "thread_local"
+version = "1.0.0"
+source = "git+https://github.com/mesalock-linux/thread_local-rs-sgx#eb03eee1141108bef5b1e60631580c026d2408e8"
+dependencies = [
+ "lazy_static",
+ "sgx_tstd",
+]
+
+[[package]]
+name = "toml"
+version = "0.5.3"
+source = "git+https://github.com/mesalock-linux/toml-rs-sgx#9ef1e2cd2b7377eedd34fb6511a407ac7b143a7b"
+dependencies = [
+ "serde 1.0.106",
+ "sgx_tstd",
+]
+
+[[package]]
+name = "typenum"
+version = "1.12.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "373c8a200f9e67a0c95e62a4f52fbf80c23b4381c05a17845531982fa99e6b33"
+
 [[package]]
 name = "unicode-xid"
 version = "0.1.0"
@@ -558,13 +1100,47 @@ version = "0.2.0"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c"
 
+[[package]]
+name = "untrusted"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a156c684c91ea7d62626509bce3cb4e1d9ed5c4d978f7b4352658f96a4c26b4a"
+
 [[package]]
 name = "uuid"
 version = "0.7.4"
 source = "registry+https://github.com/rust-lang/crates.io-index"
 checksum = "90dbc611eb48397705a6b0f6e917da23ae517e4d127123d2cf7674206627d32a"
 dependencies = [
- "rand",
+ "rand 0.6.5",
+]
+
+[[package]]
+name = "uuid"
+version = "0.8.1"
+source = "git+https://github.com/mesalock-linux/uuid-sgx#0fffd5407fb31d229bff55ba9bc233cdd4c5edfc"
+dependencies = [
+ "rand 0.7.3",
+ "sgx_tstd",
+]
+
+[[package]]
+name = "webpki"
+version = "0.21.2"
+source = "git+https://github.com/mesalock-linux/webpki?branch=mesalock_sgx#ab35cad4197f6e421ca14da0a2eb7df86654418f"
+dependencies = [
+ "ring",
+ "sgx_tstd",
+ "untrusted",
+]
+
+[[package]]
+name = "webpki-roots"
+version = "0.19.0"
+source = "git+https://github.com/mesalock-linux/webpki-roots?branch=mesalock_sgx#4b542642de1d5a5394f8a24b356b7801e9220008"
+dependencies = [
+ "sgx_tstd",
+ "webpki",
 ]
 
 [[package]]
@@ -596,6 +1172,17 @@ dependencies = [
  "zero",
 ]
 
+[[package]]
+name = "yasna"
+version = "0.3.1"
+source = "git+https://github.com/mesalock-linux/yasna.rs-sgx#e28d16ecb426975d10ab792179e4d4f473ab872d"
+dependencies = [
+ "bit-vec",
+ "chrono",
+ "num-bigint",
+ "sgx_tstd",
+]
+
 [[package]]
 name = "zero"
 version = "0.1.2"
diff --git a/src/libos/Cargo.toml b/src/libos/Cargo.toml
index 7d50d6e..0769aed 100644
--- a/src/libos/Cargo.toml
+++ b/src/libos/Cargo.toml
@@ -37,3 +37,4 @@ sgx_tstd = { path = "../../deps/rust-sgx-sdk/sgx_tstd", features = ["backtrace"]
 sgx_trts = { path = "../../deps/rust-sgx-sdk/sgx_trts" }
 sgx_tse = { path = "../../deps/rust-sgx-sdk/sgx_tse" }
 sgx_tcrypto = { path = "../../deps/rust-sgx-sdk/sgx_tcrypto" }
+mesatee_sdk = { path = "../../trusted-mesatee-sdk/mesatee_sdk", package = "mesatee_sdk", feature = ["mesalock_sgx"]}
diff --git a/src/libos/src/entry.rs b/src/libos/src/entry.rs
index 120dd92..a8e85ff 100644
--- a/src/libos/src/entry.rs
+++ b/src/libos/src/entry.rs
@@ -15,6 +15,9 @@ use crate::util::mem_util::from_untrusted::*;
 use crate::util::sgx::allow_debug as sgx_allow_debug;
 use sgx_tse::*;
 
+use mesatee_sdk::{Mesatee, MesateeEnclaveInfo};
+use std::net::SocketAddr;
+
 pub static mut INSTANCE_DIR: String = String::new();
 static mut ENCLAVE_PATH: String = String::new();
 
@@ -30,6 +33,28 @@ macro_rules! ecall_errno {
     }};
 }
 
+lazy_static! {
+    static ref USER_ID: String = String::from("user1");
+    static ref USER_TOKEN: String = String::from("token1");
+    static ref FNS_ADDR: SocketAddr = "172.17.0.3:30007".parse().unwrap();
+    static ref PUBKEY_PATH: String = String::from("auditors/godzilla/godzilla.public.der");
+    static ref SIG_PATH: String = String::from("auditors/godzilla/godzilla.sign.sha256");
+    static ref ENCLAVE_CONFIG_PATH: String = String::from("enclave_info.toml");
+}
+
+#[no_mangle]
+pub extern "C" fn mutual_att() -> bool {
+    let mut auditors: Vec<(&str, &str)> = Vec::new();
+    auditors.push((&PUBKEY_PATH, &SIG_PATH));
+    let enclave_info: MesateeEnclaveInfo =
+        MesateeEnclaveInfo::load(auditors, &ENCLAVE_CONFIG_PATH).unwrap();
+    let mesatee: Mesatee = Mesatee::new(&enclave_info, &USER_ID, &USER_TOKEN, *FNS_ADDR).unwrap();
+    let msg: String = String::from("hello, from Occlum");
+    let task = mesatee.create_task("echo").unwrap();
+    let _res = task.invoke_with_payload(&msg);
+    true
+}
+
 #[no_mangle]
 pub extern "C" fn occlum_ecall_init(log_level: *const c_char, instance_dir: *const c_char) -> i32 {
     if HAS_INIT.load(Ordering::SeqCst) == true {
@@ -95,6 +120,8 @@ pub extern "C" fn occlum_ecall_new_process(
     if HAS_INIT.load(Ordering::SeqCst) == false {
         return ecall_errno!(EAGAIN);
     }
+    //判断返回值
+    mutual_att();
 
     let (path, args, env, host_stdio_fds) =
         match parse_arguments(path_buf, argv, env, host_stdio_fds) {
diff --git a/src/libos/src/util/sgx/sgx_attestation_agent.rs b/src/libos/src/util/sgx/sgx_attestation_agent.rs
index 6c6231b..ef0c0c3 100644
--- a/src/libos/src/util/sgx/sgx_attestation_agent.rs
+++ b/src/libos/src/util/sgx/sgx_attestation_agent.rs
@@ -112,6 +112,13 @@ impl InnerAgent {
                 quote_buf_ptr: *mut u8,            // Output
                 quote_buf_len: u32,                // Input
             ) -> sgx_status_t;
+
+            fn occlum_ocall_sgx_calc_quote_size(
+                p_retval: *mut sgx_status_t,
+                p_sig_rl: *const u8,
+                sig_rl_size: u32,
+                p_quote_size: *mut u32,
+            ) -> sgx_status_t;
         }
 
         // Prepare argments for OCall
@@ -133,9 +140,24 @@ impl InnerAgent {
         let report = rsgx_create_report(&self.target_info, report_data)
             .map_err(|_e| errno!(EINVAL, "sgx_error"))?;
         let mut qe_report = sgx_report_t::default();
-        // TODO: what if quote_buf is not big enough?
-        let mut quote_buf = [0_u8; 4096];
 
+        let mut quote_len: u32 = 0;
+        let mut rt = Default::default();
+        let status = unsafe {
+            occlum_ocall_sgx_calc_quote_size(&mut rt as _, sigrl_ptr, sigrl_size, &mut quote_len as _)
+        };
+
+        assert!(status == sgx_status_t::SGX_SUCCESS);
+        if rt != sgx_status_t::SGX_SUCCESS {
+            match rt {
+                sgx_status_t::SGX_ERROR_BUSY => {
+                    return_errno!(EBUSY, "occlum_ocall_sgx_calc_quote_size is temporarily busy")
+                }
+                _ => return_errno!(EINVAL, "occlum_ocall_sgx_calc_quote_size failed"),
+            }
+        }
+
+        let mut quote_buf = vec![0_u8; quote_len as usize];
         // Do OCall
         unsafe {
             let mut retval = Default::default();
diff --git a/src/pal/include/occlum_pal_api.h b/src/pal/include/occlum_pal_api.h
index 46c9e5a..064ed92 100644
--- a/src/pal/include/occlum_pal_api.h
+++ b/src/pal/include/occlum_pal_api.h
@@ -161,6 +161,8 @@ int occlum_pal_kill(int pid, int sig);
  */
 int occlum_pal_destroy(void);
 
+char * u_getenv_ocall(const char *name);
+
 #ifdef __cplusplus
 }
 #endif
diff --git a/src/pal/src/ocalls/attestation.c b/src/pal/src/ocalls/attestation.c
index 73c5de5..551093c 100644
--- a/src/pal/src/ocalls/attestation.c
+++ b/src/pal/src/ocalls/attestation.c
@@ -10,6 +10,13 @@ sgx_status_t occlum_ocall_sgx_init_quote(
     return sgx_init_quote(target_info, epid_group_id);
 }
 
+sgx_status_t occlum_ocall_sgx_calc_quote_size (
+    uint8_t* p_sig_rl,
+    uint32_t sig_rl_size,
+    uint32_t *p_quote_size) {
+    return sgx_calc_quote_size(p_sig_rl, sig_rl_size, p_quote_size);
+}
+
 sgx_status_t occlum_ocall_sgx_get_quote(
     uint8_t *sigrl,
     uint32_t sigrl_len,
diff --git a/src/pal/src/ocalls/env.c b/src/pal/src/ocalls/env.c
new file mode 100644
index 0000000..d51b904
--- /dev/null
+++ b/src/pal/src/ocalls/env.c
@@ -0,0 +1,5 @@
+#include "ocalls.h"
+
+char *u_getenv_ocall(const char *name) {
+    return getenv(name);
+}
diff --git a/src/pal/src/ocalls/net.c b/src/pal/src/ocalls/net.c
index badfed8..516fabe 100644
--- a/src/pal/src/ocalls/net.c
+++ b/src/pal/src/ocalls/net.c
@@ -60,3 +60,30 @@ int occlum_ocall_select(int nfds,
                         struct timeval *timeout) {
     return select(nfds, readfds, writefds, exceptfds, timeout);
 }
+
+int ocall_sgx_get_ias_socket() {
+    char *s = "api.trustedservices.intel.com";
+    char svc[6] = {0};
+    snprintf(svc, 5, "%d", 443);
+    struct addrinfo hint, *res;
+    bzero(&hint, sizeof(hint));
+    hint.ai_socktype = SOCK_STREAM;
+    int n = -1;
+    if ((n = getaddrinfo(s, svc, &hint, &res)) != 0 ) {
+        printf("getaddrinfo failed: %s\n", strerror(errno));
+        return -1;
+    }
+
+    int sockfd = socket(res->ai_family, res->ai_socktype, res->ai_protocol);
+    if (sockfd == -1) {
+        printf("socket creation failed...\n");
+        return -1;
+    }
+
+    int ret = connect(sockfd, res->ai_addr, res->ai_addrlen);
+    if (ret != 0) {
+        printf("connect error: %s\n", strerror(errno));
+        return -1;
+    }
+    return sockfd;
+}
diff --git a/trusted-mesatee-sdk/keys/README.md b/trusted-mesatee-sdk/keys/README.md
new file mode 100644
index 0000000..e967463
--- /dev/null
+++ b/trusted-mesatee-sdk/keys/README.md
@@ -0,0 +1,11 @@
+# Keys and Certificates in Teaclave
+
+This directory contains keys and certificates used in the Teaclave platform.
+Note that these are only for demonstration. *DO NOT use them in production.*
+
+- `enclave_signing_key.pem`: private key to sign SGX enclaves
+- `ias_root_ca_cert.pem`: attestation report root CA certificate for Intel SGX
+  Attestation Service, obtained from the
+  [service website](https://api.portal.trustedservices.intel.com/EPID-attestation)
+- `auditors`: contains auditors' keys to sign the *enclave info* for mutual
+  attestation
diff --git a/trusted-mesatee-sdk/keys/auditors/albus_dumbledore/albus_dumbledore.private.pem b/trusted-mesatee-sdk/keys/auditors/albus_dumbledore/albus_dumbledore.private.pem
new file mode 100644
index 0000000..2b2217e
--- /dev/null
+++ b/trusted-mesatee-sdk/keys/auditors/albus_dumbledore/albus_dumbledore.private.pem
@@ -0,0 +1,51 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIJKAIBAAKCAgEApdqjkKxTqVOZ/Y+S7cRbyFVKzqNvqddwZ4wezON0gK3Q80Og
+N6azq66SRzO+qv9I6uUmhfPXFqX5tstwtTgRVrriezOtUIVv3z/7J4GEZp7et/Oh
+90spNZnQGQsLnaszRxlfNOus8d/4gd8XqgCCWgcDtZ+zxxZuu4TcRevAkYm5fqio
+V+AhtWtu91jxYAk7tiMUKGWyQEbS9Uy2tb46qnhLUeD2cuRbL0wRtSVtPtiSQ+KZ
+WlronOOJTrMGoguLzkwOojJR7mR/31aRwwZs0u01akqGlhXDufTAcg78ResRnsdr
+Vp18jXkYwynMW/8QNWVVyPRUx8DM/1QanKaZmYWylEQv5Twkb+k9PAXzLIVBNjNT
+ExNWAtW1UV1bZ2rDMZjcqn8ZB9U5sPl5ZrY0bfSAvFqhlMuSJ/0eNYa9nrYQx8n5
+ZuUf0QTtrOzb6+i+EAR84PTo6JqBTL5vzrbNvNT+obSS2eXRyqIm21XDGyuXWPxT
++P8SD6ymmOAR7K/BsVfz15ne/jJ1QkUf8Uzt6zEm0BvxCSuxICOl6R8orYfgPjri
+oJcToAsQT73LQUz4gR4KVSwb69XtI+afDR47o3ezRs0jXx+sPz7lXwzzRvg1JXy3
+M3wo78t8MK+aP2lOwjyjsfnLVjNKKHgI1gs274alKi7upTMwl+J2lJXL2vECAwEA
+AQKCAgBw6M/Bhg/OjqOfA0c7pxn04Fv1IT67mXdkhvfQ9Ggz0iEV+0vvlwVqM4ZS
+AuAi+XhisW3wc3hSatv9nbI1LN5g9QmKZjvvPWhTy/Lnijzgv/dPtATnnbuIShZp
+diOKSyq1lIhENs2ePKOphn9NtNsI/w1/cCGrv5HTBzgOQdjvO5uUpq00ZdmM8H6y
+1VI91wtXi7oFZnZbW9vyMy+PutmlhA+CxmwA+4U4RckoUTp2Nmoc3P8ZjBof9Kdd
+dHNnjgS3hP/RXAB7EuAa44yIAK/FSMe8fM/zDQ4aYo1BGQKVdtqgBZMFfGF2zqIU
++zesyY/3Se2EyRGOi6sDh/Y1/xVBXiZIEmgBPn58VY2UNxu9lvC4283Q/9gF8cAm
+O9DXsIP6RocdehYr010UPvWL0oUsTO/UJrZLY8ybqdTZkgsLnwOksOpAde4OhNbM
+cljNz2XLvgHT6v2ktEAPNmpNMielOMf3/xUHf89xXN5HwmZHJUUardf3Rh0jTq4E
+Ies8dbOVHEFzHx0lfJPWwIr3lZMk7tPz/tv2khmxm2UnxPP+Wc/UpsgNiZXP06eY
+P8WisL8WJEXTu3JChpxN0OyCMIPee+ggowKW4ditkMTOYf2rGEO3ypLlhmJmBqoW
+PrFQ2EU/eaQ9qOdbTEmbliAJUauc3HZUTh5fCuURpHBHgmQCAQKCAQEA00E1ao1S
+qzkLbyXyZMQUC+IwP+kDGeh37epN2nwUk8otNc6/cUCJINQd+UNDGz/guG6nMF2l
+Y87fa6lF5i4olU4+VwzptEkaKCPpTrZOunbEDFa/1SidghrNK1CMmBwjSiKFy6z3
+zFFZHVQ/5idFWUbpM9gRD9+hfWI+UBu1brfhp0sObu8Mlw8BEHBCPh7m2QQ3qCH+
+LzoZ/Jov/CTOZe5iOd7T7OgDIraW9KLJE9IllFKsjlfUF2struZ1OjOrnelaSonO
+1xa7l+yASwCS2ZKKkwLevGX3tgHtQlbNlrvbZsEZJu4PBYDHBcrAQouPdfR1RNwX
+rx0aboj3qjSDWQKCAQEAyPuvltiURep1TNHfVnRWA6+hNs6nYA+L2/YGVZ4TWS2P
+UgQ1r2cUwI5K0YSd75gn9f/Onu+xAuoTDfE4qjgq7WYdABS85yCXocXDYbVtNg+w
+wAYUA5qQH03ro4AvLq+hKOtYI8MwVg25vsELtdnu0XasiqNC4Pzaig4gW6Ldmbjq
+FcqeqJJeEMPsWi3S82OXCdHh1bg+dFDPxj5tehI4YVjUBlvFOBUoiRr/BU2Lgv9M
+962DnH4CwveKFiccBCDabaZSt7yfXC/jiPAnSnxWQqE6TBrJGviO6hlJ2UZ6E3IJ
+aBw1gaItUI2GK4gJp93UtC2DFZKvEEkf2S3DMBqZWQKCAQBy2r4e6yzp+H619Eyf
+6lb3ywbuiFHuUQx7JmsjgVhyrXX9DiXZffvQBGMzdRVUCFu2CjsNuaxE4mFoGETv
+i2L3Ie4Ux+l74k69SiD7cXTGPfICv1tWmdlgtg+cIBQAUzQAh1p0zNqAlC2+G2MO
+T4WNr1b0n+FO3wfesn4scZQn2QNvQAhd2cvfiQHMHSx2t7hMftV/rNOUe6NLSc0S
+6jPpCT0QN4zC/bVOtzTFVoe6JgPWa0hzr16ZSOUydQuBFDyXAxra8aeqGyrsw2FQ
+5cPxVJHQsbvFdC7EHrIO4kCuVf5IFG4HU2CJXmVWSdBTnarmt3zWbk7WHx2SwRbd
+y+UpAoIBAHz3KVVkssTKJEcwk2phCX5fPKEkWyO6Zt7MmWGw2Rzw3BVF8s9uC5Qy
+pUii6cSo2ef2N1XReUFzo4devjnwlJhpjoyXWGFpfX6jxXlCYnZjySWMYfNfrk8Y
+lvRhZnTj1RPpSTNrUOmgvSZjR9G5gOmSnXPSUWotLgD7CZmQqbLELCCCjKYJ5B0O
+hS4JIgodmTMM4huN5J9UA+yislVdcNrubV7KvtTBKyQcugZlEeLQtN2ncJbkLvll
+CuH9TUkv2ECnUvVVfczHJfXmRLfmmYfyUZoyaWqws8PRF37WeF8Q39Jw/7/rw7s7
+U/pLKp3Kq0+goMnQG7PHk9rovl1xnHkCggEBANHEg+t7ishLNhKxt/NPF1C1Ylos
+bIttLEeOTDJ8RVU+L7O3YaXUWQ72G03LGx949zO1Tu9GTDkac3ZzhAQqGF6jiIxD
+beBx5QK6hcq7pdM/lWX7aPCGA+bvWQjM8uqKvMClPaXoK98KEsIO6tW7c3ciTLEH
+Eu8Zp4nNRnRL0XAqzjCZ8CpkAIS5EqewrvinVXm4R/njXFvnwScTX+zsV7nBZCVX
+N56M3CMxYVZ5hpAR5NQBhv0lq7nbH/HFVHdIT+fIMtkeVtqH0YYf71FIgxjbRZPJ
+IVcIjdvKvwcUCSuEyZ/H6bR0aHefai85qQbC2fiATCUlPd8w7WfjYkfHRFo=
+-----END RSA PRIVATE KEY-----
diff --git a/trusted-mesatee-sdk/keys/auditors/albus_dumbledore/albus_dumbledore.public.der b/trusted-mesatee-sdk/keys/auditors/albus_dumbledore/albus_dumbledore.public.der
new file mode 100644
index 0000000000000000000000000000000000000000..c46b89f2a30e3ca4fab66003d0ebd2a7e577ee1c
GIT binary patch
literal 526
zcmV+p0`dJYf&vNxf&u{mrP`yAtW&8|nf;HF?ZjKiRZ7mIZ>iUCXN(@q<8*+n(DOr}
zH>R_zu98PHzN-I7>g6Vd^Vb%o`L@e&wKx%0y5f5?tx$z;-#_~&frMtB-na9i_e&`?
zna~*v3!SSoM;Tu<>#XtL_<`RSssMso2LrXAv&R;0yM)|D>%ftTxqhgqSKuMFYi{>g
z@n8u%wj&fMWwJm<()CQXwZ1y4cuP^>_HyJ~FH8}&C2c;~l0)K|T3YCw<B3kQ2BHg#
z&P)!XGEweif8SP-!v<{9?KNsjhL#n>x%9wt4*W&y5uV3uR-Jr}c^Jbf%v=8uHDy)E
z^i;>d%>PsxoTizXg|d`HFXcQWZ|OZe1@kP0K{hi}6BAYf)wNMwTW4y+F__${e;EhW
zIk5S8X0|kK^nkotp_I##C;c8ZhP|G)5XZ^+X5}Bz1nsQs+w17Q5CnYS^yuiCflR({
z&bH0G)c&EglG)|a%AzLQRl^%AmstE$`2P|QtfrXY5$vzQu~+lgncn^~bwWiS@l5UO
zF(%L(@d+!jAS0#eA1JMd;66IypqCS%3lLAe%Rx-|fgTD~EF0_9?IY%&4IVqAce6&#
zBVQk^KR)GO4D&|#H6?tvGkhrT%X~1enm=hy!aSp~`O8)_N+@^;)(bZ8hNUVl?xiy@
Qm*RGmmCM@k0s{d60gnO=0ssI2

literal 0
HcmV?d00001

diff --git a/trusted-mesatee-sdk/keys/auditors/godzilla/godzilla.private.pem b/trusted-mesatee-sdk/keys/auditors/godzilla/godzilla.private.pem
new file mode 100644
index 0000000..26033d2
--- /dev/null
+++ b/trusted-mesatee-sdk/keys/auditors/godzilla/godzilla.private.pem
@@ -0,0 +1,51 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIJKQIBAAKCAgEAp+6fTyMeiVhcyjdjC43KoUrPLmbt0GJFbMyib+BTp6igqMqx
+dDQBmoAfYQNVeojLXEu3O9NWga3wEysmxxsjGBbPHLW1LEofnx0AacQpskKTSkAK
+maMFbY1P+WdL1x4NtJFx8lgFW+fPWRJyOeb07hMGbw3tgwTZV7woi8/IiuNbnFaU
+jGLhsUE78uChcSl1c0aJ9AKNNf17R5+A2WnwjBdh6hJQWKpqyQb+CjsUi/bbhv9f
+yMXGXtcIh1OVzJKeqwQKgPYvkQbk9fOngjSENHRkT+vDbDC3pAjmlXR80YrmcbH7
+a7LOYeO42VKGLEgQSkg7vScu4qbKPQGUqwgpPatElnoHwuPrlQum8rrTfK6JPOJf
+xt8uge1hWVHvoH0tQ7nQnyVoG2+RxjnREK5RK5cclpA8k9EEC2McrJJg4fpKKZCX
+0qVL1Olhdtt+FdoLY67ha2Jpyq771LHpSwfw6pKlowJ5zTy1IgKtGm8cVQjHyC4h
+Zf1evqQhrBe25AltCQPyxGSJnYCAKoj25zcHp0O9hoTIf0mBvIeQvHVW2ZOojysK
+X8mIRvWHqgBWdqdKwQyCQCfpXfoFK6lh/gKnXrX6LUktjl6pz+epyIqbgpxvbDMe
+Jkb4C5ontLVA+na/sri5mAJS34QtnIMSwxjfMI+yTR0j8r+aP4zYWc7vERECAwEA
+AQKCAgEAgYBP1CxGAS5mJ/78X02R5D4XdTYk0Jzn4tYPseyxNkqg0mm03OK6FdYV
+3K9AfMT+5gbxn64DOO/UgkO1nLd9obb9MquhsizbI82uouGGMhSLFyg5xG7l4aym
+7rLM1nAzq3q5/2QHhe9Gg+7orWRAn1OGk5+O+ImFvdW5AtBSW2CnJfHSjkw2tYWT
+4GF/vg91plbQTZ6mHOuD5SDIsWC0AqSJeoNy+F07ChldULBs0N6mPf2zdNWnez2i
+MxGvJFoxB7qPCxJObi195XlnRM6Q4Q6cyNEMG+OZymKexsRU+RZ/TVAujcgOxYhh
+5R1xoLZV8aKwhtavnlN3BAKzDg22FrukYJc+UaJ85u1Knzv7CaOIfpzk20xOt2ZW
+GYO24ZWUTLFZpuxPG+WWZLQzYsDJtBczolEfLq4YF4I1tteHqMGdFi9PXtC6hvSN
+N5FaPOwh+Gur+VxyI9G1wzgA/9FKNvbFah1sDIkV6FLf4cQVunSadUC9qFkA6vLy
+WLD4cT511pXGqXNNa9nhVQV2BicjcZjUlUAGauCMtcnxduWQVgeFP7pwHh60J9Et
+4c7dbdKbIUvrouBFXtupYf/YNfHbsCbuITEZi35vkWV7U8LuqiU5jXvEggHBGj6B
+nVex5FqcAIy1iKtr6+WPfIcjFkMvLfrlr4ETHhdTjwlKWtI78E0CggEBANMbgZPR
+FBJj+vvqwFvwLVnDDa9O8oY54AA6YchFUXH5zGpCk8NwFr8TSlKzBasJQ/DQnIjc
+6papo/+mT7nF8Jkja7b6fhSJdGcCQ/Movgqeebh4pbzUx13+UnsjF4+KkqY87pgf
+oPBcK+QJ1X/IFCaL3KnLEsWCjQ+5MwiINUGfsejulPtO8gBzSLPhhxSN8BRuulQA
+v1hzuQ07zOFxNQhaLlRpo8lMgrBzUYmBTeBCZCW71FdUt68C2QJsIwwnKIMzwNMB
+4q1co8JuZrBFYfoV9VlgRlFYlgMMdFAvujI9+RKuTArg1ilfMnw4X8RCtqHBPUf8
+MhhVG3WkTGPdAtcCggEBAMuksPiYrG8D4l0qxEBARFI3KDo+/+TThs5U8kAb0VQV
+IMZ7yEbK9ej/QUcpb3GKxhY2iEBKfmdYWrk35qoFdi11s7ZSNwdVWJD6xtwbQwUe
+gkktAqb823Zs98xUMz732ceu1z2o0EJi/m7fYdP7zclAgUELPDaAUqW1weiAmBpr
+FNy8bseByD/2Rpq4Q/CahoUpB5WUCFdrF/Q1fum+gnMgrAVEB543d/U9gICaQ/kw
+wT3ayPpdJbutbGnkEmDCbS9lIcvopwmfEhLXRgrkIqvIY0QgCxhUlnYquiKK2Hmh
+fAJgL49hBTBClquFWR9Te603vL25hMIG+09WB9AcdlcCggEATdpiAgpkFZgrkkXz
+pLRBdU36uQErbZbgZhUhxILT022lFjbxWWz35oWNrkv5NidXl/LHF64pEWEEax6B
+XmiCH2exrKxaXOaIOAjc2ErZMv9YslBEBwyNbbuB3YmGgdg/1vC3qQBZEOtdAF8k
+DljSHZkMys1qYc6QiRDqoiXhRg9HxDhgVwG5O7NIR5ZPg6QIuvBO5PXVmyAqSZgZ
+KbbfMPJZDaZb0bvWoo4UrtoxxxeU6VmIqKBEkVVChKMulafHSAOJBAg4+WgluGmQ
+k0czJ9B7R/e6VvuNbxhjuMKxLyAtv9bpkkVylZVW//qmTrGvup2SJP771n9kfhEW
+Xum9xwKCAQBkLST9daVFi0ScjkAyVysEwqtgU8Nv3npvH6x3yvdjhG02FohEAu2L
+a53CEukGkry1Cqhl7/9UeUtP1+b5dmxXGpKIOtNlIR/LWgHfHu4OI571vlWSrcqL
+7DjN5BG9hRE1wJWTeGrSbX46Llsie7kUqk2rIIrDSMbfS5US+cdZH5oIqA1ayUYn
+6M98pu6M+ob4FGHtu/+KeV00PeirtZLYbZcRlBCnTSQOmO2Q1dJgUBKPigPZ3V6F
+f19Yi+BahupNKVPByjX5bq3mZM3I58cCeDYUuiqbEmldwdEE0waAdubZCFX9Ez4J
+KoiR4awg0+GAKW4Iaq2bAPI5adm4D3hLAoIBAQCubhzR1y2RqrDqh3fambh93FOW
+MOQBP+FOgFxIBDAW/ve84r9/aVr8pyvsAP8zeX/2U6/OUgYn3uaXa6SJp33Din07
+YtuRqsrBRtMgAkkh+dCAqITlX6wjqmLaSUt4aeNCr85y+9npnfRoLucuQiEByuX7
+xPEum69DXvAAjNNo5lnWPiVb5B2ftGfZu3Ex6HR8W5fhsF60GJn5+MTGvu3lmAsC
+cZPAv4/NVheep4nEwYeRnHFNhsLcdJf3zHBjuT6xfzQpSDPW7PW5TFSIQG8VMTw6
+gm+k6ZkbOosQozIU3R9I6yK3/GdxY4Dw75FkfwzZxX4NKk0kOgIrsz2W/HE8
+-----END RSA PRIVATE KEY-----
diff --git a/trusted-mesatee-sdk/keys/auditors/godzilla/godzilla.public.der b/trusted-mesatee-sdk/keys/auditors/godzilla/godzilla.public.der
new file mode 100644
index 0000000000000000000000000000000000000000..c1131656f8fd5439279bdc14a41f8fed5186516b
GIT binary patch
literal 526
zcmV+p0`dJYf&vNxf&u{mr|zFmBOZxZT*^0N3ysR5O3yB4?a*RHY|Nr>;8Ullps32R
zbTk2)fFEH4ReFfaTuZk*(^i44@DnR0#~ULU7S9~DwJb^>pB(^c#3`~ulS)7enWF`5
zjZgV!OV=I^w2^W0SOr_>&sh?3Ip*~469#V$?Sll_SG*{T&&Z17Tbx#ujAG%jK|Au`
zp>Zj7b4H2u0*y8Odq<yu*=g{M7h&oWP*|#J$p-!kI~0rd+lK#N$i>E9*9eDGmCTZ!
zs{{&w_AikJ<n{BXf;5CQbYxHK!)!3OqzLAfbbQf@=5ew6YqHK^<G9&UhAc=BN=Q4s
zCobZq$~^&;s|YDQt3;N12g2j)l?$fwy3>5Fi9F(8#@{Z1?O|C_@1T7xL%GnOC1@LO
zk;XaE5Ux=xmmHRmJd@D`3u7Ftl3?NbN-2<+(xpq(>0x%;eihmaW3J(AVrj~*`_!@N
zO9$}klBJ^pdCfevA_A=%ZyZ$!$H*=rW&K{hq#>*qw&V$I2?O%PWQm=CfGUXg=QjtZ
zL%oKC$bU(JyoZpybynGvsE;cOU&)9@^@pkeR(7XK!3=^xC+S`K1uLmx{sO07wfZed
zEskEP&*!PgikpI*Z)`IjCPw%RnkTfiK>BvSvbedJ0#e_EEu4cA!x-N%kFrf2Bl5qR
QKaAK}&hHTs0s{d60puF}p8x;=

literal 0
HcmV?d00001

diff --git a/trusted-mesatee-sdk/keys/auditors/optimus_prime/optimus_prime.private.pem b/trusted-mesatee-sdk/keys/auditors/optimus_prime/optimus_prime.private.pem
new file mode 100644
index 0000000..0640811
--- /dev/null
+++ b/trusted-mesatee-sdk/keys/auditors/optimus_prime/optimus_prime.private.pem
@@ -0,0 +1,51 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIJKQIBAAKCAgEAx8g4ELFBXr/3vCIt36hF9QvfeQpRZfZ3oIZs48E969meAyBa
+7WZlhhsf/L54W/3Lm57/YNeeb7xHlYpkStwOGUib6vYN2sXFOdfvJe6WBsiHf3u/
+7ADcSHGnhVTVaHLK968pUSNtqs2DoSGb5lkVPZdBQXjKXNYHOF26rNG4ZWLvFMlq
+DQEG11YBs/BPA5Sz1qlF4NBzPYttjhUWSXKkLA0fFW+yVTCHldbyOLsPLkckCdfb
+z7sMfBomYZvceLB/LdJavo3zvQfwC2Ff3gypOOvJxiZUt3ZNg1wdKrBOmsFgs+P0
+4RFzVDHJmByGaePM5Dz6bO2LA7aimvOqXUHixVEgz5SyvGhdlQ1KXC1OEHuCAPYy
+ObBuHnaofl+a+ppd0eHVriBzn4/0TZ+u3qNQtBMWUbAOC4J4jSxRUeVYts08Z/MS
+aeJpm+8ZBMAPQK6fbB6oTuLYqCwTo3XJP5HEDrD6ZEwCjhzzEi1H8nakNFMN0KBU
+YEOmb2ZBzXDESd0AmKl+Ky5aluIxJnTbw2odTGSDhdC10LrzWrbQ//8HV2pZwgkk
+MFfvKYdfOxNACWZcnZUXm+5jcACMsVdfcHo9lCMCN1Uuy9C8576DohV9cqxAZt8b
+bCOkOtappiObZRlZK/+1vU4XH/uPF+Ldmm+Rfch/+Cz4KbyurlPfSHVKZk0CAwEA
+AQKCAgBOv7xh0A0NdSwIy4w7kg/pVMHE621EfM+QxgwcBqsK0Z/4aYON+oPgRcbp
+EIdO846TjCvsF3ILZzLsXj3ESFOCYd2b01uItdZVQ6mv0QjwKZFHjhcLxxcNs0cu
+Rk9MuZsJ4NCvfACZiCLvm9jhBpJZ0cpWLW/PAkqcTE3uG0jNJh9JmU8lSxdQQEWx
+kPMEXVQ6NEUoJeKXCuOnUuaTEw5lktKC16F69QMs7CpUdF+6hS5OdvjdPETikkg4
+x4AzTpcDD9zXKgs+oudbBQoN8/2sQz0ozykrnAVX1zJkBlUlqT4eCqgXI5LLSEjH
+nc7Z5IJ6IRMxZr0aPJ6B57RqyDLDkwErkx7DR0wBodsPzEt0Lq2dG6QY92AFD+hU
+Hf2M+M11OBzom3mkG1pm5R+ymkMiU9pY5FTIOvUfIShPC/GfJaO/i7y8PB2QChXT
+DNAOJQev97Pidd7VhEfw77sp6HEOpixASQ51OixDVrOkYb5bOIUsSW+eJh0mrmvR
+FK4bS722+QUyNWITVK/tVutKyqMpyEBc+oGb7QW6gOrp1Nhvwa3YTrOXwLLX65V6
+A0YHJVuWW9jxJsZtNlchmgAane0itCF4P+8fp6611jl7TAnTadjvTzNBkhgGRVB5
+APP1Yemw7hi8Zdtu3vPKP6LUk8YmyIdwOjFI58XChSZaW2qZ4QKCAQEA/jxZU/qm
+JuZZznuSuICyYtyB51Faki08ujC/4NC9I8hUA4PJfxxyvMX2eJ0fVznfAIn3J5ja
+ycFup2xt5xFT9t+uNIK8pau6au9c+3+Yjp+IYqIbQ4LPmbZQlVUifrQHL2E/+WcL
+Rb0ZQt5R4wR2K7WCUneRdGdEbEcEwXeMO8ZAtXDkDs+7X6lWXW50LA8Zo6HXgmRY
+q9YOpJ3Kf7zrwCqihpFoPEera3XXh71uQPe3i/Ux4eZZ0R6FqfRagYLLHFxcWJXg
+GgVUWym7SSdSJ6pbnyAqzo98/NOozLEjEKTvc5ecCwP7Yqfy7yjTWcwvOBQfa6qL
+zP/6hBzzZz5zFQKCAQEAySsiBsh0OEvd6AA6+r2bMuZJ61HqpgSWEM5lLM85n+dR
+FJMm5K9i7DA1/8VlGTwT0kvabqLUTibU4vGXy1X48EcC51ZZSGrf9sLUcd9pSTxm
+HSles+e5caNI6SdEQHg9bFe5BCn7Rzdsiytut3NWWYY4TGCDZgqRk7ISGgG2vnYz
+nd/g9RDwoUm6SBPvlXDJaHmJVXAEQbejHMeSNzvd9BNWDFco53QTDJZRpnv445X0
+dcXMFtvD2186KgwD05IACuXABKPxzN8uGcH/t1ijvy3pABPS6fCyLwh1BBllQ771
+4fMn9w7vGa8m5mWBzLLR0BHbsSo6YbzZxuQeoevUWQKCAQEAnS0oOMAcWq5M1VgW
+hFSkdHRJJ35nVTn8ckvTRKUoWefu8OFYAGrREJ3+2+Cf0Khpkwa4s1VP5i3dQErL
+w3A2DcmKBNLS2EXMEXJ8dMwUwBAnHHuGCX3k5O4O8dPZaKXaT1N7XrBzCqF27Z1O
+2OAYQruLn3pmhaWWaq6ZZRaIryfJN6Nciz+oYuLpDwhLcDXBryVOfEGXhFzpXqJi
+4AgnY/23zyQ0YhgZBW2sWzIk6Kt9YVysgzGLU7rf/gugrLL06Uq8mNPH4a5r0ZSC
+Qh66LuWmkUEs1dll91TP5gSZXh/qHfecND84+mxEx9DgoYKXqr7eEg01Mv8KnQTd
+AnZcZQKCAQEArR54btvs4FGxyyj/mK65M+loraFWTL7foeDsws4mqgx4AzvLmbux
+Zs7qeY0XPssrx6tNdC6ehA7438DHP85hp+2Eey8dMKwAxyvNhZ2cztCyk9/5Rtth
+BIFfin4nR0/ylB099G5od1YkC/Q5mJgiNHLEWj4odhUcSL1SxJy69ldkfjWfM2b7
+neGD9OlrIfDo8wa8gBEhKKjvLyI0G2Ji1NwbDg2n/t8uUYO/CoXfn4N52Cx7QSSo
+/U2LEYo7dMRNUxN61sN7oDJkSvhfpxoZ+Ll6rX1h4b8oqD8f7IIqWk2o7mTB/OQW
+McVAtb+fH1i4JNZpeKJ9kYTi6T2BexknKQKCAQA/38neJx+7veeCuG/Cz2jhPwMx
+TL3ECjPkDNKz42Tzh9Rnvbyg3uJ9oFoxhjWzReHvoVnLdRLDq0nHHMEZbCNjOucR
+yYs2kGIRaF5DWkiE5XU80QATgq5bHypnByLm/QFT+ZF6rLeMH0tcOEZR966XppEI
+sVmEmIHGtbT3EyEmAA3NvX6iKGyHMwUtuguUij34o0yO7PFxtlUsW9iAiAhFEiXR
+mGOlXrUyuVbObEiUtOHkWQyUtXw9SXXmYk/HOULmnON94Nt4GR87ACW2IfcPMPXv
+zJBki9K7D9ny0iY15Oh/uBvH35McErY79TgnY84xo77MD4MzwkFWn+35nffW
+-----END RSA PRIVATE KEY-----
diff --git a/trusted-mesatee-sdk/keys/auditors/optimus_prime/optimus_prime.public.der b/trusted-mesatee-sdk/keys/auditors/optimus_prime/optimus_prime.public.der
new file mode 100644
index 0000000000000000000000000000000000000000..d34d584ff4ba75efa9740a42f3f24a8671f00d75
GIT binary patch
literal 526
zcmV+p0`dJYf&vNxf&u{m$H+Jku|ZzH_q-x4->60P3*UJPQDydbpoVPY!9DBQo&z9S
z?Pg_$8z20>cw7C;o1Xt**Pd^@N0o|XO56?^NSo^R4cf)UIoIzc?v@6~hktv&>;T+I
zai@h;)o60c_pd2YBW<e9gP|dt=2;azmq9^z%3Rh5I9<A|(YR$|?-a>u4FLw%Rspl{
zPXm;*)~Q9{&~rVDZH^TdNphqt4IdS6vQ;pLmDch&yALi$Bnj8s&$|qK8YW?z+<35m
zEz(-Pjq|++@C#vI-VCWY>&eC@RJV3bgIpaduuhu6V6)@&;SqCGG0B)5hH2x><UIOp
z?TZ7pqMGxnT|wf-Q6SHhvb<<rl?_T<Elv=7f&lh1Ik0XXcBp<|n);eu(c#suAakFO
z^i7|x-lI^o6Bbdh4hw>KjVw`7<yf}OJZJL~Y2s;{?->NZ4?wP;Y#yji;@GGx6Qgy>
zKas=^u=-?70*)N>5-msacBC{@4bY%eU_+*FW<kwx#7W%%n5lj%E?So2F(!1|!)hH&
zWP^p!wa~irTDH*t{|8rUS;7e<Fjwy>hhIArKnZ4Cos}1x?qhHOjImc=aC$wIBLX*7
zF3Zro=e~oY6@7B7KxW??Y$K#P)~Ti=n`IeUEC02<P8T2hj~C+Ins1SP$ba}O_$j=u
Qu2bJgbxLMU0s{d60h$5)e*gdg

literal 0
HcmV?d00001

diff --git a/trusted-mesatee-sdk/keys/enclave_signing_key.pem b/trusted-mesatee-sdk/keys/enclave_signing_key.pem
new file mode 100644
index 0000000..529d07b
--- /dev/null
+++ b/trusted-mesatee-sdk/keys/enclave_signing_key.pem
@@ -0,0 +1,39 @@
+-----BEGIN RSA PRIVATE KEY-----
+MIIG4gIBAAKCAYEAroOogvsj/fZDZY8XFdkl6dJmky0lRvnWMmpeH41Bla6U1qLZ
+AmZuyIF+mQC/cgojIsrBMzBxb1kKqzATF4+XwPwgKz7fmiddmHyYz2WDJfAjIveJ
+ZjdMjM4+EytGlkkJ52T8V8ds0/L2qKexJ+NBLxkeQLfV8n1mIk7zX7jguwbCG1Pr
+nEMdJ3Sew20vnje+RsngAzdPChoJpVsWi/K7cettX/tbnre1DL02GXc5qJoQYk7b
+3zkmhz31TgFrd9VVtmUGyFXAysuSAb3EN+5VnHGr0xKkeg8utErea2FNtNIgua8H
+ONfm9Eiyaav1SVKzPHlyqLtcdxH3I8Wg7yqMsaprZ1n5A1v/levxnL8+It02KseD
+5HqV4rf/cImSlCt3lpRg8U5E1pyFQ2IVEC/XTDMiI3c+AR+w2jSRB3Bwn9zJtFlW
+KHG3m1xGI4ck+Lci1JvWWLXQagQSPtZTsubxTQNx1gsgZhgv1JHVZMdbVlAbbRMC
+1nSuJNl7KPAS/VfzAgEDAoIBgHRXxaynbVP5gkO0ug6Qw/E27wzIw4SmjsxG6Wpe
+K7kfDeRskKxESdsA/xCrKkwGwhcx1iIgS5+Qscd1Yg+1D9X9asd/P7waPmWoZd+Z
+AhlKwhdPsO7PiF3e1AzHhGQwsUTt/Y/aSI1MpHBvy2/s1h9mFCslOUxTmWw0oj/Q
+ldIEgWeNR72CE2+jFIJIyml6ftnb6qzPiga8Bm48ubKh0kvySOqnkmnPzgh+JBD6
+JnBmtZbfPT97bwTT+N6rnPqOOApvfHPf15kWI8yDbprG1l4OCUaIUH1AszxLd826
+5IPM+8gINLRDP1MA6azECPjTyHXhtnSIBZCyWSVkc05vYmNXYUNiXWMajcxW9M02
+wKzFELO8NCEAkaTPxwo4SCyIjUxiK1LbQ9h8PSy4c1+gGP4LAMR8xqP4QKg6zdu9
+osUGG/xRe/uufgTBFkcjqBHtK5L5VI0jeNIUAgW/6iNbYXjBMJ0GfauLs+g1VsOm
+WfdgXzsb9DYdMa0OXXHypmV4GwKBwQDUwQj8RKJ6c8cT4vcWCoJvJF00+RFL+P3i
+Gx2DLERxRrDa8AVGfqaCjsR+3vLgG8V/py+z+dxZYSqeB80Qeo6PDITcRKoeAYh9
+xlT3LJOS+k1cJcEmlbbO2IjLkTmzSwa80fWexKu8/Xv6vv15gpqYl1ngYoqJM3pd
+vzmTIOi7MKSZ0WmEQavrZj8zK4endE3v0eAEeQ55j1GImbypSf7Idh7wOXtjZ7WD
+Dg6yWDrri+AP/L3gClMj8wsAxMV4ZR8CgcEA0fzDHkFa6raVOxWnObmRoDhAtE0a
+cjUj976NM5yyfdf2MrKy4/RhdTiPZ6b08/lBC/+xRfV3xKVGzacm6QjqjZrUpgHC
+0LKiZaMtccCJjLtPwQd0jGQEnKfMFaPsnhOc5y8qVkCzVOSthY5qhz0XNotHHFmJ
+gffVgB0iqrMTvSL7IA2yqqpOqNRlhaYhNl8TiFP3gIeMtVa9rZy31JPgT2uJ+kfo
+gV7sdTPEjPWZd7OshGxWpT6QfVDj/T9T7L6tAoHBAI3WBf2DFvxNL2KXT2QHAZ9t
+k3imC4f7U+wSE6zILaDZyzygA4RUbwG0gv8/TJVn2P/Eynf76DuWHGlaiLWnCbSz
+Az2DHBQBBaku409zDQym3j1ugMRjzzSQWzJg0SIyBH3hTmnYcn3+Uqcp/lEBvGW6
+O+rsXFt3pukqJmIV8HzLGGaLm62BHUeZf3dyWm+i3p/hQAL7Xvu04QW70xuGqdr5
+afV7p5eaeQIJXyGQJ0eylV/90+qxjMKiB1XYg6WYvwKBwQCL/ddpgOdHJGN8uRom
+e7Zq0Csi3hGheMKlKbN3vcxT5U7MdyHtTZZOJbTvxKNNUNYH/8uD+PqDGNneb29G
+BfGzvI3EASyLIcGZF3OhKwZd0jUrWk2y7Vhob91jwp2+t73vdMbkKyI4mHOuXvGv
+fg95si9oO7EBT+Oqvhccd2J+F1IVXncccYnF4u5ZGWt5lLewN/pVr7MjjykeaHqN
+t+rfnQam2psA6fL4zS2zTmZPzR2tnY8Y1GBTi0Ko1OKd1HMCgcAb5cB/7/AQlhP9
+yQa04PLH9ygQkKKptZp7dy5WcWRx0K/hAHRoi2aw1wZqfm7VBNu2SLcs90kCCCxp
+6C5sfJi6b8NpNbIPC+sc9wsFr7pGo9SFzQ78UlcWYK2Gu2FxlMjonhka5hvo4zvg
+WxlpXKEkaFt3gLd92m/dMqBrHfafH7VwOJY2zT3WIpjwuk0ZzmRg5p0pG/svVQEH
+NZmwRwlopysbR69B/n1nefJ84UO50fLh5s5Zr3gBRwbWNZyzhXk=
+-----END RSA PRIVATE KEY-----
diff --git a/trusted-mesatee-sdk/keys/ias_root_ca_cert.pem b/trusted-mesatee-sdk/keys/ias_root_ca_cert.pem
new file mode 100644
index 0000000..948b4c0
--- /dev/null
+++ b/trusted-mesatee-sdk/keys/ias_root_ca_cert.pem
@@ -0,0 +1,31 @@
+-----BEGIN CERTIFICATE-----
+MIIFSzCCA7OgAwIBAgIJANEHdl0yo7CUMA0GCSqGSIb3DQEBCwUAMH4xCzAJBgNV
+BAYTAlVTMQswCQYDVQQIDAJDQTEUMBIGA1UEBwwLU2FudGEgQ2xhcmExGjAYBgNV
+BAoMEUludGVsIENvcnBvcmF0aW9uMTAwLgYDVQQDDCdJbnRlbCBTR1ggQXR0ZXN0
+YXRpb24gUmVwb3J0IFNpZ25pbmcgQ0EwIBcNMTYxMTE0MTUzNzMxWhgPMjA0OTEy
+MzEyMzU5NTlaMH4xCzAJBgNVBAYTAlVTMQswCQYDVQQIDAJDQTEUMBIGA1UEBwwL
+U2FudGEgQ2xhcmExGjAYBgNVBAoMEUludGVsIENvcnBvcmF0aW9uMTAwLgYDVQQD
+DCdJbnRlbCBTR1ggQXR0ZXN0YXRpb24gUmVwb3J0IFNpZ25pbmcgQ0EwggGiMA0G
+CSqGSIb3DQEBAQUAA4IBjwAwggGKAoIBgQCfPGR+tXc8u1EtJzLA10Feu1Wg+p7e
+LmSRmeaCHbkQ1TF3Nwl3RmpqXkeGzNLd69QUnWovYyVSndEMyYc3sHecGgfinEeh
+rgBJSEdsSJ9FpaFdesjsxqzGRa20PYdnnfWcCTvFoulpbFR4VBuXnnVLVzkUvlXT
+L/TAnd8nIZk0zZkFJ7P5LtePvykkar7LcSQO85wtcQe0R1Raf/sQ6wYKaKmFgCGe
+NpEJUmg4ktal4qgIAxk+QHUxQE42sxViN5mqglB0QJdUot/o9a/V/mMeH8KvOAiQ
+byinkNndn+Bgk5sSV5DFgF0DffVqmVMblt5p3jPtImzBIH0QQrXJq39AT8cRwP5H
+afuVeLHcDsRp6hol4P+ZFIhu8mmbI1u0hH3W/0C2BuYXB5PC+5izFFh/nP0lc2Lf
+6rELO9LZdnOhpL1ExFOq9H/B8tPQ84T3Sgb4nAifDabNt/zu6MmCGo5U8lwEFtGM
+RoOaX4AS+909x00lYnmtwsDVWv9vBiJCXRsCAwEAAaOByTCBxjBgBgNVHR8EWTBX
+MFWgU6BRhk9odHRwOi8vdHJ1c3RlZHNlcnZpY2VzLmludGVsLmNvbS9jb250ZW50
+L0NSTC9TR1gvQXR0ZXN0YXRpb25SZXBvcnRTaWduaW5nQ0EuY3JsMB0GA1UdDgQW
+BBR4Q3t2pn680K9+QjfrNXw7hwFRPDAfBgNVHSMEGDAWgBR4Q3t2pn680K9+Qjfr
+NXw7hwFRPDAOBgNVHQ8BAf8EBAMCAQYwEgYDVR0TAQH/BAgwBgEB/wIBADANBgkq
+hkiG9w0BAQsFAAOCAYEAeF8tYMXICvQqeXYQITkV2oLJsp6J4JAqJabHWxYJHGir
+IEqucRiJSSx+HjIJEUVaj8E0QjEud6Y5lNmXlcjqRXaCPOqK0eGRz6hi+ripMtPZ
+sFNaBwLQVV905SDjAzDzNIDnrcnXyB4gcDFCvwDFKKgLRjOB/WAqgscDUoGq5ZVi
+zLUzTqiQPmULAQaB9c6Oti6snEFJiCQ67JLyW/E83/frzCmO5Ru6WjU4tmsmy8Ra
+Ud4APK0wZTGtfPXU7w+IBdG5Ez0kE1qzxGQaL4gINJ1zMyleDnbuS8UicjJijvqA
+152Sq049ESDz+1rRGc2NVEqh1KaGXmtXvqxXcTB+Ljy5Bw2ke0v8iGngFBPqCTVB
+3op5KBG3RjbF6RRSzwzuWfL7QErNC8WEy5yDVARzTA5+xmBc388v9Dm21HGfcC8O
+DD+gT9sSpssq0ascmvH49MOgjt1yoysLtdCtJW/9FZpoOypaHx0R+mJTLwPXVMrv
+DaVzWh5aiEx+idkSGMnX
+-----END CERTIFICATE-----
diff --git a/trusted-mesatee-sdk/mesatee_core/Cargo.lock b/trusted-mesatee-sdk/mesatee_core/Cargo.lock
new file mode 100644
index 0000000..a1b3cab
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/Cargo.lock
@@ -0,0 +1,958 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+[[package]]
+name = "aho-corasick"
+version = "0.7.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8716408b8bc624ed7f65d223ddb9ac2d044c0547b6fa4b0d554f3a9540496ada"
+dependencies = [
+ "memchr",
+]
+
+[[package]]
+name = "anyhow"
+version = "1.0.28"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d9a60d744a80c30fcb657dfe2c1b22bcb3e814c1a1e3674f32bf5820b570fbff"
+
+[[package]]
+name = "atty"
+version = "0.2.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d9b39be18770d11421cdb1b9947a45dd3f37e93092cbf377614828a319d5fee8"
+dependencies = [
+ "hermit-abi",
+ "libc",
+ "winapi",
+]
+
+[[package]]
+name = "autocfg"
+version = "0.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1d49d90015b3c36167a20fe2810c5cd875ad504b39cff3d4eae7977e6b7c1cb2"
+
+[[package]]
+name = "autocfg"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f8aac770f1885fd7e387acedd76065302551364496e46b3dd00860b2f8359b9d"
+
+[[package]]
+name = "base64"
+version = "0.10.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0b25d992356d2eb0ed82172f5248873db5560c4721f564b13cb5193bda5e668e"
+dependencies = [
+ "byteorder",
+]
+
+[[package]]
+name = "bit-vec"
+version = "0.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a4523a10839ffae575fb08aa3423026c8cb4687eef43952afb956229d4f246f7"
+
+[[package]]
+name = "bitflags"
+version = "1.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693"
+
+[[package]]
+name = "bumpalo"
+version = "3.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "12ae9db68ad7fac5fe51304d20f016c911539251075a214f8e663babefa35187"
+
+[[package]]
+name = "byteorder"
+version = "1.3.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "08c48aae112d48ed9f069b33538ea9e3e90aa263cfa3d1c24309612b1f7472de"
+
+[[package]]
+name = "cc"
+version = "1.0.50"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "95e28fa049fda1c330bcf9d723be7663a899c4679724b34c81e9f5a326aab8cd"
+
+[[package]]
+name = "cfg-if"
+version = "0.1.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822"
+
+[[package]]
+name = "chrono"
+version = "0.4.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "80094f509cf8b5ae86a4966a39b3ff66cd7e2a3e594accec3743ff3fabeab5b2"
+dependencies = [
+ "num-integer",
+ "num-traits",
+ "time",
+]
+
+[[package]]
+name = "cloudabi"
+version = "0.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f"
+dependencies = [
+ "bitflags",
+]
+
+[[package]]
+name = "env_logger"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "44533bbbb3bb3c1fa17d9f2e4e38bbbaf8396ba82193c4cb1b6445d711445d36"
+dependencies = [
+ "atty",
+ "humantime",
+ "log",
+ "regex",
+ "termcolor",
+]
+
+[[package]]
+name = "fuchsia-cprng"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a06f77d526c1a601b7c4cdd98f54b5eaabffc14d5f2f0296febdc7f357c6d3ba"
+
+[[package]]
+name = "hashbrown_tstd"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3c57e7f2e84e024aff147279232fa17a5940ebcb7a6c9e6343a8f13adad3125c"
+dependencies = [
+ "autocfg 1.0.0",
+]
+
+[[package]]
+name = "hermit-abi"
+version = "0.1.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "725cf19794cf90aa94e65050cb4191ff5d8fa87a498383774c47b332e3af952e"
+dependencies = [
+ "libc",
+]
+
+[[package]]
+name = "httparse"
+version = "1.3.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cd179ae861f0c2e53da70d892f5f3029f9594be0c41dc5269cd371691b1dc2f9"
+
+[[package]]
+name = "humantime"
+version = "1.3.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "df004cfca50ef23c36850aaaa59ad52cc70d0e90243c3c7737a4dd32dc7a3c4f"
+dependencies = [
+ "quick-error",
+]
+
+[[package]]
+name = "ipc_attribute"
+version = "0.1.0"
+dependencies = [
+ "quote 0.6.13",
+ "syn 0.15.44",
+]
+
+[[package]]
+name = "itoa"
+version = "0.4.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b8b7a7c0c47db5545ed3fef7468ee7bb5b74691498139e4b3f6a20685dc6dd8e"
+
+[[package]]
+name = "js-sys"
+version = "0.3.37"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6a27d435371a2fa5b6d2b028a74bbdb1234f308da363226a2854ca3ff8ba7055"
+dependencies = [
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "lazy_static"
+version = "1.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"
+dependencies = [
+ "spin",
+]
+
+[[package]]
+name = "libc"
+version = "0.2.68"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "dea0c0405123bba743ee3f91f49b1c7cfb684eef0da0a50110f758ccf24cdff0"
+
+[[package]]
+name = "log"
+version = "0.4.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "14b6052be84e6b71ab17edffc2eeabf5c2c3ae1fdb464aae35ac50c67a44e1f7"
+dependencies = [
+ "cfg-if",
+]
+
+[[package]]
+name = "memchr"
+version = "2.3.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3728d817d99e5ac407411fa471ff9800a778d88a24685968b36824eaf4bee400"
+
+[[package]]
+name = "mesatee_core"
+version = "0.1.0"
+dependencies = [
+ "base64",
+ "bit-vec",
+ "cfg-if",
+ "chrono",
+ "env_logger",
+ "httparse",
+ "ipc_attribute",
+ "lazy_static",
+ "log",
+ "net2",
+ "num-bigint",
+ "ring",
+ "rustls",
+ "serde",
+ "serde_derive",
+ "serde_json",
+ "sgx_rand",
+ "sgx_tcrypto",
+ "sgx_tse",
+ "sgx_tstd",
+ "sgx_types",
+ "sgx_urts",
+ "teaclave_attestation",
+ "teaclave_config",
+ "teaclave_utils",
+ "toml",
+ "uuid",
+ "webpki",
+ "webpki-roots",
+ "yasna",
+]
+
+[[package]]
+name = "net2"
+version = "0.2.33"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "42550d9fb7b6684a6d404d9fa7250c2eb2646df731d1c06afc06dcee9e1bcf88"
+dependencies = [
+ "cfg-if",
+ "libc",
+ "winapi",
+]
+
+[[package]]
+name = "num-bigint"
+version = "0.2.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "090c7f9998ee0ff65aa5b723e4009f7b217707f1fb5ea551329cc4d6231fb304"
+dependencies = [
+ "autocfg 1.0.0",
+ "num-integer",
+ "num-traits",
+]
+
+[[package]]
+name = "num-integer"
+version = "0.1.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "3f6ea62e9d81a77cd3ee9a2a5b9b609447857f3d358704331e4ef39eb247fcba"
+dependencies = [
+ "autocfg 1.0.0",
+ "num-traits",
+]
+
+[[package]]
+name = "num-traits"
+version = "0.2.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "c62be47e61d1842b9170f0fdeec8eba98e60e90e5446449a0545e5152acd7096"
+dependencies = [
+ "autocfg 1.0.0",
+]
+
+[[package]]
+name = "proc-macro2"
+version = "0.4.30"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cf3d2011ab5c909338f7887f4fc896d35932e29146c12c8d01da6b22a80ba759"
+dependencies = [
+ "unicode-xid 0.1.0",
+]
+
+[[package]]
+name = "proc-macro2"
+version = "1.0.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "df246d292ff63439fea9bc8c0a270bed0e390d5ebd4db4ba15aba81111b5abe3"
+dependencies = [
+ "unicode-xid 0.2.0",
+]
+
+[[package]]
+name = "quick-error"
+version = "1.2.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a1d01941d82fa2ab50be1e79e6714289dd7cde78eba4c074bc5a4374f650dfe0"
+
+[[package]]
+name = "quote"
+version = "0.6.13"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6ce23b6b870e8f94f81fb0a363d65d86675884b34a09043c81e5562f11c1f8e1"
+dependencies = [
+ "proc-macro2 0.4.30",
+]
+
+[[package]]
+name = "quote"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2bdc6c187c65bca4260c9011c9e3132efe4909da44726bad24cf7572ae338d7f"
+dependencies = [
+ "proc-macro2 1.0.10",
+]
+
+[[package]]
+name = "rand"
+version = "0.6.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6d71dacdc3c88c1fde3885a3be3fbab9f35724e6ce99467f7d9c5026132184ca"
+dependencies = [
+ "autocfg 0.1.7",
+ "libc",
+ "rand_chacha",
+ "rand_core 0.4.2",
+ "rand_hc",
+ "rand_isaac",
+ "rand_jitter",
+ "rand_os",
+ "rand_pcg",
+ "rand_xorshift",
+ "winapi",
+]
+
+[[package]]
+name = "rand_chacha"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "556d3a1ca6600bfcbab7c7c91ccb085ac7fbbcd70e008a98742e7847f4f7bcef"
+dependencies = [
+ "autocfg 0.1.7",
+ "rand_core 0.3.1",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7a6fdeb83b075e8266dcc8762c22776f6877a63111121f5f8c7411e5be7eed4b"
+dependencies = [
+ "rand_core 0.4.2",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9c33a3c44ca05fa6f1807d8e6743f3824e8509beca625669633be0acbdf509dc"
+
+[[package]]
+name = "rand_hc"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7b40677c7be09ae76218dc623efbf7b18e34bced3f38883af07bb75630a21bc4"
+dependencies = [
+ "rand_core 0.3.1",
+]
+
+[[package]]
+name = "rand_isaac"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ded997c9d5f13925be2a6fd7e66bf1872597f759fd9dd93513dd7e92e5a5ee08"
+dependencies = [
+ "rand_core 0.3.1",
+]
+
+[[package]]
+name = "rand_jitter"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1166d5c91dc97b88d1decc3285bb0a99ed84b05cfd0bc2341bdf2d43fc41e39b"
+dependencies = [
+ "libc",
+ "rand_core 0.4.2",
+ "winapi",
+]
+
+[[package]]
+name = "rand_os"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7b75f676a1e053fc562eafbb47838d67c84801e38fc1ba459e8f180deabd5071"
+dependencies = [
+ "cloudabi",
+ "fuchsia-cprng",
+ "libc",
+ "rand_core 0.4.2",
+ "rdrand",
+ "winapi",
+]
+
+[[package]]
+name = "rand_pcg"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "abf9b09b01790cfe0364f52bf32995ea3c39f4d2dd011eac241d2914146d0b44"
+dependencies = [
+ "autocfg 0.1.7",
+ "rand_core 0.4.2",
+]
+
+[[package]]
+name = "rand_xorshift"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cbf7e9e623549b0e21f6e97cf8ecf247c1a8fd2e8a992ae265314300b2455d5c"
+dependencies = [
+ "rand_core 0.3.1",
+]
+
+[[package]]
+name = "rdrand"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "678054eb77286b51581ba43620cc911abf02758c91f93f479767aed0f90458b2"
+dependencies = [
+ "rand_core 0.3.1",
+]
+
+[[package]]
+name = "redox_syscall"
+version = "0.1.56"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2439c63f3f6139d1b57529d16bc3b8bb855230c8efcc5d3a896c8bea7c3b1e84"
+
+[[package]]
+name = "regex"
+version = "1.3.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7f6946991529684867e47d86474e3a6d0c0ab9b82d5821e314b1ede31fa3a4b3"
+dependencies = [
+ "aho-corasick",
+ "memchr",
+ "regex-syntax",
+ "thread_local",
+]
+
+[[package]]
+name = "regex-syntax"
+version = "0.6.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7fe5bd57d1d7414c6b5ed48563a2c855d995ff777729dcd91c369ec7fea395ae"
+
+[[package]]
+name = "ring"
+version = "0.16.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "1ba5a8ec64ee89a76c98c549af81ff14813df09c3e6dc4766c3856da48597a0c"
+dependencies = [
+ "cc",
+ "lazy_static",
+ "libc",
+ "spin",
+ "untrusted",
+ "web-sys",
+ "winapi",
+]
+
+[[package]]
+name = "rustls"
+version = "0.16.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "b25a18b1bf7387f0145e7f8324e700805aade3842dd3db2e74e4cdeb4677c09e"
+dependencies = [
+ "base64",
+ "log",
+ "ring",
+ "sct",
+ "webpki",
+]
+
+[[package]]
+name = "ryu"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "535622e6be132bccd223f4bb2b8ac8d53cda3c7a6394944d3b2b33fb974f9d76"
+
+[[package]]
+name = "sct"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "e3042af939fca8c3453b7af0f1c66e533a15a86169e39de2657310ade8f98d3c"
+dependencies = [
+ "ring",
+ "untrusted",
+]
+
+[[package]]
+name = "serde"
+version = "1.0.106"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "36df6ac6412072f67cf767ebbde4133a5b2e88e76dc6187fa7104cd16f783399"
+
+[[package]]
+name = "serde_derive"
+version = "1.0.106"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9e549e3abf4fb8621bd1609f11dfc9f5e50320802273b12f3811a67e6716ea6c"
+dependencies = [
+ "proc-macro2 1.0.10",
+ "quote 1.0.3",
+ "syn 1.0.17",
+]
+
+[[package]]
+name = "serde_json"
+version = "1.0.51"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "da07b57ee2623368351e9a0488bb0b261322a15a6e0ae53e243cbdc0f4208da9"
+dependencies = [
+ "itoa",
+ "ryu",
+ "serde",
+]
+
+[[package]]
+name = "sgx_alloc"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "84804a804cb6af05d4cc88c922100c8a118c23a8dd358a058b792b754a0defba"
+
+[[package]]
+name = "sgx_backtrace_sys"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d130c6906fd90640248619b9f30b9978e551d9848dbadd45d5dded534f77fcf8"
+dependencies = [
+ "cc",
+ "sgx_build_helper",
+ "sgx_libc",
+]
+
+[[package]]
+name = "sgx_build_helper"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2554e308f6aacd9198eac74d99fe72dd079c83e2e6de4e1af475bfe352ddb0df"
+
+[[package]]
+name = "sgx_demangle"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "df2a91c68258d157180f995639dc4f57414447709fbd0acf53ca1afb5fd9c410"
+
+[[package]]
+name = "sgx_libc"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fee2c4cbe19e311ed879fa44471208cc0dc63ea7eb84cc65c65d3c0e5909242f"
+dependencies = [
+ "sgx_types",
+]
+
+[[package]]
+name = "sgx_rand"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "cc4072d8271d7b7768ddf7e437c353bd4391a2a805a3e8ec3da231c950905aff"
+dependencies = [
+ "sgx_trts",
+ "sgx_tstd",
+ "sgx_types",
+]
+
+[[package]]
+name = "sgx_tcrypto"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fab75120c28a11c13f4e9879c6ab9ef1203ba91a59de1d2fbf42b854d10b3bae"
+dependencies = [
+ "sgx_types",
+]
+
+[[package]]
+name = "sgx_tprotected_fs"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "639522f180dad519af8ea5e5cc1cffdc84f585030acadb313ad333e27701300d"
+dependencies = [
+ "sgx_trts",
+ "sgx_types",
+]
+
+[[package]]
+name = "sgx_trts"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "63e3a84fb7cc0151f9c0d83c57dce4a29a9a619b8259e2473cca6b4aba0a94bc"
+dependencies = [
+ "sgx_libc",
+ "sgx_types",
+]
+
+[[package]]
+name = "sgx_tse"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6bb1eecaba028749a185674c055d200d622f8cbd27aac302115e66b4935cb4c4"
+dependencies = [
+ "sgx_types",
+]
+
+[[package]]
+name = "sgx_tstd"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "5770678ad6b38d4ed7bf01be8e5f450ba60f3e54a3622d9c1a0f8626a744d871"
+dependencies = [
+ "hashbrown_tstd",
+ "sgx_alloc",
+ "sgx_backtrace_sys",
+ "sgx_demangle",
+ "sgx_libc",
+ "sgx_tprotected_fs",
+ "sgx_trts",
+ "sgx_types",
+ "sgx_unwind",
+]
+
+[[package]]
+name = "sgx_types"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "df329127455d6a2964782739218468878770a6dc54cb037b6c9c8846fe09d362"
+
+[[package]]
+name = "sgx_unwind"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "879db0855ab3c42027670722fc6d9d3d8cc7dc0aa674d0509e585951f6d3b203"
+dependencies = [
+ "sgx_build_helper",
+]
+
+[[package]]
+name = "sgx_urts"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "7a660e4b8f9cd8f740fecb220672afd3b4b43d048d4293ed80c2dadef5e46788"
+dependencies = [
+ "libc",
+ "sgx_types",
+]
+
+[[package]]
+name = "spin"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "6e63cff320ae2c57904679ba7cb63280a3dc4613885beafb148ee7bf9aa9042d"
+
+[[package]]
+name = "syn"
+version = "0.15.44"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "9ca4b3b69a77cbe1ffc9e198781b7acb0c7365a883670e8f1c1bc66fba79a5c5"
+dependencies = [
+ "proc-macro2 0.4.30",
+ "quote 0.6.13",
+ "unicode-xid 0.1.0",
+]
+
+[[package]]
+name = "syn"
+version = "1.0.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "0df0eb663f387145cab623dea85b09c2c5b4b0aef44e945d928e682fce71bb03"
+dependencies = [
+ "proc-macro2 1.0.10",
+ "quote 1.0.3",
+ "unicode-xid 0.2.0",
+]
+
+[[package]]
+name = "teaclave_attestation"
+version = "0.1.0"
+dependencies = [
+ "anyhow",
+ "base64",
+ "bit-vec",
+ "cfg-if",
+ "chrono",
+ "httparse",
+ "log",
+ "num-bigint",
+ "rustls",
+ "serde_json",
+ "sgx_rand",
+ "sgx_tcrypto",
+ "sgx_tse",
+ "sgx_tstd",
+ "sgx_types",
+ "teaclave_config",
+ "teaclave_utils",
+ "thiserror",
+ "uuid",
+ "webpki",
+ "webpki-roots",
+ "yasna",
+]
+
+[[package]]
+name = "teaclave_config"
+version = "0.1.0"
+dependencies = [
+ "lazy_static",
+ "log",
+ "serde",
+ "serde_derive",
+ "sgx_tstd",
+ "toml",
+]
+
+[[package]]
+name = "teaclave_utils"
+version = "0.1.0"
+dependencies = [
+ "ring",
+ "serde",
+ "serde_derive",
+ "sgx_tstd",
+ "sgx_types",
+ "toml",
+]
+
+[[package]]
+name = "termcolor"
+version = "1.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "bb6bfa289a4d7c5766392812c0a1f4c1ba45afa1ad47803c11e1f407d846d75f"
+dependencies = [
+ "winapi-util",
+]
+
+[[package]]
+name = "thiserror"
+version = "1.0.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f0570dc61221295909abdb95c739f2e74325e14293b2026b0a7e195091ec54ae"
+dependencies = [
+ "thiserror-impl",
+]
+
+[[package]]
+name = "thiserror-impl"
+version = "1.0.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "227362df41d566be41a28f64401e07a043157c21c14b9785a0d8e256f940a8fd"
+dependencies = [
+ "proc-macro2 1.0.10",
+ "quote 1.0.3",
+ "syn 1.0.17",
+]
+
+[[package]]
+name = "thread_local"
+version = "1.0.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d40c6d1b69745a6ec6fb1ca717914848da4b44ae29d9b3080cbee91d72a69b14"
+dependencies = [
+ "lazy_static",
+]
+
+[[package]]
+name = "time"
+version = "0.1.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "db8dcfca086c1143c9270ac42a2bbd8a7ee477b78ac8e45b19abfb0cbede4b6f"
+dependencies = [
+ "libc",
+ "redox_syscall",
+ "winapi",
+]
+
+[[package]]
+name = "toml"
+version = "0.5.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ffc92d160b1eef40665be3a05630d003936a3bc7da7421277846c2613e92c71a"
+dependencies = [
+ "serde",
+]
+
+[[package]]
+name = "unicode-xid"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fc72304796d0818e357ead4e000d19c9c174ab23dc11093ac919054d20a6a7fc"
+
+[[package]]
+name = "unicode-xid"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c"
+
+[[package]]
+name = "untrusted"
+version = "0.7.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "60369ef7a31de49bcb3f6ca728d4ba7300d9a1658f94c727d4cab8c8d9f4aece"
+
+[[package]]
+name = "uuid"
+version = "0.7.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "90dbc611eb48397705a6b0f6e917da23ae517e4d127123d2cf7674206627d32a"
+dependencies = [
+ "rand",
+]
+
+[[package]]
+name = "wasm-bindgen"
+version = "0.2.60"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2cc57ce05287f8376e998cbddfb4c8cb43b84a7ec55cf4551d7c00eef317a47f"
+dependencies = [
+ "cfg-if",
+ "wasm-bindgen-macro",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.60"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d967d37bf6c16cca2973ca3af071d0a2523392e4a594548155d89a678f4237cd"
+dependencies = [
+ "bumpalo",
+ "lazy_static",
+ "log",
+ "proc-macro2 1.0.10",
+ "quote 1.0.3",
+ "syn 1.0.17",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.60"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8bd151b63e1ea881bb742cd20e1d6127cef28399558f3b5d415289bc41eee3a4"
+dependencies = [
+ "quote 1.0.3",
+ "wasm-bindgen-macro-support",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.60"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "d68a5b36eef1be7868f668632863292e37739656a80fc4b9acec7b0bd35a4931"
+dependencies = [
+ "proc-macro2 1.0.10",
+ "quote 1.0.3",
+ "syn 1.0.17",
+ "wasm-bindgen-backend",
+ "wasm-bindgen-shared",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.60"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "daf76fe7d25ac79748a37538b7daeed1c7a6867c92d3245c12c6222e4a20d639"
+
+[[package]]
+name = "web-sys"
+version = "0.3.37"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "2d6f51648d8c56c366144378a33290049eafdd784071077f6fe37dae64c1c4cb"
+dependencies = [
+ "js-sys",
+ "wasm-bindgen",
+]
+
+[[package]]
+name = "webpki"
+version = "0.21.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "f1f50e1972865d6b1adb54167d1c8ed48606004c2c9d0ea5f1eeb34d95e863ef"
+dependencies = [
+ "ring",
+ "untrusted",
+]
+
+[[package]]
+name = "webpki-roots"
+version = "0.17.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a262ae37dd9d60f60dd473d1158f9fbebf110ba7b6a5051c8160460f6043718b"
+dependencies = [
+ "webpki",
+]
+
+[[package]]
+name = "winapi"
+version = "0.3.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "8093091eeb260906a183e6ae1abdba2ef5ef2257a21801128899c3fc699229c6"
+dependencies = [
+ "winapi-i686-pc-windows-gnu",
+ "winapi-x86_64-pc-windows-gnu",
+]
+
+[[package]]
+name = "winapi-i686-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
+
+[[package]]
+name = "winapi-util"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "fa515c5163a99cc82bab70fd3bfdd36d827be85de63737b40fcef2ce084a436e"
+dependencies = [
+ "winapi",
+]
+
+[[package]]
+name = "winapi-x86_64-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
+
+[[package]]
+name = "yasna"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+checksum = "a563d10ead87e2d798e357d44f40f495ad70bcee4d5c0d3f77a5b1b7376645d9"
+dependencies = [
+ "bit-vec",
+ "chrono",
+ "num-bigint",
+]
diff --git a/trusted-mesatee-sdk/mesatee_core/Cargo.toml b/trusted-mesatee-sdk/mesatee_core/Cargo.toml
new file mode 100644
index 0000000..209bdff
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/Cargo.toml
@@ -0,0 +1,81 @@
+[package]
+name = "mesatee_core"
+version = "0.1.0"
+authors = ["MesaTEE Authors <developers@mesatee.org>"]
+description = "Core of MesaTEE, including IPC/RPC/Error-handling/Database/etc. -- everything you need to develop a TEE services and clients"
+license = "Apache-2.0"
+edition = "2018"
+
+[lib]
+name = "mesatee_core"
+path = "src/lib.rs"
+
+[features]
+default = ["mesalock_sgx"]
+mesalock_sgx = ["sgx_tstd", "sgx_tcrypto", "sgx_rand", "sgx_tse", "ipc", "teaclave_config/mesalock_sgx", "teaclave_utils/mesalock_sgx", "teaclave_attestation/mesalock_sgx"]
+ipc = []
+
+[dependencies]
+#cfg-if       = { version = "0.1.9" }
+#env_logger   = { version = "0.7.1" }
+#lazy_static  = { version = "1.0.2", features = ["spin_no_std"] }
+#log          = { version = "0.4.6" }
+#rustls       = { version = "0.16.0", features = ["dangerous_configuration"] }
+#serde        = { version = "1.0.92" }
+#serde_derive = { version = "1.0.92" }
+#serde_json   = { version = "1.0.39" }
+#chrono       = { version = "0.4.6" }
+#ring         = { version = "0.16.5" }
+#webpki       = { version = "0.21.0" }
+#webpki-roots = { version = "0.19.0" }
+#base64       = { version = "0.10.1" }
+#yasna        = { version = "0.3.0", features = ["bit-vec", "num-bigint", "chrono"] }
+#num-bigint   = { version = "0.2.2" }
+#bit-vec      = { version = "0.6.1", default-features = false }
+#httparse     = { version = "1.3.2", default-features = false }
+#uuid         = { version = "0.8.1", features = ["v4"] }
+#net2         = { version = "0.2.33" }
+#toml         = { version = "0.5.3" }
+
+
+#sgx_tstd     = { version = "1.1.0", features = ["net", "backtrace"], optional = true }
+#sgx_types    = { version = "1.1.0" }
+#sgx_urts     = { version = "1.1.0" }
+#sgx_tcrypto  = { version = "1.1.0", optional = true }
+#sgx_rand     = { version = "1.1.0", optional = true }
+#sgx_tse      = { version = "1.1.0", optional = true }
+
+
+cfg-if       = { version = "0.1.10" }
+env_logger   = { git = "https://github.com/mesalock-linux/env_logger-sgx" }
+lazy_static  = { version = "1.0.2", features = ["spin_no_std"] }
+log          = { git = "https://github.com/mesalock-linux/log-sgx" }
+rustls       = { git = "https://github.com/mesalock-linux/rustls", branch = "mesalock_sgx", features = ["dangerous_configuration"]}
+serde        = { git = "https://github.com/mesalock-linux/serde-sgx" }
+serde_derive = { git = "https://github.com/mesalock-linux/serde-sgx" }
+serde_json   = { git = "https://github.com/mesalock-linux/serde-json-sgx" }
+chrono       = { git = "https://github.com/mesalock-linux/chrono-sgx" }
+ring         = { git = "https://github.com/mesalock-linux/ring-sgx", tag = "v0.16.5" }
+webpki       = { git = "https://github.com/mesalock-linux/webpki", branch = "mesalock_sgx" }
+webpki-roots = { git = "https://github.com/mesalock-linux/webpki-roots", branch = "mesalock_sgx" }
+base64       = { git = "https://github.com/mesalock-linux/rust-base64-sgx" }
+yasna        = { git = "https://github.com/mesalock-linux/yasna.rs-sgx", features = ["bit-vec", "num-bigint", "chrono"] }
+num-bigint      = { git = "https://github.com/mesalock-linux/num-bigint-sgx" }
+bit-vec      = { version = "0.6.1", default-features = false }
+httparse     = { version = "1.3.2", default-features = false }
+uuid         = { git = "https://github.com/mesalock-linux/uuid-sgx", features = ["v4"] }
+net2         = { git = "https://github.com/mesalock-linux/net2-rs-sgx" }
+toml         = { git = "https://github.com/mesalock-linux/toml-rs-sgx"}
+
+
+sgx_tstd     = { rev = "v1.1.2", git = "https://github.com/apache/teaclave-sgx-sdk.git", features = ["net", "backtrace"], optional = true}
+sgx_types    = { rev = "v1.1.2", git = "https://github.com/apache/teaclave-sgx-sdk.git" }
+sgx_urts     = { rev = "v1.1.2", git = "https://github.com/apache/teaclave-sgx-sdk.git" }
+sgx_tcrypto  = { rev = "v1.1.2", git = "https://github.com/apache/teaclave-sgx-sdk.git", optional = true}
+sgx_rand     = { rev = "v1.1.2", git = "https://github.com/apache/teaclave-sgx-sdk.git", optional = true}
+sgx_tse      = { rev = "v1.1.2", git = "https://github.com/apache/teaclave-sgx-sdk.git", optional = true}
+
+teaclave_config = { path = "../teaclave_config" }
+teaclave_utils = { path = "../teaclave_utils" }
+ipc_attribute = { path = "./ipc_attribute" }
+teaclave_attestation = { path = "../teaclave_attestation" }
diff --git a/trusted-mesatee-sdk/mesatee_core/ipc_attribute/Cargo.toml b/trusted-mesatee-sdk/mesatee_core/ipc_attribute/Cargo.toml
new file mode 100644
index 0000000..20dfa4d
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/ipc_attribute/Cargo.toml
@@ -0,0 +1,12 @@
+[package]
+name = "ipc_attribute"
+version = "0.1.0"
+authors = ["root"]
+edition = "2018"
+
+[lib]
+proc-macro = true
+
+[dependencies]
+quote = "0.6"
+syn = { version = "0.15", features = ["full"] }
diff --git a/trusted-mesatee-sdk/mesatee_core/ipc_attribute/src/lib.rs b/trusted-mesatee-sdk/mesatee_core/ipc_attribute/src/lib.rs
new file mode 100644
index 0000000..c6aff52
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/ipc_attribute/src/lib.rs
@@ -0,0 +1,76 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+extern crate proc_macro;
+use proc_macro::TokenStream;
+use quote::quote;
+use syn::parse_macro_input;
+
+#[proc_macro_attribute]
+pub fn handle_ecall(_args: TokenStream, input: TokenStream) -> TokenStream {
+    let f = parse_macro_input!(input as syn::ItemFn);
+    let ident = &f.ident;
+
+    let input_types: Vec<_> = f
+        .decl
+        .inputs
+        .iter()
+        .map(|arg| match arg {
+            &syn::FnArg::Captured(ref val) => &val.ty,
+            _ => unreachable!(),
+        })
+        .collect();
+
+    let args_type = match input_types.first().unwrap() {
+        &syn::Type::Reference(ref r) => &r.elem,
+        _ => unreachable!(),
+    };
+
+    let ret_type = match &f.decl.output {
+        syn::ReturnType::Default => unreachable!(),
+        syn::ReturnType::Type(_, ty) => ty,
+    };
+
+    let generic_type = match **ret_type {
+        syn::Type::Path(ref path) => {
+            let type_params = &path.path.segments.iter().next().unwrap().arguments;
+            let generic_arg = match type_params {
+                syn::PathArguments::AngleBracketed(params) => params.args.iter().next().unwrap(),
+                _ => {
+                    panic!("IPC Macro Attribute: unexpected return type, no AngleBracketed found.")
+                }
+            };
+
+            match generic_arg {
+                syn::GenericArgument::Type(ty) => ty.clone(),
+                _ => panic!("IPC Macro Attribute: unexpected return type, no generic found."),
+            }
+        }
+        _ => panic!("IPC Macro Attribute: unexpected return type."),
+    };
+
+    quote!(
+        impl HandleRequest<#generic_type> for #args_type {
+            fn handle(&self) -> #ret_type {
+                #ident(self)
+            }
+        }
+
+        #f
+    )
+    .into()
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/config/mod.rs b/trusted-mesatee-sdk/mesatee_core/src/config/mod.rs
new file mode 100644
index 0000000..cacecb5
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/config/mod.rs
@@ -0,0 +1,106 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// ip/port is dynamically dispatched for fns client.
+// we cannot use the &'static str in this struct.
+
+use std::collections::HashMap;
+use std::net::SocketAddr;
+use std::prelude::v1::*;
+use teaclave_attestation;
+use teaclave_attestation::verifier::EnclaveAttr;
+use teaclave_config::build_config::BUILD_CONFIG;
+use teaclave_config::runtime_config::RuntimeConfig;
+use teaclave_utils::EnclaveMeasurement;
+
+use lazy_static::lazy_static;
+
+#[derive(Clone)]
+pub struct TargetDesc {
+    pub addr: SocketAddr,
+    pub desc: OutboundDesc,
+}
+
+impl TargetDesc {
+    pub fn new(addr: SocketAddr, desc: OutboundDesc) -> TargetDesc {
+        TargetDesc { addr, desc }
+    }
+}
+
+#[derive(Clone)]
+pub enum InboundDesc {
+    Sgx(EnclaveAttr),
+    External,
+}
+
+#[derive(Clone)]
+pub enum OutboundDesc {
+    Sgx(EnclaveAttr),
+}
+
+impl OutboundDesc {
+    pub fn default() -> OutboundDesc {
+        OutboundDesc::Sgx(get_trusted_enclave_attr(vec!["fns"]))
+    }
+
+    pub fn new(measures: EnclaveMeasurement) -> OutboundDesc {
+        OutboundDesc::Sgx(EnclaveAttr {
+            measures: vec![measures],
+        })
+    }
+}
+
+fn load_presigned_enclave_info() -> HashMap<String, EnclaveMeasurement> {
+    if runtime_config().audit.auditor_signatures.len() < BUILD_CONFIG.auditor_public_keys.len() {
+        panic!("Number of auditor signatures is not enough for verification.")
+    }
+
+    if !teaclave_utils::verify_enclave_info(
+        &runtime_config().audit.enclave_info.as_bytes(),
+        BUILD_CONFIG.auditor_public_keys,
+        &runtime_config().audit.auditor_signatures,
+    ) {
+        panic!("Failed to verify the signatures of enclave info.");
+    }
+
+    teaclave_utils::load_enclave_info(&runtime_config().audit.enclave_info)
+}
+
+lazy_static! {
+    static ref RUNTIME_CONFIG: Option<RuntimeConfig> =
+        RuntimeConfig::from_toml("runtime.config.toml");
+    static ref ENCLAVE_IDENTITIES: HashMap<String, EnclaveMeasurement> =
+        load_presigned_enclave_info();
+}
+
+pub fn is_runtime_config_initialized() -> bool {
+    RUNTIME_CONFIG.is_some()
+}
+
+pub fn runtime_config() -> &'static RuntimeConfig {
+    RUNTIME_CONFIG
+        .as_ref()
+        .expect("Invalid runtime config, should gracefully exit during enclave_init!")
+}
+
+pub fn get_trusted_enclave_attr(service_names: Vec<&str>) -> EnclaveAttr {
+    let measures = service_names
+        .iter()
+        .map(|name| *ENCLAVE_IDENTITIES.get(&(*name).to_string()).unwrap())
+        .collect();
+    EnclaveAttr { measures }
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/db.rs b/trusted-mesatee-sdk/mesatee_core/src/db.rs
new file mode 100644
index 0000000..ecbf6c0
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/db.rs
@@ -0,0 +1,62 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Insert std prelude in the top for the sgx feature
+#[cfg(feature = "mesalock_sgx")]
+use std::prelude::v1::*;
+
+use cfg_if::cfg_if;
+
+// Use target specific definitions here
+cfg_if! {
+    if #[cfg(feature = "mesalock_sgx")]  {
+        use std::sync::SgxRwLock as RwLock;
+    } else {
+        use std::sync::RwLock;
+    }
+}
+
+use crate::Result;
+use std::collections::HashMap;
+use std::hash;
+
+pub struct Memdb<K: Clone + Eq + hash::Hash, V: Clone> {
+    hashmap: RwLock<HashMap<K, V>>,
+}
+
+impl<K: Clone + Eq + hash::Hash, V: Clone> Memdb<K, V> {
+    pub fn open() -> Result<Self> {
+        Ok(Self {
+            hashmap: RwLock::new(HashMap::<K, V>::new()),
+        })
+    }
+
+    pub fn set(&self, key: &K, value: &V) -> Result<Option<V>> {
+        let mut hashmap = self.hashmap.write()?;
+        Ok(hashmap.insert(key.to_owned(), value.to_owned()))
+    }
+
+    pub fn get(&self, key: &K) -> Result<Option<V>> {
+        let hashmap = self.hashmap.read()?;
+        Ok(hashmap.get(key).cloned())
+    }
+
+    pub fn del(&self, key: &K) -> Result<Option<V>> {
+        let mut hashmap = self.hashmap.write()?;
+        Ok(hashmap.remove(key))
+    }
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/error.rs b/trusted-mesatee-sdk/mesatee_core/src/error.rs
new file mode 100644
index 0000000..80bcee1
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/error.rs
@@ -0,0 +1,551 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Insert std prelude in the top for the sgx feature
+#[cfg(feature = "mesalock_sgx")]
+use std::prelude::v1::*;
+
+use std::fmt;
+use std::{io, net};
+use teaclave_utils;
+
+use serde_derive;
+
+pub type Result<T> = std::result::Result<T, Error>;
+
+/// Status for Ecall
+#[repr(C)]
+pub struct EnclaveStatus(u32);
+
+/// Status for Ocall
+pub type UntrustedStatus = EnclaveStatus;
+
+#[derive(serde_derive::Serialize, serde_derive::Deserialize)]
+pub struct Error {
+    repr: Repr,
+}
+
+impl fmt::Debug for Error {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        fmt::Debug::fmt(&self.repr, f)
+    }
+}
+
+#[derive(serde_derive::Serialize, serde_derive::Deserialize)]
+enum Repr {
+    Simple(ErrorKind),
+    #[serde(skip)]
+    Custom(Box<Custom>),
+}
+
+#[derive(Debug)]
+struct Custom {
+    kind: ErrorKind,
+    error: Box<dyn std::error::Error + Send + Sync>,
+}
+
+#[derive(
+    serde_derive::Serialize,
+    serde_derive::Deserialize,
+    Clone,
+    Copy,
+    Debug,
+    Eq,
+    Hash,
+    Ord,
+    PartialEq,
+    PartialOrd,
+)]
+pub enum ErrorKind {
+    /// The operation lacked the necessary privileges to complete.
+    PermissionDenied,
+    /// Expecting a value from option but get None.
+    MissingValue,
+    /// The connection was refused by the remote.
+    ConnectionRefused,
+    /// Internal error during Remote Attestation.
+    RAInternalError,
+    /// Invalid connection refused during Remote Attestion .
+    InvalidRA,
+    /// Error occurred during Internal RPC, happens inside SDK.
+    InternalRPCError,
+    /// Error when sending a request, happens outside SDK.
+    RPCRequestError,
+    /// Error when receiving a response, happens outside SDK.
+    RPCResponseError,
+    /// Implementation errors.
+    BadImplementation,
+    /// Error parsing HTTP.
+    InvalidHTTPRequest,
+    /// Failed to parse
+    ParseError,
+    /// FFI caller provided outbuf too small
+    FFICallerOutBufferTooSmall,
+    /// TEE doesn't support this command
+    ECallCommandNotRegistered,
+    /// IO Error,
+    IoError,
+    /// ECall Error.
+    ECallError,
+    /// OCall Error.
+    OCallError,
+    /// TCP Error.
+    TCPError,
+    /// TLS Error.
+    TLSError,
+    /// Error occurred when retrieving system time.
+    SystemTimeError,
+    /// Error occurred when doing UUID operations.
+    UUIDError,
+    /// Cyprto related errors.
+    CryptoError,
+    /// Error when doing sync primitves operations, e.g. RWLock.
+    SyncPrimitiveError,
+    /// Error when doing ecall/ocall.
+    SgxError,
+    /// Error in untrusted app.
+    UntrustedAppError,
+    /// Error during ffi data converting.
+    FFIError,
+    /// Expect to get key from KMS but failed
+    KeyNotFoundError,
+    /// Function is not supported
+    FunctionNotSupportedError,
+    /// Input provided by users is invalid
+    InvalidInputError,
+    /// Worker failed to generate output
+    OutputGenerationError,
+    /// IPC error
+    IPCError,
+    /// IAS client key or cert not available
+    IASClientKeyCertError,
+    /// No valid worker for the task
+    NoValidWorkerError,
+    /// RPC Message size excceds the limit
+    MsgSizeLimitExceedError,
+    /// Unhandled MesaPy exception encountered
+    MesaPyError,
+    /// RPC input/output is invalid.
+    RpcProtocolError,
+    /// Others.
+    Unknown,
+}
+
+impl EnclaveStatus {
+    pub fn default() -> EnclaveStatus {
+        EnclaveStatus(0)
+    }
+
+    pub fn is_err(&self) -> bool {
+        match self.0 {
+            0 => false,
+            _ => true,
+        }
+    }
+
+    pub fn is_err_ffi_outbuf(&self) -> bool {
+        match Error::from(self.0).kind() {
+            ErrorKind::FFICallerOutBufferTooSmall => true,
+            _ => false,
+        }
+    }
+}
+
+impl From<Result<()>> for EnclaveStatus {
+    #[inline]
+    fn from(r: Result<()>) -> EnclaveStatus {
+        match r {
+            Ok(_) => EnclaveStatus(0),
+            Err(e) => EnclaveStatus(e.into()),
+        }
+    }
+}
+
+impl ErrorKind {
+    pub(crate) fn as_str(self) -> &'static str {
+        match self {
+            ErrorKind::PermissionDenied => "permission denied",
+            ErrorKind::MissingValue => "missing value",
+            ErrorKind::ConnectionRefused => "connection refused",
+            ErrorKind::RAInternalError => "ra internal error",
+            ErrorKind::RPCRequestError => "rpc request error",
+            ErrorKind::RPCResponseError => "rpc response error",
+            ErrorKind::InvalidRA => "invalid ra",
+            ErrorKind::InternalRPCError => "internal rpc error",
+            ErrorKind::BadImplementation => "invalid implementation",
+            ErrorKind::InvalidHTTPRequest => "invalid http request",
+            ErrorKind::ParseError => "failed to parse",
+            ErrorKind::FFICallerOutBufferTooSmall => "ffi caller out buffer too small",
+            ErrorKind::ECallCommandNotRegistered => "ecall command not registered",
+            ErrorKind::IoError => "io error",
+            ErrorKind::ECallError => "ecall error",
+            ErrorKind::OCallError => "ocall error",
+            ErrorKind::TCPError => "tcp error",
+            ErrorKind::TLSError => "tls error",
+            ErrorKind::SystemTimeError => "system time error",
+            ErrorKind::UUIDError => "uuid error",
+            ErrorKind::CryptoError => "crypto error",
+            ErrorKind::SyncPrimitiveError => "sync primitive error",
+            ErrorKind::SgxError => "sgx error",
+            ErrorKind::UntrustedAppError => "untrusted app error",
+            ErrorKind::FFIError => "ffi error",
+            ErrorKind::KeyNotFoundError => "key not found error",
+            ErrorKind::FunctionNotSupportedError => "function not supported error",
+            ErrorKind::InvalidInputError => "invalid user input error",
+            ErrorKind::OutputGenerationError => "generate output error",
+            ErrorKind::IPCError => "ipc error",
+            ErrorKind::IASClientKeyCertError => {
+                "intel attestation service client key/certificate unavailable error"
+            }
+            ErrorKind::NoValidWorkerError => "no valid worker error",
+            ErrorKind::MsgSizeLimitExceedError => "message size exceeds limit",
+            ErrorKind::MesaPyError => "unhandled mesapy exception",
+            ErrorKind::RpcProtocolError => "invalid rpc protocol",
+            ErrorKind::Unknown => "unknown error",
+        }
+    }
+}
+
+impl From<ErrorKind> for Error {
+    #[inline]
+    fn from(kind: ErrorKind) -> Error {
+        Error {
+            repr: Repr::Simple(kind),
+        }
+    }
+}
+
+impl From<u32> for Error {
+    #[inline]
+    fn from(kind: u32) -> Error {
+        let err_kind = match kind {
+            0x0000_0001 => ErrorKind::PermissionDenied,
+            0x0000_0002 => ErrorKind::MissingValue,
+            0x0000_0003 => ErrorKind::ConnectionRefused,
+            0x0000_0004 => ErrorKind::RAInternalError,
+            0x0000_0005 => ErrorKind::InvalidRA,
+            0x0000_0006 => ErrorKind::InternalRPCError,
+            0x0000_0007 => ErrorKind::RPCRequestError,
+            0x0000_0008 => ErrorKind::RPCResponseError,
+            0x0000_0009 => ErrorKind::BadImplementation,
+            0x0000_000a => ErrorKind::InvalidHTTPRequest,
+            0x0000_000b => ErrorKind::ParseError,
+            0x0000_000c => ErrorKind::FFICallerOutBufferTooSmall,
+            0x0000_000d => ErrorKind::ECallCommandNotRegistered,
+            0x0000_1000 => ErrorKind::IoError,
+            0x0000_1001 => ErrorKind::ECallError,
+            0x0000_1002 => ErrorKind::OCallError,
+            0x0000_1003 => ErrorKind::TCPError,
+            0x0000_1004 => ErrorKind::TLSError,
+            0x0000_1005 => ErrorKind::SystemTimeError,
+            0x0000_1006 => ErrorKind::UUIDError,
+            0x0000_1007 => ErrorKind::CryptoError,
+            0x0000_1008 => ErrorKind::SyncPrimitiveError,
+            0x0000_1009 => ErrorKind::SgxError,
+            0x0000_100a => ErrorKind::UntrustedAppError,
+            0x0000_100b => ErrorKind::FFIError,
+            0x0000_100c => ErrorKind::KeyNotFoundError,
+            0x0000_100d => ErrorKind::FunctionNotSupportedError,
+            0x0000_100e => ErrorKind::InvalidInputError,
+            0x0000_100f => ErrorKind::OutputGenerationError,
+            0x0000_1010 => ErrorKind::IPCError,
+            0x0000_1011 => ErrorKind::IASClientKeyCertError,
+            0x0000_1012 => ErrorKind::NoValidWorkerError,
+            0x0000_1013 => ErrorKind::MsgSizeLimitExceedError,
+            0x0000_1014 => ErrorKind::MesaPyError,
+            0x0000_1015 => ErrorKind::RpcProtocolError,
+            _ => ErrorKind::Unknown,
+        };
+
+        Error {
+            repr: Repr::Simple(err_kind),
+        }
+    }
+}
+
+impl Into<u32> for Error {
+    #[inline]
+    fn into(self) -> u32 {
+        match self.kind() {
+            ErrorKind::PermissionDenied => 0x0000_0001,
+            ErrorKind::MissingValue => 0x0000_0002,
+            ErrorKind::ConnectionRefused => 0x0000_0003,
+            ErrorKind::RAInternalError => 0x0000_0004,
+            ErrorKind::InvalidRA => 0x0000_0005,
+            ErrorKind::InternalRPCError => 0x0000_0006,
+            ErrorKind::RPCRequestError => 0x0000_0007,
+            ErrorKind::RPCResponseError => 0x0000_0008,
+            ErrorKind::BadImplementation => 0x0000_0009,
+            ErrorKind::InvalidHTTPRequest => 0x0000_000a,
+            ErrorKind::ParseError => 0x0000_000b,
+            ErrorKind::FFICallerOutBufferTooSmall => 0x0000_000c,
+            ErrorKind::ECallCommandNotRegistered => 0x0000_000d,
+
+            ErrorKind::IoError => 0x0000_1000,
+            ErrorKind::ECallError => 0x0000_1001,
+            ErrorKind::OCallError => 0x0000_1002,
+            ErrorKind::TCPError => 0x0000_1003,
+            ErrorKind::TLSError => 0x0000_1004,
+            ErrorKind::SystemTimeError => 0x0000_1005,
+            ErrorKind::UUIDError => 0x0000_1006,
+            ErrorKind::CryptoError => 0x0000_1007,
+            ErrorKind::SyncPrimitiveError => 0x0000_1008,
+            ErrorKind::SgxError => 0x0000_1009,
+            ErrorKind::UntrustedAppError => 0x0000_100a,
+            ErrorKind::FFIError => 0x0000_100b,
+            ErrorKind::KeyNotFoundError => 0x0000_100c,
+            ErrorKind::FunctionNotSupportedError => 0x0000_100d,
+            ErrorKind::InvalidInputError => 0x0000_100e,
+            ErrorKind::OutputGenerationError => 0x0000_100f,
+            ErrorKind::IPCError => 0x0000_1010,
+            ErrorKind::IASClientKeyCertError => 0x0000_1011,
+            ErrorKind::NoValidWorkerError => 0x0000_1012,
+            ErrorKind::MsgSizeLimitExceedError => 0x0000_1013,
+            ErrorKind::MesaPyError => 0x0000_1014,
+            ErrorKind::RpcProtocolError => 0x0000_1015,
+            ErrorKind::Unknown => 0xffff_ffff,
+        }
+    }
+}
+
+impl Error {
+    pub fn new<E>(kind: ErrorKind, error: E) -> Error
+    where
+        E: Into<Box<dyn std::error::Error + Send + Sync>>,
+    {
+        Self::_new(kind, error.into())
+    }
+
+    fn _new(kind: ErrorKind, error: Box<dyn std::error::Error + Send + Sync>) -> Error {
+        Error {
+            repr: Repr::Custom(Box::new(Custom { kind, error })),
+        }
+    }
+
+    pub fn get_ref(&self) -> Option<&(dyn std::error::Error + Send + Sync + 'static)> {
+        match self.repr {
+            Repr::Simple(..) => None,
+            Repr::Custom(ref c) => Some(&*c.error),
+        }
+    }
+
+    pub fn get_mut(&mut self) -> Option<&mut (dyn std::error::Error + Send + Sync + 'static)> {
+        match self.repr {
+            Repr::Simple(..) => None,
+            Repr::Custom(ref mut c) => Some(&mut *c.error),
+        }
+    }
+
+    pub fn into_inner(self) -> Option<Box<dyn std::error::Error + Send + Sync>> {
+        match self.repr {
+            Repr::Simple(..) => None,
+            Repr::Custom(c) => Some(c.error),
+        }
+    }
+
+    pub fn into_simple_error(self) -> Error {
+        match self.repr {
+            Repr::Simple(_) => self,
+            Repr::Custom(c) => Error::from(c.kind),
+        }
+    }
+
+    pub fn kind(&self) -> ErrorKind {
+        match self.repr {
+            Repr::Custom(ref c) => c.kind,
+            Repr::Simple(kind) => kind,
+        }
+    }
+
+    pub fn unknown() -> Error {
+        Error::from(ErrorKind::Unknown)
+    }
+}
+
+impl fmt::Debug for Repr {
+    fn fmt(&self, fmt: &mut fmt::Formatter<'_>) -> fmt::Result {
+        match *self {
+            Repr::Custom(ref c) => fmt::Debug::fmt(&c, fmt),
+            Repr::Simple(kind) => fmt.debug_tuple("Kind").field(&kind).finish(),
+        }
+    }
+}
+
+impl fmt::Display for Error {
+    fn fmt(&self, fmt: &mut fmt::Formatter) -> fmt::Result {
+        match self.repr {
+            Repr::Custom(ref c) => c.error.fmt(fmt),
+            Repr::Simple(kind) => write!(fmt, "{}", kind.as_str()),
+        }
+    }
+}
+
+impl std::error::Error for Error {
+    fn source(&self) -> Option<&(dyn std::error::Error + 'static)> {
+        match self.repr {
+            Repr::Simple(..) => None,
+            Repr::Custom(ref c) => c.error.source(),
+        }
+    }
+}
+
+impl From<io::Error> for Error {
+    #[inline]
+    fn from(err: io::Error) -> Error {
+        Error::new(ErrorKind::IoError, err)
+    }
+}
+
+impl From<serde_json::Error> for Error {
+    #[inline]
+    fn from(err: serde_json::Error) -> Error {
+        Error::new(ErrorKind::ParseError, err)
+    }
+}
+
+impl From<net::AddrParseError> for Error {
+    #[inline]
+    fn from(err: net::AddrParseError) -> Error {
+        Error::new(ErrorKind::ParseError, err)
+    }
+}
+
+impl From<EnclaveStatus> for Error {
+    #[inline]
+    fn from(status: EnclaveStatus) -> Error {
+        Error::from(status.0)
+    }
+}
+
+impl<T> From<std::sync::PoisonError<T>> for Error {
+    #[inline]
+    fn from(_err: std::sync::PoisonError<T>) -> Error {
+        Error::from(ErrorKind::SyncPrimitiveError)
+    }
+}
+
+impl From<Error> for EnclaveStatus {
+    #[inline]
+    fn from(err: Error) -> EnclaveStatus {
+        EnclaveStatus(err.into())
+    }
+}
+
+impl From<std::str::Utf8Error> for Error {
+    #[inline]
+    fn from(_err: std::str::Utf8Error) -> Error {
+        Error::from(ErrorKind::ParseError)
+    }
+}
+
+use sgx_types;
+impl From<sgx_types::sgx_status_t> for Error {
+    #[inline]
+    fn from(status: sgx_types::sgx_status_t) -> Error {
+        Error::new(ErrorKind::SgxError, SgxStatus::from(status))
+    }
+}
+
+impl From<teaclave_utils::UtilsError> for Error {
+    #[inline]
+    fn from(err: teaclave_utils::UtilsError) -> Error {
+        match err {
+            teaclave_utils::UtilsError::ParseError => Error::from(ErrorKind::ParseError),
+        }
+    }
+}
+
+#[repr(u32)]
+#[derive(Copy, Clone, PartialEq, Eq, Ord, PartialOrd, Debug)]
+pub enum SgxStatus {
+    Inner(sgx_types::sgx_status_t),
+}
+
+impl fmt::Display for SgxStatus {
+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
+        match self {
+            SgxStatus::Inner(x) => write!(f, "{}", x.as_str()),
+        }
+    }
+}
+
+impl From<sgx_types::sgx_status_t> for SgxStatus {
+    #[inline]
+    fn from(status: sgx_types::sgx_status_t) -> SgxStatus {
+        SgxStatus::Inner(status)
+    }
+}
+
+impl std::error::Error for SgxStatus {
+    fn description(&self) -> &str {
+        match self {
+            SgxStatus::Inner(x) => x.as_str(),
+        }
+    }
+}
+
+#[cfg(test)]
+mod test {
+    use super::{Custom, Error, ErrorKind, Repr};
+    use std::boxed::Box;
+    use std::fmt;
+
+    #[test]
+    fn test_debug_error() {
+        let err = Error {
+            repr: Repr::Custom(Box::new(Custom {
+                kind: ErrorKind::Unknown,
+                error: Box::new(Error {
+                    repr: super::Repr::Simple(ErrorKind::Unknown),
+                }),
+            })),
+        };
+        let expected = "Custom { \
+                        kind: Unknown, \
+                        error: Kind(Unknown) \
+                        }"
+        .to_string();
+        assert_eq!(format!("{:?}", err), expected);
+    }
+
+    #[test]
+    fn test_downcasting() {
+        #[derive(Debug)]
+        struct TestError;
+
+        impl fmt::Display for TestError {
+            fn fmt(&self, _: &mut fmt::Formatter<'_>) -> fmt::Result {
+                Ok(())
+            }
+        }
+
+        impl std::error::Error for TestError {
+            fn description(&self) -> &str {
+                "asdf"
+            }
+        }
+
+        // we have to call all of these UFCS style right now since method
+        // resolution won't implicitly drop the Send+Sync bounds
+        let mut err = Error::new(ErrorKind::Unknown, TestError);
+        assert!(err.get_ref().unwrap().is::<TestError>());
+        assert_eq!("asdf", err.get_ref().unwrap().description());
+        assert!(err.get_mut().unwrap().is::<TestError>());
+        let extracted = err.into_inner().unwrap();
+        extracted.downcast::<TestError>().unwrap();
+    }
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/ipc/channel/app_dep.rs b/trusted-mesatee-sdk/mesatee_core/src/ipc/channel/app_dep.rs
new file mode 100644
index 0000000..99ac5ee
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/ipc/channel/app_dep.rs
@@ -0,0 +1,147 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Insert std prelude in the top for the sgx feature
+#[cfg(feature = "mesalock_sgx")]
+use std::prelude::v1::*;
+
+use serde::de::DeserializeOwned;
+use serde::Serialize;
+
+use sgx_types::{sgx_enclave_id_t, sgx_status_t};
+
+use crate::ipc::IpcSender;
+use crate::{EnclaveStatus, Error, Result};
+
+// Delaration of ecall for App, the implementation is in TEE
+// This function is automatically generated by the procedure macro #[ecall_entry_point].
+// fn enclave_init(eid: sgx_enclave_id_t, retval: *mut EnclaveStatus) -> sgx_status_t;
+#[no_mangle]
+extern "C" {
+    fn ecall_ipc_entry_point(
+        eid: sgx_enclave_id_t,
+        retval: *mut EnclaveStatus,
+        cmd: u32,
+        in_buf: *const u8,
+        in_len: usize,
+        out_buf: *mut u8,
+        out_max: usize,
+        out_len: &mut usize,
+    ) -> sgx_status_t;
+}
+
+// Implementation of IPC Sender For App
+// ECallChannel, receiver is implemented in TEE
+pub struct ECallChannel {
+    enclave_id: sgx_enclave_id_t,
+    curr_out_buf_size: usize,
+}
+
+impl ECallChannel {
+    pub fn new(enclave_id: sgx_enclave_id_t) -> ECallChannel {
+        ECallChannel {
+            enclave_id,
+            curr_out_buf_size: 256,
+        }
+    }
+
+    fn ecall_ipc_app_to_tee(&mut self, cmd: u32, request_payload: Vec<u8>) -> Result<Vec<u8>> {
+        debug! {"ecall_ipc_app_to_tee: {:x}, {:x} bytes", cmd, request_payload.len()};
+
+        let in_ptr: *const u8 = request_payload.as_ptr();
+        let in_len: usize = request_payload.len();
+
+        let mut retried = false;
+        let out_buf = loop {
+            let out_max: usize = self.curr_out_buf_size;
+            let mut out_buf: Vec<u8> = Vec::with_capacity(out_max);
+            let mut out_len: usize = out_max;
+            let out_ptr: *mut u8 = out_buf.as_mut_ptr();
+
+            let mut ecall_ret = EnclaveStatus::default();
+
+            let sgx_status = unsafe {
+                ecall_ipc_entry_point(
+                    self.enclave_id,
+                    &mut ecall_ret,
+                    cmd,
+                    in_ptr,
+                    in_len,
+                    out_ptr,
+                    out_max,
+                    &mut out_len,
+                )
+            };
+
+            /* Check sgx return values */
+            if sgx_status != sgx_status_t::SGX_SUCCESS {
+                error!("ecall_ipc_entry_point, app sgx_error:{}", sgx_status);
+                return Err(Error::from(sgx_status));
+            }
+
+            /*
+             * Check rust logic return values
+             * If out_buf is not big enough, realloc based on the returned out_len
+             * We only retry once for once invocation.
+             */
+            if ecall_ret.is_err_ffi_outbuf() && !retried {
+                let e = Error::from(ecall_ret);
+                debug!(
+                    "ecall_ipc_entry_point, expand app request buffer size: {}",
+                    e
+                );
+
+                assert!(out_len > out_max);
+                self.curr_out_buf_size = out_len;
+                retried = true;
+                continue;
+            }
+
+            /*
+             * Check rust logic return values
+             * Transparent deliever the errors to outer logic.
+             */
+            if ecall_ret.is_err() {
+                let e = Error::from(ecall_ret);
+                error!("ecall_ipc_entry_point, app api_error: {}", e);
+                return Err(e);
+            }
+
+            unsafe {
+                out_buf.set_len(out_len);
+            }
+            debug!("ecall_ipc_entry_point OK. App Received Buf: {:?}", out_buf);
+
+            break out_buf;
+        };
+
+        Ok(out_buf)
+    }
+}
+
+impl IpcSender for ECallChannel {
+    fn invoke<U, V>(&mut self, cmd: u32, input: U) -> Result<V>
+    where
+        U: Serialize,
+        V: DeserializeOwned,
+    {
+        let request_payload = serde_json::to_vec(&input)?;
+        let result_buf = self.ecall_ipc_app_to_tee(cmd, request_payload)?;
+        let response: V = serde_json::from_slice(&result_buf)?;
+        Ok(response)
+    }
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/ipc/channel/mod.rs b/trusted-mesatee-sdk/mesatee_core/src/ipc/channel/mod.rs
new file mode 100644
index 0000000..48386ec
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/ipc/channel/mod.rs
@@ -0,0 +1,21 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+mod app_dep;
+mod tee_dep;
+pub use app_dep::ECallChannel;
+pub use tee_dep::ECallReceiver;
diff --git a/trusted-mesatee-sdk/mesatee_core/src/ipc/channel/tee_dep.rs b/trusted-mesatee-sdk/mesatee_core/src/ipc/channel/tee_dep.rs
new file mode 100644
index 0000000..bbc73b2
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/ipc/channel/tee_dep.rs
@@ -0,0 +1,52 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Insert std prelude in the top for the sgx feature
+#[cfg(feature = "mesalock_sgx")]
+use std::prelude::v1::*;
+
+use serde_json;
+
+use crate::DeserializeOwned;
+use crate::Serialize;
+
+use crate::ipc::IpcReceiver;
+use crate::ipc::IpcService;
+use crate::{Error, ErrorKind, Result};
+
+// Implementation of Receiver
+// The receiver is TEE, the sender is App
+pub struct ECallReceiver {}
+
+impl IpcReceiver for ECallReceiver {
+    fn dispatch<U, V, X>(input_payload: &[u8], x: X) -> Result<Vec<u8>>
+    where
+        U: DeserializeOwned,
+        V: Serialize,
+        X: IpcService<U, V>,
+    {
+        let input: U = serde_json::from_slice(&input_payload)
+            .map_err(|e| Error::new(ErrorKind::IPCError, e))?;
+
+        let response = x.handle_invoke(input)?;
+
+        let response_payload =
+            serde_json::to_vec(&response).map_err(|e| Error::new(ErrorKind::IPCError, e))?;
+
+        Ok(response_payload)
+    }
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/ipc/macros.rs b/trusted-mesatee-sdk/mesatee_core/src/ipc/macros.rs
new file mode 100644
index 0000000..7d47896
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/ipc/macros.rs
@@ -0,0 +1,129 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// ATTN: Must bring `use mesatee_core::ipc::IpcReceiver` into scope when use!!
+#[macro_export]
+macro_rules! register_ecall_handler {
+    ( type $cmd_type: ty, $( ($cmd: path, $arg: ty, $ret: ty), )* ) =>
+    {
+        fn ecall_ipc_lib_dispatcher(cmd: u32, input: &[u8]) -> mesatee_core::Result<Vec<u8>> {
+            let cmd = <$cmd_type>::from(cmd);
+            match cmd {
+                $(
+                    $cmd => dispatch_helper::<$arg, $ret>(input),
+                )*
+                _ => return Err(mesatee_core::Error::from(mesatee_core::ErrorKind::ECallCommandNotRegistered)),
+            }
+        }
+
+        // Declear a local trait, the [handle_ecall] attribute macro
+        // will help implement this trait and call user defined function.
+        trait HandleRequest<V> {
+            fn handle(&self) -> mesatee_core::Result<V>;
+        }
+
+        struct ServeInstance<U, V>
+        where
+            U: HandleRequest<V> + mesatee_core::DeserializeOwned,
+            V: mesatee_core::Serialize,
+        {
+            u: std::marker::PhantomData<U>,
+            v: std::marker::PhantomData<V>,
+        }
+
+        impl<U, V> ServeInstance<U, V>
+        where
+            U: HandleRequest<V> + mesatee_core::DeserializeOwned,
+            V: mesatee_core::Serialize,
+        {
+            fn new() -> ServeInstance<U, V> {
+                ServeInstance {
+                    u: std::marker::PhantomData,
+                    v: std::marker::PhantomData,
+                }
+            }
+        }
+
+        impl<U, V> mesatee_core::ipc::IpcService<U, V> for ServeInstance<U, V>
+        where
+            U: HandleRequest<V> + mesatee_core::DeserializeOwned,
+            V: mesatee_core::Serialize,
+        {
+            fn handle_invoke(&self, input: U) -> mesatee_core::Result<V> {
+                input.handle()
+            }
+        }
+
+        fn dispatch_helper<U, V>(input: &[u8]) -> mesatee_core::Result<Vec<u8>>
+        where
+            U: HandleRequest<V> + mesatee_core::DeserializeOwned,
+            V: mesatee_core::Serialize,
+        {
+            let instance = ServeInstance::<U, V>::new();
+            mesatee_core::ipc::channel::ECallReceiver::dispatch(input, instance)
+        }
+
+        // The actual ecall funcation defined in .edl.
+        #[no_mangle]
+        pub extern "C" fn ecall_ipc_entry_point(
+            cmd: u32,
+            in_buf: *const u8,
+            in_len: usize,
+            out_buf: *mut u8,
+            out_max: usize,
+            out_len: &mut usize,
+        ) -> mesatee_core::EnclaveStatus {
+            // The last argument could be either * mut usize, or &mut usize
+            let input_buf: &[u8] = unsafe { std::slice::from_raw_parts(in_buf, in_len) };
+
+            debug!("tee receive cmd: {:x}, input_buf = {:?}", cmd, input_buf);
+
+            let inner_vec = unsafe {
+                match ecall_ipc_lib_dispatcher(cmd, input_buf) {
+                    Ok(out) => out,
+                    Err(e) => {
+                        error!("tee execute cmd: {:x}, error: {}", cmd, e);
+                        return e.into();
+                    }
+                }
+            };
+
+            let inner_len = inner_vec.len();
+
+            // ATTN: We should always set the out_len, no matter whether it is within the buffer range.
+            *out_len = inner_len;
+
+            if inner_len > out_max {
+                debug!("tee before copy out_buf check: out_max={:x} < inner={:x}", out_max, inner_len);
+                return mesatee_core::Error::from(mesatee_core::ErrorKind::FFICallerOutBufferTooSmall).into();
+            }
+
+            // you can use anything to fill out the output buf
+            // another example could be found at crypto sample
+            // https://github.com/baidu/rust-sgx-sdk/blob/master/samplecode/crypto/enclave/src/lib.rs#L151
+            // The following lines use a trick of "constructing a mutable slice in place" using slice::from_raw_parts_mut
+            // You can always use ptr::copy_nonoverlapping to copy a buffer to the output pointer (see the above crypto sample)
+            unsafe {
+                std::ptr::copy_nonoverlapping(inner_vec.as_ptr(), out_buf, inner_len);
+            }
+
+            // out_len would be used in `set_len` in the untrusted app
+            // so out_len cannot be larger than out_max. Additional checks are **required**.
+            Ok(()).into()
+        }
+    }
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/ipc/mod.rs b/trusted-mesatee-sdk/mesatee_core/src/ipc/mod.rs
new file mode 100644
index 0000000..908fc1b
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/ipc/mod.rs
@@ -0,0 +1,65 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Insert std prelude in the top for the sgx feature
+#[cfg(feature = "mesalock_sgx")]
+use std::prelude::v1::*;
+
+use crate::Result;
+use serde::de::DeserializeOwned;
+use serde::Serialize;
+
+// Intra-Process-Communication
+// Developer should split a process into two partitions, App and TEE.
+
+// Caller of an IPC function
+// Generic U: ArgmentsInfo type
+// Generic V: ReturnInfo type
+pub trait IpcSender {
+    fn invoke<U, V>(&mut self, cmd: u32, input: U) -> Result<V>
+    where
+        U: Serialize,
+        V: DeserializeOwned;
+}
+
+// Service Instance of an IPC function
+// Generic U: ArgmentsInfo type
+// Generic V: ReturnInfo type
+pub trait IpcService<U, V>
+where
+    U: DeserializeOwned,
+    V: Serialize,
+{
+    fn handle_invoke(&self, input: U) -> Result<V>;
+}
+
+// Callee of an IPC function
+// Generic U: ArgmentsInfo type
+// Generic V: ReturnInfo type
+// Generic X: Service Instance that serves of <U, V>
+// Dispatch a received input to a specific service instance.
+pub trait IpcReceiver {
+    fn dispatch<U, V, X>(input: &[u8], x: X) -> Result<Vec<u8>>
+    where
+        U: DeserializeOwned,
+        V: Serialize,
+        X: IpcService<U, V>;
+}
+
+pub mod channel;
+pub mod macros;
+pub mod protos;
diff --git a/trusted-mesatee-sdk/mesatee_core/src/ipc/protos/command.rs b/trusted-mesatee-sdk/mesatee_core/src/ipc/protos/command.rs
new file mode 100644
index 0000000..187d86d
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/ipc/protos/command.rs
@@ -0,0 +1,51 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+use std::convert::From;
+
+pub enum ECallCommand {
+    InitEnclave,
+    FinalizeEnclave,
+    RunFunctionalTest,
+    ServeConnection,
+    Unimplemented,
+}
+
+impl From<u32> for ECallCommand {
+    #[inline]
+    fn from(cmd: u32) -> ECallCommand {
+        match cmd {
+            0x0000_1001 => ECallCommand::InitEnclave,
+            0x0000_1002 => ECallCommand::FinalizeEnclave,
+            0x0000_1003 => ECallCommand::RunFunctionalTest,
+            0x0000_1004 => ECallCommand::ServeConnection,
+            _ => ECallCommand::Unimplemented,
+        }
+    }
+}
+
+impl Into<u32> for ECallCommand {
+    #[inline]
+    fn into(self) -> u32 {
+        match self {
+            ECallCommand::InitEnclave => 0x0000_1001,
+            ECallCommand::FinalizeEnclave => 0x0000_1002,
+            ECallCommand::RunFunctionalTest => 0x0000_1003,
+            ECallCommand::ServeConnection => 0x0000_1004,
+            ECallCommand::Unimplemented => 0xffff_ffff,
+        }
+    }
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/ipc/protos/ecall.rs b/trusted-mesatee-sdk/mesatee_core/src/ipc/protos/ecall.rs
new file mode 100644
index 0000000..96ba158
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/ipc/protos/ecall.rs
@@ -0,0 +1,71 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Insert std prelude in the top for the sgx feature
+
+use cfg_if::cfg_if;
+use serde_derive::{Deserialize, Serialize};
+
+// Use target specific definitions here
+cfg_if! {
+    if #[cfg(feature = "mesalock_sgx")]  {
+        use sgx_types::c_int;
+    } else {
+        use std::os::raw::c_int;
+    }
+}
+
+#[derive(Clone, Serialize, Deserialize, Debug, Default)]
+pub struct InitEnclaveInput;
+
+#[derive(Clone, Serialize, Deserialize, Debug, Default)]
+pub struct InitEnclaveOutput;
+
+#[derive(Clone, Serialize, Deserialize, Debug, Default)]
+pub struct FinalizeEnclaveInput;
+
+#[derive(Clone, Serialize, Deserialize, Debug, Default)]
+pub struct FinalizeEnclaveOutput;
+
+#[derive(Clone, Serialize, Deserialize, Debug, Default)]
+pub struct RunFunctionalTestInput;
+
+#[derive(Clone, Serialize, Deserialize, Debug)]
+pub struct RunFunctionalTestOutput {
+    pub failed_count: usize,
+}
+
+#[derive(Clone, Serialize, Deserialize, Debug)]
+pub struct ServeConnectionInput {
+    pub socket_fd: c_int,
+    pub port: u16,
+}
+
+#[derive(Clone, Serialize, Deserialize, Debug, Default)]
+pub struct ServeConnectionOutput;
+
+impl RunFunctionalTestOutput {
+    pub fn new(failed_count: usize) -> RunFunctionalTestOutput {
+        RunFunctionalTestOutput { failed_count }
+    }
+}
+
+impl ServeConnectionInput {
+    pub fn new(socket_fd: c_int, port: u16) -> ServeConnectionInput {
+        ServeConnectionInput { socket_fd, port }
+    }
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/ipc/protos/mod.rs b/trusted-mesatee-sdk/mesatee_core/src/ipc/protos/mod.rs
new file mode 100644
index 0000000..f769ca9
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/ipc/protos/mod.rs
@@ -0,0 +1,21 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+pub mod ecall;
+
+mod command;
+pub use command::ECallCommand;
diff --git a/trusted-mesatee-sdk/mesatee_core/src/ipc/sgx.rs b/trusted-mesatee-sdk/mesatee_core/src/ipc/sgx.rs
new file mode 100644
index 0000000..b5032ab
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/ipc/sgx.rs
@@ -0,0 +1,20 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+//! (intra-pc) for MesaTEE-SGX
+//!
+//! MesaTEE-SGX uses direct ECALL/OCALL interfaces on locali.
diff --git a/trusted-mesatee-sdk/mesatee_core/src/lib.rs b/trusted-mesatee-sdk/mesatee_core/src/lib.rs
new file mode 100644
index 0000000..f55c724
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/lib.rs
@@ -0,0 +1,76 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+#![feature(specialization)] // for mayfail
+
+// Use sgx_tstd to replace Rust's default std
+#![cfg_attr(feature = "mesalock_sgx", no_std)]
+#[cfg(feature = "mesalock_sgx")]
+#[macro_use]
+extern crate sgx_tstd as std;
+
+#[macro_use]
+extern crate log;
+
+#[cfg(feature = "mesalock_sgx")]
+extern crate ring;
+
+pub mod db;
+pub mod rpc; // Syntax sugar for monadic error handling, defined in mayfail.rs
+
+// MesaTEE Error is defined in error.rs
+mod error;
+pub use error::EnclaveStatus;
+pub use error::Error;
+pub use error::ErrorKind;
+pub use error::Result;
+pub use error::UntrustedStatus;
+
+#[cfg(feature = "ipc")]
+pub mod ipc;
+
+// re-export
+#[cfg(feature = "ipc")]
+pub use ipc_attribute;
+
+pub use serde::de::DeserializeOwned;
+pub use serde::Serialize;
+
+pub mod prelude;
+pub mod config;
+
+#[cfg(feature = "mesalock_sgx")]
+pub fn init_service(name: &str) -> Result<()> {
+    use std::backtrace;
+    env_logger::init();
+
+    debug!("Enclave [{}]: Initializing...", name);
+
+    if backtrace::enable_backtrace(format!("{}.signed.so", name), backtrace::PrintFormat::Full)
+        .is_err()
+    {
+        error!("Cannot enable backtrace");
+        return Err(Error::from(ErrorKind::ECallError));
+    }
+    if !config::is_runtime_config_initialized() {
+        error!("Runtime config is not initialized");
+        return Err(Error::from(ErrorKind::ECallError));
+    }
+    crate::rpc::sgx::prelude()?;
+
+    Ok(())
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/prelude.rs b/trusted-mesatee-sdk/mesatee_core/src/prelude.rs
new file mode 100644
index 0000000..e62d5b9
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/prelude.rs
@@ -0,0 +1,57 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+use cfg_if::cfg_if;
+
+cfg_if! {
+    if #[cfg(all(feature = "mesalock_sgx", feature = "ipc"))] {
+        // preludes provided for SGX enclave.
+        pub use crate::register_ecall_handler;
+        pub use crate::rpc::{RpcServer, RpcClient, EnclaveService};
+        pub use crate::rpc::sgx::{Pipe, PipeConfig};
+        pub use crate::ipc::{IpcSender, IpcService, IpcReceiver};
+        pub use crate::ipc::protos::ECallCommand;
+        pub use crate::ipc::protos::ecall::{
+            InitEnclaveInput,
+            InitEnclaveOutput,
+            FinalizeEnclaveInput,
+            FinalizeEnclaveOutput,
+            ServeConnectionInput,
+            ServeConnectionOutput,
+        };
+        pub use crate::ipc_attribute::handle_ecall;
+    } else if #[cfg(all(not(feature = "mesalock_sgx"), feature = "ipc"))] {
+        // preludes provided for sgx_app
+        pub use crate::ipc::protos::ECallCommand;
+        pub use crate::ipc::protos::ecall::{
+            ServeConnectionInput,
+            ServeConnectionOutput,
+        };
+
+    } else if #[cfg(all(not(feature = "mesalock_sgx"), not(feature = "ipc")))] {
+        // preludes provided for unix app
+    } else {
+        // This should not happen!
+        #[deprecated(
+            since = "0.0.0",
+            note = "mesatee_core is being used in wrong feature combination!"
+        )]
+        fn something_bad_happens() {
+            stop_the_compilation // Cannot compile!
+        }
+    }
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/rpc/channel.rs b/trusted-mesatee-sdk/mesatee_core/src/rpc/channel.rs
new file mode 100644
index 0000000..af3b6c7
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/rpc/channel.rs
@@ -0,0 +1,66 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Use sgx_tstd to replace Rust's default std
+#[cfg(feature = "mesalock_sgx")]
+use std::prelude::v1::*;
+
+use crate::rpc::sgx;
+use crate::rpc::RpcClient;
+use crate::Result;
+use net2::TcpBuilder;
+use serde::{de::DeserializeOwned, Serialize};
+
+use teaclave_attestation::verifier::EnclaveAttr;
+use teaclave_attestation::verifier::SgxQuoteVerifier;
+
+pub struct SgxTrustedChannel<U: Serialize, V: DeserializeOwned> {
+    client: sgx::PipeClient<U, V>,
+}
+
+impl<U, V> SgxTrustedChannel<U, V>
+where
+    U: Serialize,
+    V: DeserializeOwned,
+{
+    pub fn new(
+        addr: std::net::SocketAddr,
+        enclave_attr: EnclaveAttr,
+    ) -> Result<SgxTrustedChannel<U, V>> {
+        let tcp_builder = TcpBuilder::new_v4()?;
+        tcp_builder.reuse_address(true)?;
+        let stream = tcp_builder.connect(addr)?;
+        stream.set_nodelay(true)?;
+
+        let config = sgx::PipeClientConfig {
+            tcp: stream,
+            hostname: webpki::DNSNameRef::try_from_ascii_str(
+                format!("{}-{}", "localhost", addr.port()).as_ref(),
+            )
+            .unwrap()
+            .to_owned(),
+            server_verifier: SgxQuoteVerifier::new(enclave_attr),
+        };
+        let client = sgx::PipeClient::<U, V>::open(config)?;
+
+        Ok(SgxTrustedChannel { client })
+    }
+
+    pub fn invoke(&mut self, input: U) -> Result<V> {
+        self.client.invoke(input)
+    }
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/rpc/mod.rs b/trusted-mesatee-sdk/mesatee_core/src/rpc/mod.rs
new file mode 100644
index 0000000..8a85a76
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/rpc/mod.rs
@@ -0,0 +1,135 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+//! rpc support for MesaTEE
+
+// Insert std prelude in the top for the sgx feature
+#[cfg(feature = "mesalock_sgx")]
+use std::prelude::v1::*;
+
+use crate::{Error, ErrorKind, Result};
+use serde::{de::DeserializeOwned, Serialize};
+use std::io::{Read, Write};
+
+mod sendrecv;
+use crate::rpc::sendrecv::*;
+
+// RpcServer takes three generic type and provides two functions:
+// `fn start` to bind the service on the given config
+// `fn serve` is a blocking call contains an event loop in which the handler
+// functions are invoked.
+// Here U is the type of incoming request. V is the type of outgoing response.
+// X is the type of the EnclaveService which is a generic type depends on U
+// and V.
+pub trait RpcServer<U, V, X>: Read + Write
+where
+    U: DeserializeOwned + std::fmt::Debug,
+    V: Serialize + std::fmt::Debug,
+    X: EnclaveService<U, V>,
+    Self: Sized,
+{
+    type Config;
+
+    fn start(config: &Self::Config) -> Result<Self>;
+
+    // This call would block -- contains main loop
+    // Returns error on socket close or any exceptions.
+    // The `loop` here is used for multi-round communications:
+    // Assuming that we have the following codes on the client side
+    // ```
+    // let _ = conn.invoke(first_req).unwrap();
+    // let _ = conn.invoke(second_req).unwrap();
+    // let _ = conn.invoke(third_req).unwrap();
+    // ```
+    // The `serve` function would loop its body for 3 times.
+    fn serve(&mut self, mut x: X) -> Result<()> {
+        loop {
+            // First receive a payload from client
+            let recv_buf: Vec<u8> = receive_vec(self)?;
+
+            // Now we received a payload in recv_buf
+            // recv_buf should be a serialized incoming request U
+            // The server needs deser it into U first
+            let request: U = serde_json::from_slice(&recv_buf)?;
+            debug!("SERVER get request: {:?}", request);
+            let result: Result<V> = x.handle_invoke(request).map_err(|e| e.into_simple_error());
+            debug!("SERVER handle_invoke result: {:?}", result);
+
+            let response = match serde_json::to_vec(&result) {
+                Ok(resp) => resp,
+                Err(_) => {
+                    let r: Result<V> = Err(Error::from(ErrorKind::InternalRPCError));
+                    serde_json::to_vec(&r).expect("infallable")
+                }
+            };
+            debug!("SERVER send response {:?}", response);
+
+            // Now the result is stored in ret and we need to sent it back.
+            // `ret` is cleared here. Performance is not very good.
+            send_vec(self, response)?;
+        }
+    }
+}
+
+pub trait RpcClient<U, V>: Read + Write
+where
+    Self: Sized,
+    U: Serialize,
+    V: DeserializeOwned,
+{
+    type Config: std::marker::Sized;
+
+    fn open(config: Self::Config) -> Result<Self>;
+
+    fn invoke(&mut self, input: U) -> Result<V> {
+        let request_payload: Vec<u8> = serde_json::to_vec(&input)?;
+
+        debug!("CLIENT: sending req: {:?}", request_payload);
+        send_vec(self, request_payload)?;
+
+        let result_buf: Vec<u8> = receive_vec(self)?;
+        debug!("CLIENT: receiving resp: {:?}", result_buf);
+
+        let resp: Result<V> = serde_json::from_slice(&result_buf)?;
+
+        resp
+    }
+}
+
+// EnclaveService takes two generic type and provides
+pub trait EnclaveService<S, T>
+where
+    S: DeserializeOwned,
+    T: Serialize,
+{
+    fn handle_invoke(&mut self, input: S) -> Result<T>;
+}
+
+// With proper `cfg`s we can support SGX client trusted/untrusted at the same
+// time.  But the server supports SGX enclave only.
+
+// TODO: update the following two cfgs if we have a full version sgx rpc
+// It seems that the current sgx examples are also dependent on mod unix,
+// and thus I choose enable this mode either unix and sgx setting.
+// Please reivse this later if we have a dedicated rpc for mesalock_sgx.
+
+pub mod channel;
+#[cfg(feature = "mesalock_sgx")]
+pub mod server;
+
+pub mod sgx;
+pub mod unix;
diff --git a/trusted-mesatee-sdk/mesatee_core/src/rpc/sendrecv.rs b/trusted-mesatee-sdk/mesatee_core/src/rpc/sendrecv.rs
new file mode 100644
index 0000000..bd936cd
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/rpc/sendrecv.rs
@@ -0,0 +1,76 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Insert std prelude in the top for the sgx feature
+#[cfg(feature = "mesalock_sgx")]
+use std::prelude::v1::*;
+
+use std::io::BufReader;
+use std::io::{Read, Write};
+use std::mem::transmute;
+
+//use crate::{Error, ErrorKind, Result};
+use crate::{Result};
+
+
+fn get_send_vec(mut to_send: &mut Vec<u8>) -> Vec<u8> {
+    let buf_len: u64 = to_send.len() as u64;
+    let lbuf: [u8; 8] = unsafe { transmute(buf_len.to_be()) };
+    let mut all_data: Vec<u8> = lbuf.to_vec();
+    all_data.append(&mut to_send);
+
+    all_data
+}
+
+pub fn send_vec<T>(sock: &mut T, mut buff: Vec<u8>) -> Result<()>
+where
+    T: Write,
+{
+    /*
+    if buff.len() as u64 > BUILD_CONFIG.rpc_max_message_size {
+        return Err(Error::from(ErrorKind::MsgSizeLimitExceedError));
+    }*/
+    let send_vec = get_send_vec(&mut buff);
+
+    sock.write_all(&send_vec)?;
+    sock.flush()?;
+
+    Ok(())
+}
+
+pub fn receive_vec<T>(sock: &mut T) -> Result<Vec<u8>>
+where
+    T: Read,
+{
+    let mut br = BufReader::new(sock);
+    let mut lbuf: [u8; 8] = [0; 8];
+
+    br.read_exact(&mut lbuf)?;
+
+    let buf_len: u64 = u64::from_be(unsafe { transmute::<[u8; 8], u64>(lbuf) });
+    /*
+    if buf_len > BUILD_CONFIG.rpc_max_message_size {
+        return Err(Error::from(ErrorKind::MsgSizeLimitExceedError));
+    }
+    */
+
+    let mut recv_buf: Vec<u8> = vec![0u8; buf_len as usize];
+
+    br.read_exact(&mut recv_buf)?;
+
+    Ok(recv_buf)
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/rpc/server.rs b/trusted-mesatee-sdk/mesatee_core/src/rpc/server.rs
new file mode 100644
index 0000000..eb2f1e2
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/rpc/server.rs
@@ -0,0 +1,69 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+use crate::rpc::sgx;
+use crate::rpc::EnclaveService;
+use crate::rpc::RpcServer;
+use crate::Result;
+use serde::{de::DeserializeOwned, Serialize};
+use sgx_types::c_int;
+use teaclave_attestation::verifier::EnclaveAttr;
+use teaclave_attestation::verifier::SgxQuoteVerifier;
+
+pub struct SgxTrustedServer<U, V, X>
+where
+    U: DeserializeOwned + std::fmt::Debug,
+    V: Serialize + std::fmt::Debug,
+    X: EnclaveService<U, V>,
+{
+    config: sgx::PipeConfig,
+    service: X,
+    marker: std::marker::PhantomData<(U, V)>,
+}
+
+impl<U, V, X> SgxTrustedServer<U, V, X>
+where
+    U: DeserializeOwned + std::fmt::Debug,
+    V: Serialize + std::fmt::Debug,
+    X: EnclaveService<U, V>,
+{
+    pub fn new(service: X, fd: c_int, client_attr: Option<EnclaveAttr>) -> Result<Self> {
+        let config = match client_attr {
+            Some(c) => {
+                let client_verifier = SgxQuoteVerifier::new(c);
+                sgx::PipeConfig {
+                    fd,
+                    client_verifier: Some(client_verifier),
+                }
+            }
+            _ => sgx::PipeConfig {
+                fd,
+                client_verifier: None,
+            },
+        };
+        Ok(Self {
+            config,
+            service,
+            marker: std::marker::PhantomData,
+        })
+    }
+
+    pub fn start(self) -> Result<()> {
+        let mut server = sgx::Pipe::start(&self.config)?;
+        server.serve(self.service)
+    }
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/rpc/sgx/client.rs b/trusted-mesatee-sdk/mesatee_core/src/rpc/sgx/client.rs
new file mode 100644
index 0000000..f95bf18
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/rpc/sgx/client.rs
@@ -0,0 +1,120 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+use std::sync::Arc;
+
+use teaclave_attestation::verifier::SgxQuoteVerifier;
+
+#[cfg(feature = "mesalock_sgx")]
+use sgx_types::sgx_sha256_hash_t;
+
+#[cfg(feature = "mesalock_sgx")]
+
+#[cfg(not(feature = "mesalock_sgx"))]
+use std::sync::RwLock;
+#[cfg(feature = "mesalock_sgx")]
+use std::sync::SgxRwLock as RwLock;
+
+use std::collections::HashMap;
+
+use lazy_static::lazy_static;
+
+lazy_static! {
+    static ref CLIENT_CONFIG_CACHE: RwLock<ClientConfigCache> =
+         RwLock::new(ClientConfigCache::default()) ;
+}
+
+// We use sha256 of private_key as the identity of current enclave.
+// The config cache is organized by a hashmap, in which the target
+// enclave_attr is the key.
+#[cfg(feature = "mesalock_sgx")]
+#[derive(Default)]
+struct ClientConfigCache {
+    private_key_sha256: sgx_sha256_hash_t,
+    target_configs: HashMap<Arc<SgxQuoteVerifier>, Arc<rustls::ClientConfig>>,
+}
+
+
+#[cfg(feature = "mesalock_sgx")]
+pub(crate) fn get_tls_config(server_verifier: Arc<SgxQuoteVerifier>) -> Arc<rustls::ClientConfig> {
+    use crate::rpc::sgx::ra::get_current_ra_credential;
+
+    let ra_credential = get_current_ra_credential();
+
+    if let Ok(cfg_cache) = CLIENT_CONFIG_CACHE.try_read() {
+        if let Some(cfg) = cfg_cache.target_configs.get(&server_verifier) {
+            return cfg.clone();
+        }
+    }
+
+    let certs = vec![rustls::Certificate(ra_credential.cert)];
+    let privkey = rustls::PrivateKey(ra_credential.private_key);
+
+    let mut client_cfg = rustls::ClientConfig::new();
+    client_cfg.set_single_client_cert(certs, privkey);
+    client_cfg
+        .dangerous()
+        .set_certificate_verifier(server_verifier.clone());
+    client_cfg.versions.clear();
+    client_cfg.versions.push(rustls::ProtocolVersion::TLSv1_2);
+
+    let final_arc = Arc::new(client_cfg);
+
+    if let Ok(mut cfg_cache) = CLIENT_CONFIG_CACHE.try_write() {
+        if cfg_cache.private_key_sha256 != ra_credential.private_key_sha256 {
+            *cfg_cache = ClientConfigCache {
+                private_key_sha256: ra_credential.private_key_sha256,
+                target_configs: HashMap::new(),
+            }
+        }
+
+        let _ = cfg_cache
+            .target_configs
+            .insert(server_verifier, final_arc.clone());
+    }
+
+    final_arc
+}
+
+/*
+#[cfg(feature = "mesalock_sgx")]
+pub(crate) fn get_tls_config(server_verifier: Arc<SgxQuoteVerifier>) -> Arc<rustls::ClientConfig> {
+    if let Ok(cfg_cache) = CLIENT_CONFIG_CACHE.try_read() {
+        if let Some(cfg) = cfg_cache.target_configs.get(&server_verifier) {
+            return cfg.clone();
+        }
+    }
+
+    let mut client_cfg = rustls::ClientConfig::new();
+
+    client_cfg
+        .dangerous()
+        .set_certificate_verifier(server_verifier.clone());
+    client_cfg.versions.clear();
+    client_cfg.versions.push(rustls::ProtocolVersion::TLSv1_2);
+
+    let final_arc = Arc::new(client_cfg);
+
+    if let Ok(mut cfg_cache) = CLIENT_CONFIG_CACHE.try_write() {
+        let _ = cfg_cache
+            .target_configs
+            .insert(server_verifier, final_arc.clone());
+    }
+
+    final_arc
+}
+*/
diff --git a/trusted-mesatee-sdk/mesatee_core/src/rpc/sgx/mod.rs b/trusted-mesatee-sdk/mesatee_core/src/rpc/sgx/mod.rs
new file mode 100644
index 0000000..127a61d
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/rpc/sgx/mod.rs
@@ -0,0 +1,170 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+//! rpc support for MesaTEE-SGX
+
+// Insert std prelude in the top for the sgx feature
+use serde::{de::DeserializeOwned, Serialize};
+#[cfg(feature = "mesalock_sgx")]
+use sgx_types::c_int;
+use std::io::{self, Read, Write};
+use std::marker::PhantomData;
+use std::net::TcpStream;
+use std::sync::Arc;
+
+#[cfg(feature = "mesalock_sgx")]
+use std::prelude::v1::*;
+
+#[cfg(feature = "mesalock_sgx")]
+use crate::rpc::{EnclaveService, RpcServer};
+
+use crate::rpc::RpcClient;
+use crate::Result;
+
+use teaclave_attestation;
+use teaclave_attestation::verifier::SgxQuoteVerifier;
+
+pub mod client;
+#[cfg(feature = "mesalock_sgx")]
+pub mod server;
+
+#[cfg(feature = "mesalock_sgx")]
+mod ra;
+
+// Export this function for sgx enclave initialization
+#[cfg(feature = "mesalock_sgx")]
+pub fn prelude() -> Result<()> {
+    // Hard coded RACredential validity in seconds for all enclave.
+    // We may allow each enclave to setup its own validity in the future.
+    ra::init_ra_credential(86400u64)
+}
+
+#[cfg(feature = "mesalock_sgx")]
+pub struct PipeConfig {
+    pub fd: c_int,
+    // the SGX server can optionally verify the identity of the client
+    pub client_verifier: Option<SgxQuoteVerifier>,
+}
+
+#[cfg(feature = "mesalock_sgx")]
+pub struct Pipe<U, V, X> {
+    inner: rustls::StreamOwned<rustls::ServerSession, TcpStream>,
+    u: PhantomData<U>,
+    v: PhantomData<V>,
+    x: PhantomData<X>,
+}
+
+#[cfg(feature = "mesalock_sgx")]
+impl<U, V, X> Read for Pipe<U, V, X> {
+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
+        self.inner.read(buf)
+    }
+}
+
+#[cfg(feature = "mesalock_sgx")]
+impl<U, V, X> Write for Pipe<U, V, X> {
+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+        self.inner.write(buf)
+    }
+
+    fn flush(&mut self) -> io::Result<()> {
+        self.inner.flush()
+    }
+}
+
+#[cfg(feature = "mesalock_sgx")]
+impl<U, V, X> RpcServer<U, V, X> for Pipe<U, V, X>
+where
+    U: DeserializeOwned + std::fmt::Debug,
+    V: Serialize + std::fmt::Debug,
+    X: EnclaveService<U, V>,
+{
+    type Config = PipeConfig;
+    fn start(config: &Self::Config) -> Result<Self> {
+        let tcp = TcpStream::new(config.fd)?;
+
+        // TCP set nodelay should not affect the success of this function
+        // We do not care if it is successful or not.
+        // Just do it.
+        let _ = tcp.set_nodelay(true);
+
+        // TODO: Due to switching to the SDK-style design, performing an
+        // initial RA at enclave start is not longer a viable design. Need
+        // to refactor the related API.
+        let rustls_server_cfg = server::get_tls_config(&config.client_verifier)?;
+        let sess = rustls::ServerSession::new(&rustls_server_cfg);
+
+        Ok(Pipe {
+            inner: rustls::StreamOwned::new(sess, tcp),
+            u: PhantomData::<U>,
+            v: PhantomData::<V>,
+            x: PhantomData::<X>,
+        })
+    }
+
+    // Use default implementation
+    // fn serve(&mut self, mut s: X) -> Result<()>;
+}
+
+pub struct PipeClient<U, V> {
+    inner: rustls::StreamOwned<rustls::ClientSession, TcpStream>,
+    u: PhantomData<U>,
+    v: PhantomData<V>,
+}
+
+pub struct PipeClientConfig {
+    pub tcp: TcpStream,
+    pub hostname: webpki::DNSName,
+    pub server_verifier: SgxQuoteVerifier,
+}
+
+impl<U, V> Read for PipeClient<U, V> {
+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
+        self.inner.read(buf)
+    }
+}
+
+impl<U, V> Write for PipeClient<U, V> {
+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+        self.inner.write(buf)
+    }
+
+    fn flush(&mut self) -> io::Result<()> {
+        self.inner.flush()
+    }
+}
+
+impl<U, V> RpcClient<U, V> for PipeClient<U, V>
+where
+    U: Serialize,
+    V: DeserializeOwned,
+{
+    type Config = PipeClientConfig;
+    fn open(config: Self::Config) -> Result<Self> {
+        let rustls_client_cfg = client::get_tls_config(Arc::new(config.server_verifier));
+        let sess = rustls::ClientSession::new(&rustls_client_cfg, config.hostname.as_ref());
+
+        Ok(PipeClient {
+            inner: rustls::StreamOwned::new(sess, config.tcp),
+            u: PhantomData::<U>,
+            v: PhantomData::<V>,
+        })
+    }
+
+    // use default implementation
+    // fn invoke(&mut self, input: U) -> Result<V>;
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/rpc/sgx/ra.rs b/trusted-mesatee-sdk/mesatee_core/src/rpc/sgx/ra.rs
new file mode 100644
index 0000000..eb97a76
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/rpc/sgx/ra.rs
@@ -0,0 +1,179 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+#![allow(clippy::unreadable_literal, clippy::redundant_closure)]
+
+// This entire file is solely used for the sgx environment
+use std::prelude::v1::*;
+
+use sgx_tcrypto::rsgx_sha256_slice;
+use sgx_types::*;
+
+use std::sync::SgxRwLock;
+use std::time::{self, SystemTime};
+use std::untrusted::time::SystemTimeEx;
+
+use lazy_static::lazy_static;
+
+use crate::{Error, ErrorKind, Result};
+
+use crate::config::runtime_config;
+use teaclave_attestation;
+
+lazy_static! {
+    static ref RACACHE: SgxRwLock<RACache> = {
+        SgxRwLock::new(RACache {
+            ra_credential: RACredential::default(),
+            gen_time: SystemTime::UNIX_EPOCH,
+            validity: time::Duration::from_secs(0),
+        })
+    };
+}
+
+/// Certificate and public key in DER format
+#[derive(Clone, Hash, Default)]
+pub(crate) struct RACredential {
+    pub cert: Vec<u8>,
+    pub private_key: Vec<u8>,
+    pub private_key_sha256: sgx_sha256_hash_t,
+}
+
+#[derive(Clone)]
+struct RACache {
+    ra_credential: RACredential,
+    gen_time: SystemTime,
+    validity: time::Duration,
+}
+
+pub(crate) fn init_ra_credential(valid_secs: u64) -> Result<()> {
+    match RACache::new(valid_secs) {
+        Ok(new_entry) => {
+            *RACACHE.write().unwrap() = new_entry;
+            Ok(())
+        }
+        Err(e) => {
+            error!("Cannot initialize RACredential: {:?}", e);
+            Err(Error::from(ErrorKind::RAInternalError))
+        }
+    }
+}
+
+pub(crate) fn get_current_ra_credential() -> RACredential {
+    // Check if the global cert valid
+    // If valid, use it directly
+    // If invalid, update it before use.
+    // Generate Keypair
+
+    // 1. Check if the global cert valid
+    //    Need block read here. It should wait for writers to complete
+    {
+        // Unwrapping failing means the RwLock is poisoned.
+        // Simple crash in that case.
+        let g_cache = RACACHE.read().unwrap();
+        if g_cache.is_valid() {
+            return g_cache.ra_credential.clone();
+        }
+    }
+
+    // 2. Do the update
+
+    // Unwrapping failing means the RwLock is poisoned.
+    // Simple crash in that case.
+    let mut g_cache = RACACHE.write().unwrap();
+
+    // Here is the 100% serialized access to SVRCONFIG
+    // No other reader/writer exists in this branch
+    // Toc tou check
+    if g_cache.is_valid() {
+        return g_cache.ra_credential.clone();
+    }
+
+    // Do the renew
+    match RACache::new(g_cache.validity.as_secs()) {
+        // If RA renewal fails, we do not crash for the following reasons.
+        // 1. Crashing the enclave causes most data to be lost permanently,
+        //    since we do not have persistent key-value storage yet. On the
+        //    other hand, RA renewal failure may be temporary. We still have
+        //    a chance to recover from this failure in the future.
+        // 2. If renewal failed, the old certificate is used, the the client
+        //    can decide if they want to keep talking to the enclave.
+        // 3. The certificate has a 90 days valid duration. If RA keeps
+        //    failing for 90 days, the enclave itself will not serve any
+        //    client.
+        Err(e) => {
+            error!(
+                "RACredential renewal failed, use existing credential: {:?}",
+                e
+            );
+        }
+        Ok(new_cache) => *g_cache = new_cache,
+    };
+
+    g_cache.ra_credential.clone()
+}
+
+impl RACredential {
+    fn generate_and_endorse() -> Result<RACredential> {
+        let key_pair = teaclave_attestation::key::Secp256k1KeyPair::new()
+            .map_err(|_| Error::from(ErrorKind::RAInternalError))?;
+        let report = if cfg!(sgx_sim) {
+            teaclave_attestation::IasReport::default()
+        } else {
+            match teaclave_attestation::IasReport::new(
+                key_pair.pub_k,
+                &runtime_config().env.ias_key,
+                &runtime_config().env.ias_spid,
+                false,
+            ) {
+                Ok(r) => r,
+                Err(e) => {
+                    error!("{:?}", e);
+                    return Err(Error::from(ErrorKind::RAInternalError));
+                }
+            }
+        };
+        let payload = [report.report, report.signature, report.signing_cert].join("|");
+        let cert_der =
+            key_pair.create_cert_with_extension("Teaclave", "Teaclave", &payload.as_bytes());
+        let prv_key_der = key_pair.private_key_into_der();
+        let sha256 = rsgx_sha256_slice(&prv_key_der)?;
+
+        Ok(RACredential {
+            cert: cert_der,
+            private_key: prv_key_der,
+            private_key_sha256: sha256,
+        })
+    }
+}
+
+impl RACache {
+    fn new(valid_secs: u64) -> Result<RACache> {
+        let ra_credential = RACredential::generate_and_endorse()?;
+        let gen_time = SystemTime::now();
+        let validity = time::Duration::from_secs(valid_secs);
+        Ok(RACache {
+            ra_credential,
+            gen_time,
+            validity,
+        })
+    }
+
+    fn is_valid(&self) -> bool {
+        let dur = SystemTime::now().duration_since(self.gen_time);
+        dur.is_ok() && dur.unwrap() < self.validity
+    }
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/rpc/sgx/server.rs b/trusted-mesatee-sdk/mesatee_core/src/rpc/sgx/server.rs
new file mode 100644
index 0000000..567e847
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/rpc/sgx/server.rs
@@ -0,0 +1,93 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+use std::collections::HashMap;
+use std::sync::Arc;
+
+use crate::Error;
+use crate::ErrorKind;
+use crate::Result;
+use teaclave_attestation::verifier::SgxQuoteVerifier;
+
+use sgx_types::sgx_sha256_hash_t;
+use std::sync::SgxRwLock as RwLock;
+
+use lazy_static::lazy_static;
+
+lazy_static! {
+    static ref SERVER_CONFIG_CACHE: RwLock<ServerConfigCache> =
+         RwLock::new(ServerConfigCache::default()) ;
+}
+
+#[derive(Default)]
+struct ServerConfigCache {
+    private_key_sha256: sgx_sha256_hash_t,
+    target_configs: HashMap<Arc<SgxQuoteVerifier>, Arc<rustls::ServerConfig>>,
+}
+
+pub(crate) fn get_tls_config(
+    client_verifier: &Option<SgxQuoteVerifier>,
+) -> Result<Arc<rustls::ServerConfig>> {
+    use crate::rpc::sgx::ra::get_current_ra_credential;
+
+    let ra_credential = get_current_ra_credential();
+
+    let client_verifier = match client_verifier {
+        Some(attr) => Arc::new(attr.clone()),
+        None => {
+            let certs = vec![rustls::Certificate(ra_credential.cert)];
+            let privkey = rustls::PrivateKey(ra_credential.private_key);
+            // Build a default authenticator which allow every authenticated client
+            let authenticator = rustls::NoClientAuth::new();
+            let mut cfg = rustls::ServerConfig::new(authenticator);
+            cfg.set_single_cert(certs, privkey)
+                .map_err(|_| Error::from(ErrorKind::TLSError))?;
+            return Ok(Arc::new(cfg));
+        }
+    };
+
+    if let Ok(cfg_cache) = SERVER_CONFIG_CACHE.try_read() {
+        if let Some(cfg) = cfg_cache.target_configs.get(&client_verifier) {
+            // Hit Cache. Be quick!
+            return Ok(cfg.clone());
+        }
+    }
+
+    let certs = vec![rustls::Certificate(ra_credential.cert)];
+    let privkey = rustls::PrivateKey(ra_credential.private_key);
+
+    let mut server_cfg = rustls::ServerConfig::new(client_verifier.clone());
+    server_cfg
+        .set_single_cert(certs, privkey)
+        .map_err(|_| Error::from(ErrorKind::TLSError))?;
+
+    let final_arc = Arc::new(server_cfg);
+
+    if let Ok(mut cfg_cache) = SERVER_CONFIG_CACHE.try_write() {
+        if cfg_cache.private_key_sha256 != ra_credential.private_key_sha256 {
+            *cfg_cache = ServerConfigCache {
+                private_key_sha256: ra_credential.private_key_sha256,
+                target_configs: HashMap::new(),
+            }
+        }
+        let _ = cfg_cache
+            .target_configs
+            .insert(client_verifier, final_arc.clone()); // Overwrite
+    }
+
+    Ok(final_arc)
+}
diff --git a/trusted-mesatee-sdk/mesatee_core/src/rpc/unix/mod.rs b/trusted-mesatee-sdk/mesatee_core/src/rpc/unix/mod.rs
new file mode 100644
index 0000000..e030f75
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_core/src/rpc/unix/mod.rs
@@ -0,0 +1,175 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+//! Ding-Sun RPC (dsrpc) for MesaTEE-SGX
+//!
+//! MesaTEE-SGX uses direct ECALL/OCALL interfaces on local, and
+//! socket for remote.
+
+use serde::{de::DeserializeOwned, Serialize};
+use sgx_types::c_int;
+use std::io::{self, Read, Write};
+use std::marker::PhantomData;
+use std::net::TcpStream;
+
+use crate::rpc::{EnclaveService, RpcClient, RpcServer};
+#[cfg(not(feature = "mesalock_sgx"))]
+use std::os::unix::io::FromRawFd;
+
+use crate::Result;
+
+// TODO: make the following comments into doc comments starting with `//!`.
+// Sgx Socket RPC always depends on a socket which is always managed by fd.
+// Before launching a Sgx Socket server, one should run a thread pool and
+// properly run a "accept loop" like before. On accept, use `into_raw_fd` to
+// pass the fd to the enclave.
+//
+// ```
+//     println!("Running as server...");
+//  let listener = TcpListener::bind("0.0.0.0:3443").unwrap();
+//  match listener.accept() {
+//      Ok((socket, addr)) => {
+//          println!("new client from {:?}", addr);
+//          let mut retval = sgx_status_t::SGX_SUCCESS;
+//          let result = unsafe {
+//              run_server(enclave.geteid(), &mut retval, socket.into_raw_fd(), sign_type)
+//          };
+//          match result {
+//              sgx_status_t::SGX_SUCCESS => {
+//                  println!("ECALL success!");
+//              },
+//              _ => {
+//                  println!("[-] ECALL Enclave Failed {}!", result.as_str());
+//                  return;
+//              }
+//          }
+//      }
+//      Err(e) => println!("couldn't get client: {:?}", e),
+//  }
+//```
+// `into_raw_fd` consumes the stream. So socket would **not** be dropped on
+// leaving its scope, and **not** triggers its dtor which closes the connection.
+// In MesaTEE, the stream is re-constructed in an enclave by `from_raw_fd`. So
+// the dtor is invoked when the in-enclave stream leaves its scope. Pairing
+// the `into_raw_fd` and `from_raw_fd` is **required**.
+pub struct PipeConfig {
+    fd: c_int,
+}
+
+impl PipeConfig {
+    pub fn new(fd: c_int) -> Self {
+        PipeConfig { fd }
+    }
+
+    pub fn get(&self) -> c_int {
+        self.fd
+    }
+}
+
+pub type PipeClientConfig = PipeConfig;
+
+// Pipe stores the `TcpStream` created from the fd comes from Config.
+pub struct Pipe<U, V, X> {
+    inner: TcpStream,
+    u: PhantomData<U>,
+    v: PhantomData<V>,
+    x: PhantomData<X>,
+}
+
+impl<U, V, X> Read for Pipe<U, V, X> {
+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
+        self.inner.read(buf)
+    }
+}
+
+impl<U, V, X> Write for Pipe<U, V, X> {
+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+        self.inner.write(buf)
+    }
+    fn flush(&mut self) -> io::Result<()> {
+        self.inner.flush()
+    }
+}
+
+impl<U, V, X> RpcServer<U, V, X> for Pipe<U, V, X>
+where
+    U: DeserializeOwned + std::fmt::Debug,
+    V: Serialize + std::fmt::Debug,
+    X: EnclaveService<U, V>,
+{
+    type Config = PipeConfig;
+    // type X = Box<EnclaveService<U, V>>;
+    // The `TcpStream::new()` function is different from Rust's design.
+    // The SGX version takes a fd as a input and return an `Option`.
+    fn start(config: &Self::Config) -> Result<Self> {
+        Ok(Pipe {
+            #[cfg(feature = "mesalock_sgx")]
+            inner: TcpStream::new(config.get())?,
+            #[cfg(not(feature = "mesalock_sgx"))]
+            inner: unsafe { TcpStream::from_raw_fd(config.get()) },
+            u: PhantomData::<U>,
+            v: PhantomData::<V>,
+            x: PhantomData::<X>,
+        })
+    }
+
+    // Use default impplementation
+    // fn serve(&mut self, mut s: X) -> Result<()>;
+}
+
+pub struct PipeClient<U, V> {
+    inner: TcpStream,
+    u: PhantomData<U>,
+    v: PhantomData<V>,
+}
+
+impl<U, V> Read for PipeClient<U, V> {
+    fn read(&mut self, buf: &mut [u8]) -> io::Result<usize> {
+        self.inner.read(buf)
+    }
+}
+
+impl<U, V> Write for PipeClient<U, V> {
+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {
+        self.inner.write(buf)
+    }
+    fn flush(&mut self) -> io::Result<()> {
+        self.inner.flush()
+    }
+}
+
+impl<U, V> RpcClient<U, V> for PipeClient<U, V>
+where
+    U: Serialize,
+    V: DeserializeOwned,
+{
+    type Config = PipeClientConfig;
+
+    fn open(config: Self::Config) -> Result<Self> {
+        Ok(PipeClient {
+            #[cfg(feature = "mesalock_sgx")]
+            inner: TcpStream::new(config.get())?,
+            #[cfg(not(feature = "mesalock_sgx"))]
+            inner: unsafe { TcpStream::from_raw_fd(config.get()) },
+            u: PhantomData::<U>,
+            v: PhantomData::<V>,
+        })
+    }
+
+    // Use default implementation
+    // fn invoke(&mut self, input: U) -> Result<V>;
+}
diff --git a/trusted-mesatee-sdk/mesatee_sdk/Cargo.toml b/trusted-mesatee-sdk/mesatee_sdk/Cargo.toml
new file mode 100644
index 0000000..c6b79a9
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_sdk/Cargo.toml
@@ -0,0 +1,19 @@
+[package]
+name = "mesatee_sdk"
+version = "0.1.0"
+authors = ["MesaTEE Authors <developers@mesatee.org>"]
+description = "Client SDK, applications can utilize it to invoke MesaTEE services."
+license = "Apache-2.0"
+edition = "2018"
+
+[features]
+default = ["mesalock_sgx"]
+mesalock_sgx = ["sgx_tstd", "mesatee_core/mesalock_sgx"]
+
+[dependencies]
+fns_client           = { path = "../mesatee_services/fns/client" }
+mesatee_core         = { path = "../mesatee_core" }
+teaclave_utils       = { path = "../teaclave_utils" }
+#uuid                 = { version = "0.8.1", features = ["v4"] }
+uuid         = { git = "https://github.com/mesalock-linux/uuid-sgx", features = ["v4"] }
+sgx_tstd             = { git = "https://github.com/apache/teaclave-sgx-sdk", rev = "v1.1.2",  optional = true }
diff --git a/trusted-mesatee-sdk/mesatee_sdk/c_sdk/Cargo.toml b/trusted-mesatee-sdk/mesatee_sdk/c_sdk/Cargo.toml
new file mode 100644
index 0000000..17f7eb2
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_sdk/c_sdk/Cargo.toml
@@ -0,0 +1,19 @@
+[package]
+name = "mesatee_sdk_c"
+version = "0.1.0"
+authors = ["MesaTEE Authors <developers@mesatee.org>"]
+description = "MesaTEE SDK C API."
+license = "Apache-2.0"
+edition = "2018"
+
+[lib]
+name = "mesatee_sdk_c"
+crate-type = ["cdylib"]
+
+[dependencies]
+mesatee_sdk = { version = "0.1.0" }
+mesatee_core = { version = "0.1.0" }
+log = { version = "0.4.6" }
+env_logger = { version = "0.7.1" }
+libc = { version = "0.2.58" }
+nix = { version = "0.17.0" }
diff --git a/trusted-mesatee-sdk/mesatee_sdk/c_sdk/include/mesatee/mesatee.h b/trusted-mesatee-sdk/mesatee_sdk/c_sdk/include/mesatee/mesatee.h
new file mode 100644
index 0000000..98f7a9d
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_sdk/c_sdk/include/mesatee/mesatee.h
@@ -0,0 +1,79 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+#ifndef MESATEE_H
+#define MESATEE_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include <mesatee/visibility.h>
+#include <sys/socket.h>
+
+typedef struct mesatee mesatee_t;
+typedef struct mesatee_enclave_info mesatee_enclave_info_t;
+typedef struct mesatee_task mesatee_task_t;
+typedef struct mesatee_taskinfo mesatee_taskinfo_t;
+typedef struct mesatee_auditor_set mesatee_auditor_set_t;
+
+typedef struct sockaddr sockaddr_t;
+
+typedef enum mesatee_task_status_t {
+  TASK_CREATED,
+  TASK_READY,
+  TASK_RUNNING,
+  TASK_FINISHED,
+  TASK_FAILED,
+} mesatee_task_status_t;
+
+// Initialize logger
+MESATEE_API int mesatee_init();
+
+// MesaTEE Context APIs
+MESATEE_API mesatee_t *mesatee_context_new(const mesatee_enclave_info_t *enclave_info_ptr,
+                                           const char* user_id, const char* user_token,
+                                           sockaddr_t * tms_addr);
+
+MESATEE_API mesatee_t* mesatee_context_new2(const mesatee_enclave_info_t* enclave_info_ptr,
+                                           const char* user_id, const char* user_token,
+                                           const char* tms_addr_ptr/*ip:port*/); 
+
+MESATEE_API int mesatee_context_free(mesatee_t *ctx_ptr);
+
+// MesaTEE EnclaveInfo APIs
+MESATEE_API mesatee_enclave_info_t *
+mesatee_enclave_info_load(mesatee_auditor_set_t *auditors_ptr, const char *enclave_info_file_path_ptr);
+MESATEE_API int mesatee_enclave_info_free(mesatee_enclave_info_t *enclave_info_ptr);
+
+// Auditor APIs
+MESATEE_API mesatee_auditor_set_t *mesatee_auditor_set_new();
+MESATEE_API int mesatee_auditor_set_add_auditor(mesatee_auditor_set_t *ptr,
+                                                const char *pub_key_path, const char *sig_path);
+MESATEE_API int mesatee_auditor_set_free(mesatee_auditor_set_t *ptr);
+
+// MesaTEE Task APIs
+MESATEE_API mesatee_task_t *mesatee_create_task(mesatee_t *ctx_ptr, const char *func_name_ptr);
+MESATEE_API int mesatee_task_free(mesatee_task_t *mesatee_task_ptr);
+MESATEE_API int mesatee_task_invoke_with_payload(mesatee_task_t *mesatee_task_ptr, const char *payload_buf_ptr,
+                                                 int payload_buf_len, char *result_buf_ptr, int result_buf_len);
+
+#ifdef __cplusplus
+} /* extern C */
+#endif
+
+#endif // MESATEE_H
diff --git a/trusted-mesatee-sdk/mesatee_sdk/c_sdk/include/mesatee/visibility.h b/trusted-mesatee-sdk/mesatee_sdk/c_sdk/include/mesatee/visibility.h
new file mode 100644
index 0000000..5d6f8cb
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_sdk/c_sdk/include/mesatee/visibility.h
@@ -0,0 +1,32 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+#ifndef MESATEE_VISIBILITY_H
+#define MESATEE_VISIBILITY_H
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#define MESATEE_API __attribute__((visibility("default")))
+#define MESATEE_LOCAL __attribute__((visiblity("hidden")))
+
+#ifdef __cplusplus
+} /* extern C */
+#endif
+
+#endif // MESATEE_VISIBILITY_H
diff --git a/trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/auditor_set.rs b/trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/auditor_set.rs
new file mode 100644
index 0000000..f8c8bc4
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/auditor_set.rs
@@ -0,0 +1,85 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+use super::*;
+use libc::c_char;
+use std::ffi::CStr;
+use std::path::{Path, PathBuf};
+
+pub(super) struct MesateeAuditorSet {
+    pub inner: Vec<(PathBuf, PathBuf)>,
+}
+
+impl OpaquePointerType for MesateeAuditorSet {}
+
+impl MesateeAuditorSet {
+    pub fn new() -> MesateeAuditorSet {
+        MesateeAuditorSet { inner: Vec::new() }
+    }
+}
+
+#[no_mangle]
+unsafe extern "C" fn mesatee_auditor_set_new() -> *mut MesateeAuditorSet {
+    Box::into_raw(Box::new(MesateeAuditorSet::new())) as *mut MesateeAuditorSet
+}
+
+#[no_mangle]
+unsafe extern "C" fn mesatee_auditor_set_free(ptr: *mut MesateeAuditorSet) -> c_int {
+    check_inner_result!(inner_mesatee_auditor_set_free(ptr), MESATEE_ERROR)
+}
+
+unsafe fn inner_mesatee_auditor_set_free(ptr: *mut MesateeAuditorSet) -> MesateeResult<c_int> {
+    let _ = sanitize_ptr_for_mut_ref(ptr)?;
+    let _ = Box::from_raw(ptr);
+    Ok(MESATEE_SUCCESS)
+}
+
+#[no_mangle]
+unsafe extern "C" fn mesatee_auditor_set_add_auditor(
+    ptr: *mut MesateeAuditorSet,
+    pub_key_path: *const c_char,
+    sig_path: *const c_char,
+) -> c_int {
+    check_inner_result!(
+        inner_mesatee_auditor_set_add_auditor(ptr, pub_key_path, sig_path),
+        MESATEE_ERROR
+    )
+}
+
+unsafe fn inner_mesatee_auditor_set_add_auditor(
+    auditor_set_ptr: *mut MesateeAuditorSet,
+    pub_key_path_ptr: *const c_char,
+    sig_path_ptr: *const c_char,
+) -> MesateeResult<c_int> {
+    let auditor_set = sanitize_ptr_for_mut_ref(auditor_set_ptr)?;
+
+    if pub_key_path_ptr.is_null() || pub_key_path_ptr.is_null() {
+        return Err(Error::from(ErrorKind::InvalidInputError));
+    }
+    let pub_key_path = CStr::from_ptr(pub_key_path_ptr)
+        .to_str()
+        .map_err(|_| Error::from(ErrorKind::InvalidInputError))?;
+    let sig_path = CStr::from_ptr(sig_path_ptr)
+        .to_str()
+        .map_err(|_| Error::from(ErrorKind::InvalidInputError))?;
+
+    auditor_set.inner.push((
+        Path::new(pub_key_path).to_path_buf(),
+        Path::new(sig_path).to_path_buf(),
+    ));
+    Ok(MESATEE_SUCCESS)
+}
diff --git a/trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/context.rs b/trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/context.rs
new file mode 100644
index 0000000..70afcea
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/context.rs
@@ -0,0 +1,142 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+use super::*;
+use env_logger;
+use libc::{c_char, c_int, sockaddr};
+use mesatee_sdk::{Mesatee, MesateeEnclaveInfo};
+use nix::sys::socket::SockAddr;
+use std::{ffi, net, ptr};
+
+impl OpaquePointerType for Mesatee {}
+
+#[no_mangle]
+pub unsafe extern "C" fn mesatee_init() -> c_int {
+    env_logger::init();
+    MESATEE_SUCCESS
+}
+
+#[no_mangle]
+unsafe extern "C" fn mesatee_context_new(
+    enclave_info_ptr: *mut MesateeEnclaveInfo,
+    user_id: *const c_char,
+    user_token: *const c_char,
+    tms_addr: *mut sockaddr,
+) -> *mut Mesatee {
+    check_inner_result!(
+        inner_mesatee_context_new(enclave_info_ptr, user_id, user_token, tms_addr),
+        ptr::null_mut()
+    )
+}
+
+#[no_mangle]
+unsafe extern "C" fn mesatee_context_new2(
+    enclave_info_ptr: *mut MesateeEnclaveInfo,
+    user_id: *const c_char,
+    user_token: *const c_char,
+    tms_addr_ptr: *const c_char,
+) -> *mut Mesatee {
+    check_inner_result!(
+        inner_mesatee_context_new2(
+            enclave_info_ptr,
+            user_id,
+            user_token,
+            tms_addr_ptr
+        ),
+        ptr::null_mut()
+    )
+}
+
+unsafe fn inner_mesatee_context_new(
+    enclave_info_ptr: *mut MesateeEnclaveInfo,
+    user_id_ptr: *const c_char,
+    user_token_ptr: *const c_char,
+    tms_addr_ptr: *const sockaddr,
+) -> MesateeResult<*mut Mesatee> {
+    let enclave_info = sanitize_ptr_for_ref(enclave_info_ptr)?;
+    if user_id_ptr.is_null() {
+        return Err(Error::from(ErrorKind::InvalidInputError));
+    }
+    let user_id = ffi::CStr::from_ptr(user_id_ptr)
+        .to_str()
+        .map_err(|_| Error::from(ErrorKind::InvalidInputError))?;
+    if user_token_ptr.is_null() {
+        return Err(Error::from(ErrorKind::InvalidInputError));
+    }
+    let user_token = ffi::CStr::from_ptr(user_id_ptr)
+        .to_str()
+        .map_err(|_| Error::from(ErrorKind::InvalidInputError))?;
+    let tms_addr = sockaddr_to_rust(tms_addr_ptr)?;
+    let mesatee = Mesatee::new(enclave_info, user_id, user_token, tms_addr)?;
+    let mesatee_ptr = Box::into_raw(Box::new(mesatee)) as *mut Mesatee;
+    Ok(mesatee_ptr)
+}
+
+unsafe fn inner_mesatee_context_new2(
+    enclave_info_ptr: *mut MesateeEnclaveInfo,
+    user_id_ptr: *const c_char,
+    user_token_ptr: *const c_char,
+    tms_addr_ptr: *const c_char,
+) -> MesateeResult<*mut Mesatee> {
+    let enclave_info = sanitize_ptr_for_ref(enclave_info_ptr)?;
+    if user_id_ptr.is_null() {
+        return Err(Error::from(ErrorKind::InvalidInputError));
+    }
+    let user_id = ffi::CStr::from_ptr(user_id_ptr)
+        .to_str()
+        .map_err(|_| Error::from(ErrorKind::InvalidInputError))?;
+    if user_token_ptr.is_null() {
+        return Err(Error::from(ErrorKind::InvalidInputError));
+    }
+    let user_token = ffi::CStr::from_ptr(user_id_ptr)
+        .to_str()
+        .map_err(|_| Error::from(ErrorKind::InvalidInputError))?;
+
+    let tms_addr = ffi::CStr::from_ptr(tms_addr_ptr)
+        .to_str()
+        .map_err(|_| Error::from(ErrorKind::InvalidInputError))?;
+    let tmsaddr = tms_addr
+        .parse()
+        .map_err(|_| Error::from(ErrorKind::InvalidInputError))?;
+    let mesatee = Mesatee::new(enclave_info, user_id, user_token, tmsaddr)?;
+    let mesatee_ptr = Box::into_raw(Box::new(mesatee)) as *mut Mesatee;
+    Ok(mesatee_ptr)
+}
+
+unsafe fn sockaddr_to_rust(sockaddr_ptr: *const sockaddr) -> MesateeResult<net::SocketAddr> {
+    if sockaddr_ptr.is_null() {
+        return Err(Error::from(ErrorKind::InvalidInputError));
+    }
+    let nix_sockaddr = SockAddr::from_libc_sockaddr(sockaddr_ptr)
+        .ok_or_else(|| Error::from(ErrorKind::InvalidInputError))?; // Not a valid libc::sockaddr
+    let nix_inet_addr = match nix_sockaddr {
+        SockAddr::Inet(addr) => addr,
+        _ => return Err(Error::from(ErrorKind::InvalidInputError)), // Not an INET address
+    };
+    Ok(nix_inet_addr.to_std())
+}
+
+#[no_mangle]
+unsafe extern "C" fn mesatee_context_free(ctx_ptr: *mut Mesatee) -> c_int {
+    check_inner_result!(inner_mesatee_context_free(ctx_ptr), MESATEE_ERROR)
+}
+
+unsafe fn inner_mesatee_context_free(ctx_ptr: *mut Mesatee) -> MesateeResult<c_int> {
+    let _ = sanitize_ptr_for_mut_ref(ctx_ptr)?;
+    let _ = Box::from_raw(ctx_ptr);
+    Ok(MESATEE_SUCCESS)
+}
diff --git a/trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/enclave_info.rs b/trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/enclave_info.rs
new file mode 100644
index 0000000..e120878
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/enclave_info.rs
@@ -0,0 +1,79 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+use super::*;
+use libc::c_char;
+use mesatee_sdk::MesateeEnclaveInfo;
+use std::{ffi, ptr};
+
+impl OpaquePointerType for MesateeEnclaveInfo {}
+
+#[no_mangle]
+unsafe extern "C" fn mesatee_enclave_info_load(
+    auditors_ptr: *const MesateeAuditorSet,
+    enclave_info_file_path_ptr: *const c_char,
+) -> *mut MesateeEnclaveInfo {
+    check_inner_result!(
+        inner_mesatee_enclave_info_load(auditors_ptr, enclave_info_file_path_ptr),
+        ptr::null_mut()
+    )
+}
+
+unsafe fn inner_mesatee_enclave_info_load(
+    auditors_ptr: *const MesateeAuditorSet,
+    enclave_info_file_path_ptr: *const c_char,
+) -> MesateeResult<*mut MesateeEnclaveInfo> {
+    let auditors = sanitize_const_ptr_for_ref(auditors_ptr)?;
+
+    let mut enclave_auditors: Vec<(&str, &str)> = Vec::new();
+    for (pub_key_path, sig_path) in auditors.inner.iter() {
+        let pub_key_path_str = pub_key_path
+            .to_str()
+            .ok_or_else(|| Error::from(ErrorKind::InvalidInputError))?;
+        let sig_path_str = sig_path
+            .to_str()
+            .ok_or_else(|| Error::from(ErrorKind::InvalidInputError))?;
+        enclave_auditors.push((pub_key_path_str, sig_path_str));
+    }
+
+    if enclave_info_file_path_ptr.is_null() {
+        return Err(Error::from(ErrorKind::InvalidInputError));
+    }
+    let enclave_info_file_path = ffi::CStr::from_ptr(enclave_info_file_path_ptr)
+        .to_str()
+        .map_err(|_| Error::from(ErrorKind::InvalidInputError))?;
+
+    let enclave_info = MesateeEnclaveInfo::load(enclave_auditors, enclave_info_file_path)?;
+    let enclave_info_ptr = Box::into_raw(Box::new(enclave_info)) as *mut MesateeEnclaveInfo;
+    Ok(enclave_info_ptr)
+}
+
+#[no_mangle]
+unsafe extern "C" fn mesatee_enclave_info_free(enclave_info_ptr: *mut MesateeEnclaveInfo) -> c_int {
+    check_inner_result!(
+        inner_mesatee_enclave_info_free(enclave_info_ptr),
+        MESATEE_ERROR
+    )
+}
+
+unsafe fn inner_mesatee_enclave_info_free(
+    enclave_info_ptr: *mut MesateeEnclaveInfo,
+) -> MesateeResult<c_int> {
+    let _ = sanitize_ptr_for_mut_ref(enclave_info_ptr)?;
+    let _ = Box::from_raw(enclave_info_ptr);
+    Ok(MESATEE_SUCCESS)
+}
diff --git a/trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/lib.rs b/trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/lib.rs
new file mode 100644
index 0000000..ffb8335
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/lib.rs
@@ -0,0 +1,82 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+use libc::c_int;
+use log::error;
+use mesatee_core::{Error, ErrorKind};
+
+pub(self) use auditor_set::MesateeAuditorSet;
+pub(self) type MesateeResult<T> = Result<T, Error>;
+
+#[repr(C)]
+pub(self) enum MesateeRetcode {
+    Error = 0,
+    Success = 1,
+}
+
+pub(self) const MESATEE_ERROR: c_int = MesateeRetcode::Error as c_int;
+pub(self) const MESATEE_SUCCESS: c_int = MesateeRetcode::Success as c_int;
+
+#[doc(hidden)]
+#[macro_export]
+macro_rules! check_inner_result {
+    ($inner:expr, $err_ret:expr) => {{
+        use std::panic;
+        match panic::catch_unwind(panic::AssertUnwindSafe(|| $inner))
+            .unwrap_or_else(|_| Err(Error::from(ErrorKind::FFIError)))
+        {
+            Ok(r) => r,
+            Err(e) => {
+                error!("MesaTEE SDK panicked: {:?}", e);
+                $err_ret
+            }
+        }
+    }};
+}
+
+pub(self) trait OpaquePointerType {}
+
+pub(self) fn sanitize_const_ptr_for_ref<'a, T>(ptr: *const T) -> MesateeResult<&'a T>
+where
+    T: OpaquePointerType,
+{
+    let ptr = ptr as *mut T;
+    sanitize_ptr_for_mut_ref(ptr).map(|r| r as &'a T)
+}
+pub(self) fn sanitize_ptr_for_ref<'a, T>(ptr: *mut T) -> MesateeResult<&'a T>
+where
+    T: OpaquePointerType,
+{
+    sanitize_ptr_for_mut_ref(ptr).map(|r| r as &'a T)
+}
+
+pub(self) fn sanitize_ptr_for_mut_ref<'a, T>(ptr: *mut T) -> MesateeResult<&'a mut T>
+where
+    T: OpaquePointerType,
+{
+    if !ptr.is_null() {
+        let obj_ref: &mut T = unsafe { &mut *ptr };
+        Ok(obj_ref)
+    } else {
+        Err(Error::from(ErrorKind::FFIError))
+    }
+}
+
+mod auditor_set;
+mod context;
+mod enclave_info;
+mod task;
diff --git a/trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/task.rs b/trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/task.rs
new file mode 100644
index 0000000..a895d96
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_sdk/c_sdk/src/task.rs
@@ -0,0 +1,112 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+use super::*;
+use libc::{c_char, c_uchar};
+use mesatee_sdk::{Mesatee, MesateeTask};
+use std::{ffi, ptr, slice, str};
+
+impl OpaquePointerType for MesateeTask {}
+
+#[no_mangle]
+unsafe extern "C" fn mesatee_create_task(
+    ctx_ptr: *mut Mesatee,
+    func_name_ptr: *const c_char,
+) -> *mut MesateeTask {
+    check_inner_result!(
+        inner_mesatee_create_task(ctx_ptr, func_name_ptr),
+        ptr::null_mut()
+    )
+}
+
+unsafe fn inner_mesatee_create_task(
+    ctx_ptr: *mut Mesatee,
+    func_name_ptr: *const c_char,
+) -> MesateeResult<*mut MesateeTask> {
+    let ctx = sanitize_ptr_for_ref(ctx_ptr)?;
+    if func_name_ptr.is_null() {
+        return Err(Error::from(ErrorKind::InvalidInputError));
+    }
+    let func_name = ffi::CStr::from_ptr(func_name_ptr)
+        .to_str()
+        .map_err(|_| Error::from(ErrorKind::InvalidInputError))?;
+    let task = ctx.create_task(func_name)?;
+    let task_ptr = Box::into_raw(Box::new(task)) as *mut MesateeTask;
+    Ok(task_ptr)
+}
+
+#[no_mangle]
+unsafe extern "C" fn mesatee_task_free(mesatee_task_ptr: *mut MesateeTask) -> c_int {
+    check_inner_result!(inner_mesatee_task_free(mesatee_task_ptr), MESATEE_ERROR)
+}
+
+unsafe fn inner_mesatee_task_free(mesatee_task_ptr: *mut MesateeTask) -> MesateeResult<c_int> {
+    let _ = sanitize_ptr_for_mut_ref(mesatee_task_ptr)?;
+    let _ = Box::from_raw(mesatee_task_ptr);
+    Ok(MESATEE_SUCCESS)
+}
+
+#[no_mangle]
+unsafe extern "C" fn mesatee_task_invoke_with_payload(
+    mesatee_task_ptr: *mut MesateeTask,
+    payload_buf_ptr: *const c_uchar,
+    payload_buf_len: c_int,
+    result_buf_ptr: *mut c_uchar,
+    result_buf_len: c_int,
+) -> c_int {
+    check_inner_result!(
+        inner_mesatee_task_invoke_with_payload(
+            mesatee_task_ptr,
+            payload_buf_ptr,
+            payload_buf_len,
+            result_buf_ptr,
+            result_buf_len
+        ),
+        MESATEE_ERROR
+    )
+}
+
+unsafe fn inner_mesatee_task_invoke_with_payload(
+    mesatee_task_ptr: *mut MesateeTask,
+    payload_buf_ptr: *const c_uchar,
+    payload_buf_len: c_int,
+    output_buf_ptr: *mut c_uchar,
+    output_buf_len: c_int,
+) -> MesateeResult<c_int> {
+    let task = sanitize_ptr_for_mut_ref(mesatee_task_ptr)?;
+
+    if payload_buf_ptr.is_null() || output_buf_ptr.is_null() {
+        return Err(Error::from(ErrorKind::InvalidInputError));
+    }
+
+    let payload_buf: &[u8] = slice::from_raw_parts(payload_buf_ptr, payload_buf_len as usize);
+    let output_buf: &mut [u8] = slice::from_raw_parts_mut(output_buf_ptr, output_buf_len as usize);
+
+    let payload_str = str::from_utf8_unchecked(&payload_buf);
+    let result = task.invoke_with_payload(&payload_str)?;
+    let result_bytes = result.as_bytes();
+
+    if result_bytes.len() >= output_buf.len() {
+        // Handle off-by-one
+        output_buf.copy_from_slice(&result_bytes[..output_buf.len()]);
+        output_buf[output_buf.len() - 1] = 0;
+    } else {
+        output_buf[0..result_bytes.len()].copy_from_slice(&result_bytes[..])
+    }
+
+    Ok(MESATEE_SUCCESS)
+}
diff --git a/trusted-mesatee-sdk/mesatee_sdk/src/lib.rs b/trusted-mesatee-sdk/mesatee_sdk/src/lib.rs
new file mode 100644
index 0000000..d171ddb
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_sdk/src/lib.rs
@@ -0,0 +1,121 @@
+#![feature(asm)]
+#![cfg_attr(feature = "mesalock_sgx", no_std)]
+#[cfg(feature = "mesalock_sgx")]
+extern crate sgx_tstd as std;
+
+use std::prelude::v1::*;
+
+use fns_client::FNSClient;
+use mesatee_core::config::{OutboundDesc, TargetDesc};
+pub use mesatee_core::{Error, ErrorKind, Result};
+use std::untrusted::fs;
+use std::vec;
+use std::net::SocketAddr;
+use std::path::{Path, PathBuf};
+use std::str::FromStr;
+use teaclave_utils;
+
+pub struct Mesatee {
+    // 暂时没有用上user的信息
+    #[allow(dead_code)]
+    user_id: String,
+    #[allow(dead_code)]
+    user_token: String,
+    task_desc: TargetDesc,
+}
+
+pub struct MesateeEnclaveInfo {
+    enclave_signers: Vec<(Vec<u8>, PathBuf)>,
+    enclave_info_file_path: PathBuf,
+}
+
+impl MesateeEnclaveInfo {
+    pub fn load(auditors: Vec<(&str, &str)>, enclave_info_file_path: &str) -> Result<Self> {
+        let mut enclave_signers: Vec<(Vec<u8>, PathBuf)> = vec![];
+
+        for (der, sha) in auditors.iter() {
+            let der_content = fs::read(der)?;
+            enclave_signers.push((der_content, PathBuf::from_str(sha).expect("infallible")));
+        }
+        let enclave_info_file_path = PathBuf::from_str(enclave_info_file_path).expect("infallible");
+        let enclave_info = MesateeEnclaveInfo {
+            enclave_signers,
+            enclave_info_file_path,
+        };
+        Ok(enclave_info)
+    }
+}
+
+impl Mesatee {
+    pub fn new(
+        enclave_info: &MesateeEnclaveInfo,
+        user_id: &str,
+        user_token: &str,
+        fns_addr: SocketAddr,
+    ) -> Result<Self> {
+        let mut enclave_signers: Vec<(&[u8], &Path)> = vec![];
+        for (der, hash) in enclave_info.enclave_signers.iter() {
+            enclave_signers.push((&der, hash.as_path()));
+        }
+        let enclave_info_content = fs::read_to_string(&enclave_info.enclave_info_file_path)
+            .unwrap_or_else(|_| {
+                panic!(
+                    "Cannot find enclave info at {:?}.",
+                    enclave_info.enclave_info_file_path
+                )
+            });
+        let enclave_identities = teaclave_utils::load_enclave_info(&enclave_info_content);
+
+        let tms_outbound_desc = OutboundDesc::new(
+            *enclave_identities
+                .get("fns")
+                .ok_or_else(|| Error::from(ErrorKind::MissingValue))?,
+        );
+        let task_desc = TargetDesc::new(fns_addr, tms_outbound_desc);
+
+        let mesatee = Self {
+            user_id: user_id.to_owned(),
+            user_token: user_token.to_owned(),
+            task_desc,
+        };
+        Ok(mesatee)
+    }
+
+    pub fn create_task(&self, function_name: &str) -> Result<MesateeTask> {
+        self._create_task(function_name)
+    }
+    
+    pub fn _create_task(&self, function_name: &str) -> Result<MesateeTask>{
+        Ok(MesateeTask {
+            task_id: uuid::Uuid::new_v4().to_string(),
+            function_name: function_name.to_owned(),
+	    task_desc: Some(self.task_desc.clone()),
+        })
+    }
+}
+
+pub struct MesateeTask {
+    pub task_id: String,
+    pub function_name: String,
+    task_desc: Option<TargetDesc>,
+}
+
+impl MesateeTask {
+    pub fn invoke_with_payload(&self, payload: &str) -> Result<String> {
+        self._invoke(Some(payload))
+    }
+
+    fn _invoke(&self, payload: Option<&str>) -> Result<String> {
+        let desc = self
+            .task_desc
+            .as_ref()
+            .ok_or_else(|| Error::from(ErrorKind::MissingValue))?;
+        let mut fns_client = FNSClient::new(desc)?;
+        let response = fns_client.invoke_task(
+            &self.task_id,
+            &self.function_name,
+            payload,
+        )?;
+        Ok(response.result)
+    }
+}
diff --git a/trusted-mesatee-sdk/mesatee_services/fns/client/Cargo.toml b/trusted-mesatee-sdk/mesatee_services/fns/client/Cargo.toml
new file mode 100644
index 0000000..8e71852
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_services/fns/client/Cargo.toml
@@ -0,0 +1,18 @@
+[package]
+name = "fns_client"
+version = "0.1.0"
+authors = ["MesaTEE Authors <developers@mesatee.org>"]
+description = "RPC client of FNS."
+license = "Apache-2.0"
+edition = "2018"
+
+[features]
+default = ["mesalock_sgx"]
+mesalock_sgx = ["sgx_tstd", "mesatee_core/mesalock_sgx"]
+
+[dependencies]
+cfg-if          = { version = "0.1.10" }
+#mesatee_core   = { version = "0.1.0" }
+mesatee_core    = { path = "../../../mesatee_core" }
+fns_proto       = { path = "../proto" }
+sgx_tstd        = { git = "https://github.com/apache/teaclave-sgx-sdk", rev = "v1.1.2",  optional = true }
diff --git a/trusted-mesatee-sdk/mesatee_services/fns/client/src/fns_client.rs b/trusted-mesatee-sdk/mesatee_services/fns/client/src/fns_client.rs
new file mode 100644
index 0000000..3c4a23f
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_services/fns/client/src/fns_client.rs
@@ -0,0 +1,54 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Insert std prelude in the top for the sgx feature
+#[cfg(feature = "mesalock_sgx")]
+use std::prelude::v1::*;
+
+use fns_proto::{InvokeTaskRequest, InvokeTaskResponse};
+use mesatee_core::config::{OutboundDesc, TargetDesc};
+use mesatee_core::rpc::channel::SgxTrustedChannel;
+use mesatee_core::Result;
+
+pub struct FNSClient {
+    channel: SgxTrustedChannel<InvokeTaskRequest, InvokeTaskResponse>,
+}
+
+impl FNSClient {
+    pub fn new(target: &TargetDesc) -> Result<Self> {
+        let addr = target.addr;
+
+        let channel = match &target.desc {
+            OutboundDesc::Sgx(enclave_attr) => SgxTrustedChannel::<
+                InvokeTaskRequest,
+                InvokeTaskResponse,
+            >::new(addr, enclave_attr.clone())?,
+        };
+
+        Ok(FNSClient { channel })
+    }
+
+    pub fn invoke_task(
+        &mut self,
+        task_id: &str,
+        function_name: &str,
+        payload: Option<&str>,
+    ) -> Result<InvokeTaskResponse> {
+        let req = InvokeTaskRequest::new(task_id, function_name, "", payload);
+        self.channel.invoke(req)
+    }
+}
diff --git a/trusted-mesatee-sdk/mesatee_services/fns/client/src/lib.rs b/trusted-mesatee-sdk/mesatee_services/fns/client/src/lib.rs
new file mode 100644
index 0000000..1e45198
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_services/fns/client/src/lib.rs
@@ -0,0 +1,24 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Use sgx_tstd to replace Rust's default std
+#![cfg_attr(feature = "mesalock_sgx", no_std)]
+#[cfg(feature = "mesalock_sgx")]
+extern crate sgx_tstd as std;
+
+mod fns_client;
+pub use crate::fns_client::FNSClient;
diff --git a/trusted-mesatee-sdk/mesatee_services/fns/proto/Cargo.toml b/trusted-mesatee-sdk/mesatee_services/fns/proto/Cargo.toml
new file mode 100644
index 0000000..ddaedd6
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_services/fns/proto/Cargo.toml
@@ -0,0 +1,26 @@
+[package]
+name = "fns_proto"
+version = "0.1.0"
+authors = ["MesaTEE Authors <developers@mesatee.org>"]
+description = "RPC protocol of FNS."
+license = "Apache-2.0"
+edition = "2018"
+
+[features]
+default = ["mesalock_sgx"]
+mesalock_sgx = ["sgx_tstd"]
+cov = ["sgx_cov"]
+
+[dependencies]
+cfg-if       = { version = "0.1.10" }
+#serde        = { version = "1.0.39" }
+#serde_derive = { version = "1.0.92" }
+
+serde           = { git = "https://github.com/mesalock-linux/serde-sgx", features = ["derive"] }
+serde_derive    = { git = "https://github.com/mesalock-linux/serde-sgx" }
+
+#sgx_cov = { version = "1.1.0", optional = true }
+#sgx_tstd = { version = "1.1.0", optional = true }
+sgx_cov = { rev = "v1.1.2", git = "https://github.com/apache/teaclave-sgx-sdk.git", optional = true}
+sgx_tstd = { rev = "v1.1.2", git = "https://github.com/apache/teaclave-sgx-sdk.git", optional = true}
+
diff --git a/trusted-mesatee-sdk/mesatee_services/fns/proto/src/lib.rs b/trusted-mesatee-sdk/mesatee_services/fns/proto/src/lib.rs
new file mode 100644
index 0000000..ba764d9
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_services/fns/proto/src/lib.rs
@@ -0,0 +1,31 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+#![cfg_attr(feature = "mesalock_sgx", no_std)]
+
+use cfg_if::cfg_if;
+cfg_if! {
+    if #[cfg(feature = "mesalock_sgx")]  {
+        extern crate sgx_tstd as std;
+        #[cfg(feature = "cov")]
+        extern crate sgx_cov;
+    } else {
+    }
+}
+
+mod proto;
+pub use proto::*;
diff --git a/trusted-mesatee-sdk/mesatee_services/fns/proto/src/proto.rs b/trusted-mesatee-sdk/mesatee_services/fns/proto/src/proto.rs
new file mode 100644
index 0000000..1037007
--- /dev/null
+++ b/trusted-mesatee-sdk/mesatee_services/fns/proto/src/proto.rs
@@ -0,0 +1,59 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+// Insert std prelude in the top for the sgx feature
+#[cfg(feature = "mesalock_sgx")]
+use std::prelude::v1::*;
+
+use serde_derive::*;
+
+#[derive(Clone, Serialize, Deserialize, Debug)]
+pub struct InvokeTaskRequest {
+    pub task_id: String,
+    pub function_name: String,
+    pub task_token: String,
+    pub payload: Option<String>,
+}
+
+#[derive(Clone, Serialize, Deserialize, Debug)]
+pub struct InvokeTaskResponse {
+    pub result: String,
+}
+
+impl InvokeTaskRequest {
+    pub fn new(
+        task_id: &str,
+        function_name: &str,
+        task_token: &str,
+        payload: Option<&str>,
+    ) -> InvokeTaskRequest {
+        InvokeTaskRequest {
+            task_id: task_id.to_owned(),
+            function_name: function_name.to_owned(),
+            task_token: task_token.to_owned(),
+            payload: payload.map(|s| s.to_owned()),
+        }
+    }
+}
+
+impl InvokeTaskResponse {
+    pub fn new(result: &str) -> InvokeTaskResponse {
+        InvokeTaskResponse {
+            result: result.to_owned(),
+        }
+    }
+}
diff --git a/trusted-mesatee-sdk/teaclave_attestation/Cargo.lock b/trusted-mesatee-sdk/teaclave_attestation/Cargo.lock
new file mode 100644
index 0000000..f58828b
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_attestation/Cargo.lock
@@ -0,0 +1,909 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+[[package]]
+name = "anyhow"
+version = "1.0.28"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "autocfg"
+version = "0.1.7"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "autocfg"
+version = "1.0.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "base64"
+version = "0.10.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "byteorder 1.3.4 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "bit-vec"
+version = "0.6.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "bitflags"
+version = "1.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "bumpalo"
+version = "3.2.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "byteorder"
+version = "1.3.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "cc"
+version = "1.0.50"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "cfg-if"
+version = "0.1.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "chrono"
+version = "0.4.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "num-integer 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num-traits 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
+ "time 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "cloudabi"
+version = "0.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "fuchsia-cprng"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "hashbrown_tstd"
+version = "0.7.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "autocfg 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "httparse"
+version = "1.3.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "itoa"
+version = "0.4.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "js-sys"
+version = "0.3.37"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "wasm-bindgen 0.2.60 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "lazy_static"
+version = "1.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "spin 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "libc"
+version = "0.2.68"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "log"
+version = "0.4.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "num-bigint"
+version = "0.2.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "autocfg 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num-integer 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num-traits 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "num-integer"
+version = "0.1.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "autocfg 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num-traits 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "num-traits"
+version = "0.2.11"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "autocfg 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "proc-macro2"
+version = "1.0.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "quote"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "proc-macro2 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand"
+version = "0.6.5"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "autocfg 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.68 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_chacha 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_core 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_hc 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_isaac 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_jitter 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_os 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_pcg 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_xorshift 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand_chacha"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "autocfg 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "rand_core 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand_core"
+version = "0.4.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "rand_hc"
+version = "0.1.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand_isaac"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand_jitter"
+version = "0.1.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "libc 0.2.68 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_core 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand_os"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "fuchsia-cprng 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.68 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_core 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rdrand 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand_pcg"
+version = "0.1.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "autocfg 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rand_core 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rand_xorshift"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rdrand"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "redox_syscall"
+version = "0.1.56"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "ring"
+version = "0.16.11"
+dependencies = [
+ "cc 1.0.50 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_tstd 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "spin 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "untrusted 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "ring"
+version = "0.16.12"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cc 1.0.50 (registry+https://github.com/rust-lang/crates.io-index)",
+ "lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "libc 0.2.68 (registry+https://github.com/rust-lang/crates.io-index)",
+ "spin 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "untrusted 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "web-sys 0.3.37 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "rustls"
+version = "0.16.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "base64 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "ring 0.16.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sct 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "webpki 0.21.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "ryu"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "sct"
+version = "0.6.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "ring 0.16.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "untrusted 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "serde"
+version = "1.0.104"
+source = "git+https://github.com/mesalock-linux/serde-sgx?tag=sgx_1.1.0#c945ac9aeb23dc799070f3afaf590a6c3ac2c1a2"
+dependencies = [
+ "sgx_tstd 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "serde"
+version = "1.0.106"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "serde_derive"
+version = "1.0.104"
+source = "git+https://github.com/mesalock-linux/serde-sgx?tag=sgx_1.1.0#c945ac9aeb23dc799070f3afaf590a6c3ac2c1a2"
+dependencies = [
+ "proc-macro2 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quote 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "syn 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "serde_derive"
+version = "1.0.106"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "proc-macro2 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quote 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "syn 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "serde_json"
+version = "1.0.51"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "itoa 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)",
+ "ryu 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "serde 1.0.106 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "sgx_alloc"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+
+[[package]]
+name = "sgx_alloc"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "sgx_backtrace_sys"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "cc 1.0.50 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_build_helper 0.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_libc 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_backtrace_sys"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cc 1.0.50 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_build_helper 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_libc 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "sgx_build_helper"
+version = "0.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+
+[[package]]
+name = "sgx_build_helper"
+version = "0.1.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "sgx_demangle"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+
+[[package]]
+name = "sgx_demangle"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "sgx_libc"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_libc"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "sgx_types 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "sgx_rand"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "sgx_trts 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_tstd 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_types 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "sgx_tcrypto"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_tcrypto"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "sgx_types 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "sgx_tprotected_fs"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "sgx_trts 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_tprotected_fs"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "sgx_trts 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_types 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "sgx_trts"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "sgx_libc 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_trts"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "sgx_libc 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_types 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "sgx_tse"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_tse"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "sgx_types 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "sgx_tseal"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "sgx_tcrypto 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_trts 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_tse 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_tstd"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "sgx_alloc 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_backtrace_sys 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_demangle 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_libc 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_tprotected_fs 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_trts 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_tseal 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_unwind 0.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_tstd"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "hashbrown_tstd 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_alloc 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_backtrace_sys 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_demangle 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_libc 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_tprotected_fs 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_trts 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_types 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_unwind 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "sgx_types"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+
+[[package]]
+name = "sgx_types"
+version = "1.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "sgx_unwind"
+version = "0.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "sgx_build_helper 0.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_unwind"
+version = "0.1.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "sgx_build_helper 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "spin"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "syn"
+version = "1.0.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "proc-macro2 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quote 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "teaclave_attestation"
+version = "0.1.0"
+dependencies = [
+ "anyhow 1.0.28 (registry+https://github.com/rust-lang/crates.io-index)",
+ "base64 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "bit-vec 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)",
+ "chrono 0.4.11 (registry+https://github.com/rust-lang/crates.io-index)",
+ "httparse 1.3.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num-bigint 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
+ "rustls 0.16.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "serde_json 1.0.51 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_rand 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_tcrypto 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_tse 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_tstd 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_types 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "teaclave_config 0.1.0",
+ "teaclave_utils 0.1.0",
+ "thiserror 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)",
+ "uuid 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)",
+ "webpki 0.21.2 (registry+https://github.com/rust-lang/crates.io-index)",
+ "webpki-roots 0.17.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "yasna 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "teaclave_config"
+version = "0.1.0"
+dependencies = [
+ "lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "serde 1.0.106 (registry+https://github.com/rust-lang/crates.io-index)",
+ "serde_derive 1.0.106 (registry+https://github.com/rust-lang/crates.io-index)",
+ "toml 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "teaclave_utils"
+version = "0.1.0"
+dependencies = [
+ "ring 0.16.11",
+ "serde 1.0.104 (git+https://github.com/mesalock-linux/serde-sgx?tag=sgx_1.1.0)",
+ "serde_derive 1.0.104 (git+https://github.com/mesalock-linux/serde-sgx?tag=sgx_1.1.0)",
+ "sgx_tstd 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "toml 0.5.3",
+]
+
+[[package]]
+name = "thiserror"
+version = "1.0.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "thiserror-impl 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "thiserror-impl"
+version = "1.0.14"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "proc-macro2 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quote 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "syn 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "time"
+version = "0.1.42"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "libc 0.2.68 (registry+https://github.com/rust-lang/crates.io-index)",
+ "redox_syscall 0.1.56 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "toml"
+version = "0.5.3"
+dependencies = [
+ "serde 1.0.104 (git+https://github.com/mesalock-linux/serde-sgx?tag=sgx_1.1.0)",
+ "sgx_tstd 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "toml"
+version = "0.5.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "serde 1.0.106 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "unicode-xid"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "untrusted"
+version = "0.7.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "uuid"
+version = "0.7.4"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "wasm-bindgen"
+version = "0.2.60"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)",
+ "wasm-bindgen-macro 0.2.60 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "wasm-bindgen-backend"
+version = "0.2.60"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bumpalo 3.2.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)",
+ "proc-macro2 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quote 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "syn 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)",
+ "wasm-bindgen-shared 0.2.60 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "wasm-bindgen-macro"
+version = "0.2.60"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "quote 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "wasm-bindgen-macro-support 0.2.60 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "wasm-bindgen-macro-support"
+version = "0.2.60"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "proc-macro2 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quote 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "syn 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)",
+ "wasm-bindgen-backend 0.2.60 (registry+https://github.com/rust-lang/crates.io-index)",
+ "wasm-bindgen-shared 0.2.60 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "wasm-bindgen-shared"
+version = "0.2.60"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "web-sys"
+version = "0.3.37"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "js-sys 0.3.37 (registry+https://github.com/rust-lang/crates.io-index)",
+ "wasm-bindgen 0.2.60 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "webpki"
+version = "0.21.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "ring 0.16.12 (registry+https://github.com/rust-lang/crates.io-index)",
+ "untrusted 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "webpki-roots"
+version = "0.17.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "webpki 0.21.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "winapi"
+version = "0.3.8"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "winapi-i686-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "winapi-x86_64-pc-windows-gnu"
+version = "0.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "yasna"
+version = "0.3.1"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "bit-vec 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)",
+ "chrono 0.4.11 (registry+https://github.com/rust-lang/crates.io-index)",
+ "num-bigint 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[metadata]
+"checksum anyhow 1.0.28 (registry+https://github.com/rust-lang/crates.io-index)" = "d9a60d744a80c30fcb657dfe2c1b22bcb3e814c1a1e3674f32bf5820b570fbff"
+"checksum autocfg 0.1.7 (registry+https://github.com/rust-lang/crates.io-index)" = "1d49d90015b3c36167a20fe2810c5cd875ad504b39cff3d4eae7977e6b7c1cb2"
+"checksum autocfg 1.0.0 (registry+https://github.com/rust-lang/crates.io-index)" = "f8aac770f1885fd7e387acedd76065302551364496e46b3dd00860b2f8359b9d"
+"checksum base64 0.10.1 (registry+https://github.com/rust-lang/crates.io-index)" = "0b25d992356d2eb0ed82172f5248873db5560c4721f564b13cb5193bda5e668e"
+"checksum bit-vec 0.6.1 (registry+https://github.com/rust-lang/crates.io-index)" = "a4523a10839ffae575fb08aa3423026c8cb4687eef43952afb956229d4f246f7"
+"checksum bitflags 1.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "cf1de2fe8c75bc145a2f577add951f8134889b4795d47466a54a5c846d691693"
+"checksum bumpalo 3.2.1 (registry+https://github.com/rust-lang/crates.io-index)" = "12ae9db68ad7fac5fe51304d20f016c911539251075a214f8e663babefa35187"
+"checksum byteorder 1.3.4 (registry+https://github.com/rust-lang/crates.io-index)" = "08c48aae112d48ed9f069b33538ea9e3e90aa263cfa3d1c24309612b1f7472de"
+"checksum cc 1.0.50 (registry+https://github.com/rust-lang/crates.io-index)" = "95e28fa049fda1c330bcf9d723be7663a899c4679724b34c81e9f5a326aab8cd"
+"checksum cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)" = "4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822"
+"checksum chrono 0.4.11 (registry+https://github.com/rust-lang/crates.io-index)" = "80094f509cf8b5ae86a4966a39b3ff66cd7e2a3e594accec3743ff3fabeab5b2"
+"checksum cloudabi 0.0.3 (registry+https://github.com/rust-lang/crates.io-index)" = "ddfc5b9aa5d4507acaf872de71051dfd0e309860e88966e1051e462a077aac4f"
+"checksum fuchsia-cprng 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "a06f77d526c1a601b7c4cdd98f54b5eaabffc14d5f2f0296febdc7f357c6d3ba"
+"checksum hashbrown_tstd 0.7.1 (registry+https://github.com/rust-lang/crates.io-index)" = "3c57e7f2e84e024aff147279232fa17a5940ebcb7a6c9e6343a8f13adad3125c"
+"checksum httparse 1.3.4 (registry+https://github.com/rust-lang/crates.io-index)" = "cd179ae861f0c2e53da70d892f5f3029f9594be0c41dc5269cd371691b1dc2f9"
+"checksum itoa 0.4.5 (registry+https://github.com/rust-lang/crates.io-index)" = "b8b7a7c0c47db5545ed3fef7468ee7bb5b74691498139e4b3f6a20685dc6dd8e"
+"checksum js-sys 0.3.37 (registry+https://github.com/rust-lang/crates.io-index)" = "6a27d435371a2fa5b6d2b028a74bbdb1234f308da363226a2854ca3ff8ba7055"
+"checksum lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"
+"checksum libc 0.2.68 (registry+https://github.com/rust-lang/crates.io-index)" = "dea0c0405123bba743ee3f91f49b1c7cfb684eef0da0a50110f758ccf24cdff0"
+"checksum log 0.4.8 (registry+https://github.com/rust-lang/crates.io-index)" = "14b6052be84e6b71ab17edffc2eeabf5c2c3ae1fdb464aae35ac50c67a44e1f7"
+"checksum num-bigint 0.2.6 (registry+https://github.com/rust-lang/crates.io-index)" = "090c7f9998ee0ff65aa5b723e4009f7b217707f1fb5ea551329cc4d6231fb304"
+"checksum num-integer 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)" = "3f6ea62e9d81a77cd3ee9a2a5b9b609447857f3d358704331e4ef39eb247fcba"
+"checksum num-traits 0.2.11 (registry+https://github.com/rust-lang/crates.io-index)" = "c62be47e61d1842b9170f0fdeec8eba98e60e90e5446449a0545e5152acd7096"
+"checksum proc-macro2 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)" = "6c09721c6781493a2a492a96b5a5bf19b65917fe6728884e7c44dd0c60ca3435"
+"checksum quote 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)" = "2bdc6c187c65bca4260c9011c9e3132efe4909da44726bad24cf7572ae338d7f"
+"checksum rand 0.6.5 (registry+https://github.com/rust-lang/crates.io-index)" = "6d71dacdc3c88c1fde3885a3be3fbab9f35724e6ce99467f7d9c5026132184ca"
+"checksum rand_chacha 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "556d3a1ca6600bfcbab7c7c91ccb085ac7fbbcd70e008a98742e7847f4f7bcef"
+"checksum rand_core 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)" = "7a6fdeb83b075e8266dcc8762c22776f6877a63111121f5f8c7411e5be7eed4b"
+"checksum rand_core 0.4.2 (registry+https://github.com/rust-lang/crates.io-index)" = "9c33a3c44ca05fa6f1807d8e6743f3824e8509beca625669633be0acbdf509dc"
+"checksum rand_hc 0.1.0 (registry+https://github.com/rust-lang/crates.io-index)" = "7b40677c7be09ae76218dc623efbf7b18e34bced3f38883af07bb75630a21bc4"
+"checksum rand_isaac 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "ded997c9d5f13925be2a6fd7e66bf1872597f759fd9dd93513dd7e92e5a5ee08"
+"checksum rand_jitter 0.1.4 (registry+https://github.com/rust-lang/crates.io-index)" = "1166d5c91dc97b88d1decc3285bb0a99ed84b05cfd0bc2341bdf2d43fc41e39b"
+"checksum rand_os 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)" = "7b75f676a1e053fc562eafbb47838d67c84801e38fc1ba459e8f180deabd5071"
+"checksum rand_pcg 0.1.2 (registry+https://github.com/rust-lang/crates.io-index)" = "abf9b09b01790cfe0364f52bf32995ea3c39f4d2dd011eac241d2914146d0b44"
+"checksum rand_xorshift 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "cbf7e9e623549b0e21f6e97cf8ecf247c1a8fd2e8a992ae265314300b2455d5c"
+"checksum rdrand 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "678054eb77286b51581ba43620cc911abf02758c91f93f479767aed0f90458b2"
+"checksum redox_syscall 0.1.56 (registry+https://github.com/rust-lang/crates.io-index)" = "2439c63f3f6139d1b57529d16bc3b8bb855230c8efcc5d3a896c8bea7c3b1e84"
+"checksum ring 0.16.12 (registry+https://github.com/rust-lang/crates.io-index)" = "1ba5a8ec64ee89a76c98c549af81ff14813df09c3e6dc4766c3856da48597a0c"
+"checksum rustls 0.16.0 (registry+https://github.com/rust-lang/crates.io-index)" = "b25a18b1bf7387f0145e7f8324e700805aade3842dd3db2e74e4cdeb4677c09e"
+"checksum ryu 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)" = "535622e6be132bccd223f4bb2b8ac8d53cda3c7a6394944d3b2b33fb974f9d76"
+"checksum sct 0.6.0 (registry+https://github.com/rust-lang/crates.io-index)" = "e3042af939fca8c3453b7af0f1c66e533a15a86169e39de2657310ade8f98d3c"
+"checksum serde 1.0.104 (git+https://github.com/mesalock-linux/serde-sgx?tag=sgx_1.1.0)" = "<none>"
+"checksum serde 1.0.106 (registry+https://github.com/rust-lang/crates.io-index)" = "36df6ac6412072f67cf767ebbde4133a5b2e88e76dc6187fa7104cd16f783399"
+"checksum serde_derive 1.0.104 (git+https://github.com/mesalock-linux/serde-sgx?tag=sgx_1.1.0)" = "<none>"
+"checksum serde_derive 1.0.106 (registry+https://github.com/rust-lang/crates.io-index)" = "9e549e3abf4fb8621bd1609f11dfc9f5e50320802273b12f3811a67e6716ea6c"
+"checksum serde_json 1.0.51 (registry+https://github.com/rust-lang/crates.io-index)" = "da07b57ee2623368351e9a0488bb0b261322a15a6e0ae53e243cbdc0f4208da9"
+"checksum sgx_alloc 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_alloc 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "84804a804cb6af05d4cc88c922100c8a118c23a8dd358a058b792b754a0defba"
+"checksum sgx_backtrace_sys 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_backtrace_sys 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "d130c6906fd90640248619b9f30b9978e551d9848dbadd45d5dded534f77fcf8"
+"checksum sgx_build_helper 0.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_build_helper 0.1.3 (registry+https://github.com/rust-lang/crates.io-index)" = "2554e308f6aacd9198eac74d99fe72dd079c83e2e6de4e1af475bfe352ddb0df"
+"checksum sgx_demangle 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_demangle 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "df2a91c68258d157180f995639dc4f57414447709fbd0acf53ca1afb5fd9c410"
+"checksum sgx_libc 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_libc 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "fee2c4cbe19e311ed879fa44471208cc0dc63ea7eb84cc65c65d3c0e5909242f"
+"checksum sgx_rand 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "cc4072d8271d7b7768ddf7e437c353bd4391a2a805a3e8ec3da231c950905aff"
+"checksum sgx_tcrypto 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_tcrypto 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "fab75120c28a11c13f4e9879c6ab9ef1203ba91a59de1d2fbf42b854d10b3bae"
+"checksum sgx_tprotected_fs 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_tprotected_fs 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "639522f180dad519af8ea5e5cc1cffdc84f585030acadb313ad333e27701300d"
+"checksum sgx_trts 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_trts 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "63e3a84fb7cc0151f9c0d83c57dce4a29a9a619b8259e2473cca6b4aba0a94bc"
+"checksum sgx_tse 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_tse 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "6bb1eecaba028749a185674c055d200d622f8cbd27aac302115e66b4935cb4c4"
+"checksum sgx_tseal 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_tstd 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_tstd 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "5770678ad6b38d4ed7bf01be8e5f450ba60f3e54a3622d9c1a0f8626a744d871"
+"checksum sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_types 1.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "df329127455d6a2964782739218468878770a6dc54cb037b6c9c8846fe09d362"
+"checksum sgx_unwind 0.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_unwind 0.1.1 (registry+https://github.com/rust-lang/crates.io-index)" = "879db0855ab3c42027670722fc6d9d3d8cc7dc0aa674d0509e585951f6d3b203"
+"checksum spin 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)" = "6e63cff320ae2c57904679ba7cb63280a3dc4613885beafb148ee7bf9aa9042d"
+"checksum syn 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)" = "0df0eb663f387145cab623dea85b09c2c5b4b0aef44e945d928e682fce71bb03"
+"checksum thiserror 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)" = "f0570dc61221295909abdb95c739f2e74325e14293b2026b0a7e195091ec54ae"
+"checksum thiserror-impl 1.0.14 (registry+https://github.com/rust-lang/crates.io-index)" = "227362df41d566be41a28f64401e07a043157c21c14b9785a0d8e256f940a8fd"
+"checksum time 0.1.42 (registry+https://github.com/rust-lang/crates.io-index)" = "db8dcfca086c1143c9270ac42a2bbd8a7ee477b78ac8e45b19abfb0cbede4b6f"
+"checksum toml 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)" = "ffc92d160b1eef40665be3a05630d003936a3bc7da7421277846c2613e92c71a"
+"checksum unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c"
+"checksum untrusted 0.7.0 (registry+https://github.com/rust-lang/crates.io-index)" = "60369ef7a31de49bcb3f6ca728d4ba7300d9a1658f94c727d4cab8c8d9f4aece"
+"checksum uuid 0.7.4 (registry+https://github.com/rust-lang/crates.io-index)" = "90dbc611eb48397705a6b0f6e917da23ae517e4d127123d2cf7674206627d32a"
+"checksum wasm-bindgen 0.2.60 (registry+https://github.com/rust-lang/crates.io-index)" = "2cc57ce05287f8376e998cbddfb4c8cb43b84a7ec55cf4551d7c00eef317a47f"
+"checksum wasm-bindgen-backend 0.2.60 (registry+https://github.com/rust-lang/crates.io-index)" = "d967d37bf6c16cca2973ca3af071d0a2523392e4a594548155d89a678f4237cd"
+"checksum wasm-bindgen-macro 0.2.60 (registry+https://github.com/rust-lang/crates.io-index)" = "8bd151b63e1ea881bb742cd20e1d6127cef28399558f3b5d415289bc41eee3a4"
+"checksum wasm-bindgen-macro-support 0.2.60 (registry+https://github.com/rust-lang/crates.io-index)" = "d68a5b36eef1be7868f668632863292e37739656a80fc4b9acec7b0bd35a4931"
+"checksum wasm-bindgen-shared 0.2.60 (registry+https://github.com/rust-lang/crates.io-index)" = "daf76fe7d25ac79748a37538b7daeed1c7a6867c92d3245c12c6222e4a20d639"
+"checksum web-sys 0.3.37 (registry+https://github.com/rust-lang/crates.io-index)" = "2d6f51648d8c56c366144378a33290049eafdd784071077f6fe37dae64c1c4cb"
+"checksum webpki 0.21.2 (registry+https://github.com/rust-lang/crates.io-index)" = "f1f50e1972865d6b1adb54167d1c8ed48606004c2c9d0ea5f1eeb34d95e863ef"
+"checksum webpki-roots 0.17.0 (registry+https://github.com/rust-lang/crates.io-index)" = "a262ae37dd9d60f60dd473d1158f9fbebf110ba7b6a5051c8160460f6043718b"
+"checksum winapi 0.3.8 (registry+https://github.com/rust-lang/crates.io-index)" = "8093091eeb260906a183e6ae1abdba2ef5ef2257a21801128899c3fc699229c6"
+"checksum winapi-i686-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "ac3b87c63620426dd9b991e5ce0329eff545bccbbb34f3be09ff6fb6ab51b7b6"
+"checksum winapi-x86_64-pc-windows-gnu 0.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "712e227841d057c1ee1cd2fb22fa7e5a5461ae8e48fa2ca79ec42cfc1931183f"
+"checksum yasna 0.3.1 (registry+https://github.com/rust-lang/crates.io-index)" = "a563d10ead87e2d798e357d44f40f495ad70bcee4d5c0d3f77a5b1b7376645d9"
diff --git a/trusted-mesatee-sdk/teaclave_attestation/Cargo.toml b/trusted-mesatee-sdk/teaclave_attestation/Cargo.toml
new file mode 100644
index 0000000..efbfcee
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_attestation/Cargo.toml
@@ -0,0 +1,68 @@
+[package]
+name = "teaclave_attestation"
+version = "0.1.0"
+authors = ["MesaTEE Authors <developers@mesatee.org>"]
+description = "Teaclave Attestation"
+license = "Apache-2.0"
+edition = "2018"
+
+[lib]
+name = "teaclave_attestation"
+path = "src/lib.rs"
+
+[features]
+default = ["mesalock_sgx"]
+mesalock_sgx = ["sgx_tstd", "sgx_tcrypto", "sgx_rand", "sgx_tse"]
+
+[dependencies]
+#anyhow       = { version = "1.0.26" }
+#base64       = { version = "0.10.1" }
+#bit-vec      = { version = "0.6.1", default-features = false }
+#cfg-if       = { version = "0.1.9" }
+#chrono       = { version = "0.4.6" }
+#httparse     = { version = "1.3.2", default-features = false }
+#log          = { version = "0.4.6" }
+#env_logger   = { version = "0.7.1" }
+#num-bigint   = { version = "0.2.2" }
+#rustls       = { version = "0.16.0", features = ["dangerous_configuration"] }
+#serde_json   = { version = "1.0.39" }
+#thiserror    = { version = "1.0.9" }
+#uuid         = { version = "0.8.1", features = ["v4"] }
+#webpki       = { version = "0.21.0" }
+#webpki-roots = { version = "0.19.0" }
+#yasna        = { version = "0.3.0", features = ["bit-vec", "num-bigint", "chrono"] }
+
+#sgx_rand    = { version = "1.1.0", optional = true }
+#sgx_tcrypto = { version = "1.1.0", optional = true }
+#sgx_tse     = { version = "1.1.0", optional = true }
+#sgx_tstd    = { version = "1.1.0", features = ["net", "backtrace"], optional = true }
+#sgx_types   = { version = "1.1.0" }
+
+
+anyhow       = { git = "https://github.com/mesalock-linux/anyhow-sgx" }
+base64       = { git = "https://github.com/mesalock-linux/rust-base64-sgx" }
+bit-vec      = { version = "0.6.1", default-features = false }
+cfg-if       = { version = "0.1.10" }
+chrono       = { git = "https://github.com/mesalock-linux/chrono-sgx" }
+httparse     = { version = "1.3.2", default-features = false }
+log          = { git = "https://github.com/mesalock-linux/log-sgx" }
+env_logger   = { git = "https://github.com/mesalock-linux/env_logger-sgx" }
+num-bigint      = { git = "https://github.com/mesalock-linux/num-bigint-sgx" }
+rustls       = { git = "https://github.com/mesalock-linux/rustls", branch = "mesalock_sgx", features = ["dangerous_configuration"]}
+
+serde_json   = { git = "https://github.com/mesalock-linux/serde-json-sgx" }
+thiserror    = { git = "https://github.com/mesalock-linux/thiserror-sgx" }
+uuid         = { git = "https://github.com/mesalock-linux/uuid-sgx", features = ["v4"] }
+webpki       = { git = "https://github.com/mesalock-linux/webpki", branch = "mesalock_sgx" }
+webpki-roots= { git = "https://github.com/mesalock-linux/webpki-roots", branch = "mesalock_sgx" }
+yasna       = { git = "https://github.com/mesalock-linux/yasna.rs-sgx", features = ["bit-vec", "num-bigint", "chrono"] }
+
+sgx_rand     = { rev = "v1.1.2", git = "https://github.com/apache/teaclave-sgx-sdk.git", optional = true }
+sgx_tcrypto  = { rev = "v1.1.2", git = "https://github.com/apache/teaclave-sgx-sdk.git", optional = true }
+sgx_tse      = { rev = "v1.1.2", git = "https://github.com/apache/teaclave-sgx-sdk.git", optional = true }
+sgx_tstd     = { rev = "v1.1.2", git = "https://github.com/apache/teaclave-sgx-sdk.git",  features = ["net", "backtrace"], optional = true}
+sgx_types    = { rev = "v1.1.2", git = "https://github.com/apache/teaclave-sgx-sdk.git" }
+
+
+teaclave_config = { path = "../teaclave_config" }
+teaclave_utils  = { path = "../teaclave_utils" }
diff --git a/trusted-mesatee-sdk/teaclave_attestation/src/cert.rs b/trusted-mesatee-sdk/teaclave_attestation/src/cert.rs
new file mode 100644
index 0000000..c7bfcf6
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_attestation/src/cert.rs
@@ -0,0 +1,402 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+#![allow(
+    clippy::unused_unit,
+    clippy::needless_lifetimes,
+    clippy::redundant_closure
+)]
+// Insert std prelude in the top for the sgx feature
+#[cfg(feature = "mesalock_sgx")]
+use std::prelude::v1::*;
+
+use yasna::ASN1Result;
+use yasna::{BERReader, BERReaderSeq, BERReaderSet};
+use yasna::{DERWriter, DERWriterSeq, DERWriterSet};
+
+pub type Writer<'a> = DERWriter<'a>;
+pub type Reader<'a, 'b> = BERReader<'a, 'b>;
+
+pub trait ConsWriter<'a> {
+    fn next<'b>(&'b mut self) -> Writer<'b>;
+}
+
+pub trait ConsReader<'a, 'b>
+where
+    'a: 'b,
+{
+    fn next<'c>(&'c mut self, tags: &[yasna::Tag]) -> ASN1Result<Reader<'a, 'c>>;
+}
+
+impl<'a> ConsWriter<'a> for DERWriterSeq<'a> {
+    fn next<'b>(&'b mut self) -> Writer<'b> {
+        self.next()
+    }
+}
+
+impl<'a> ConsWriter<'a> for DERWriterSet<'a> {
+    fn next<'b>(&'b mut self) -> Writer<'b> {
+        self.next()
+    }
+}
+
+impl<'a, 'b> ConsReader<'a, 'b> for BERReaderSeq<'a, 'b> {
+    fn next<'c>(&'c mut self, _tags: &[yasna::Tag]) -> ASN1Result<Reader<'a, 'c>> {
+        Ok(self.next())
+    }
+}
+
+impl<'a, 'b> ConsReader<'a, 'b> for BERReaderSet<'a, 'b> {
+    fn next<'c>(&'c mut self, tags: &[yasna::Tag]) -> ASN1Result<Reader<'a, 'c>> {
+        self.next(tags)
+    }
+}
+
+pub trait Asn1Ty {
+    type ValueTy;
+    const TAG: yasna::Tag;
+    fn dump<'a>(writer: Writer<'a>, value: Self::ValueTy) -> ();
+    fn load<'a, 'b>(reader: Reader<'a, 'b>) -> ASN1Result<Self::ValueTy>
+    where
+        'a: 'b;
+}
+
+pub trait Asn1ConsTy
+where
+    Self: std::marker::Sized,
+{
+    type ValueTy;
+    fn dump<'a, W: ConsWriter<'a>>(writer: &mut W, value: Self::ValueTy) -> ();
+    fn load<'a, 'b, R>(reader: &mut R) -> ASN1Result<Self::ValueTy>
+    where
+        'a: 'b,
+        R: ConsReader<'a, 'b>;
+}
+
+pub trait Asn1Tag {
+    const TAG: yasna::Tag;
+}
+
+const fn context_tag(tnum: u64) -> yasna::Tag {
+    yasna::Tag {
+        tag_class: yasna::TagClass::ContextSpecific,
+        tag_number: tnum,
+    }
+}
+
+mod no_instance {
+    #![allow(dead_code)]
+
+    use super::{Asn1ConsTy, Asn1Tag, Asn1Ty};
+    use std::marker::PhantomData;
+
+    pub(crate) struct CtxT0;
+    pub(crate) struct CtxT1;
+    pub(crate) struct CtxT3;
+
+    pub(crate) struct Oid;
+    pub(crate) struct U8;
+    pub(crate) struct I8;
+    pub(crate) struct BigUint;
+    pub(crate) struct Utf8Str;
+    pub(crate) struct UtcTime;
+    pub(crate) struct BitVec;
+    pub(crate) struct Bytes;
+    pub(crate) struct Tagged<T: Asn1Tag, S: Asn1Ty> {
+        t: PhantomData<T>,
+        s: PhantomData<S>,
+    }
+    pub(crate) struct Sequence<U: Asn1Ty, V: Asn1ConsTy> {
+        u: PhantomData<U>,
+        v: PhantomData<V>,
+    }
+    pub(crate) struct Set<U: Asn1Ty, V: Asn1ConsTy> {
+        u: PhantomData<U>,
+        v: PhantomData<V>,
+    }
+    pub(crate) struct Cons<U: Asn1Ty, V: Asn1ConsTy> {
+        u: PhantomData<U>,
+        v: PhantomData<V>,
+    }
+    pub(crate) struct Nil;
+}
+
+use no_instance::*;
+
+impl Asn1Tag for CtxT0 {
+    const TAG: yasna::Tag = context_tag(0);
+}
+
+impl Asn1Tag for CtxT1 {
+    const TAG: yasna::Tag = context_tag(1);
+}
+
+impl Asn1Tag for CtxT3 {
+    const TAG: yasna::Tag = context_tag(3);
+}
+
+impl<U: Asn1Ty, V: Asn1ConsTy> Asn1ConsTy for Cons<U, V> {
+    type ValueTy = (U::ValueTy, V::ValueTy);
+    fn dump<'a, W: ConsWriter<'a>>(writer: &mut W, value: Self::ValueTy) -> () {
+        U::dump(writer.next(), value.0);
+        V::dump(writer, value.1);
+    }
+    fn load<'a, 'b, R>(reader: &mut R) -> ASN1Result<Self::ValueTy>
+    where
+        'a: 'b,
+        R: ConsReader<'a, 'b>,
+    {
+        let first = U::load(reader.next(&[U::TAG])?)?;
+        let second = V::load(reader)?;
+        Ok((first, second))
+    }
+}
+
+impl Asn1ConsTy for Nil {
+    type ValueTy = ();
+    fn dump<'a, W: ConsWriter<'a>>(_writer: &mut W, _value: Self::ValueTy) -> () {}
+    fn load<'a, 'b, R>(_reader: &mut R) -> ASN1Result<Self::ValueTy>
+    where
+        'a: 'b,
+        R: ConsReader<'a, 'b>,
+    {
+        Ok(())
+    }
+}
+
+impl<T: Asn1Tag, S: Asn1Ty> Asn1Ty for Tagged<T, S> {
+    type ValueTy = S::ValueTy;
+    const TAG: yasna::Tag = T::TAG;
+    fn dump<'a>(writer: Writer<'a>, value: Self::ValueTy) {
+        writer.write_tagged(T::TAG, |writer| S::dump(writer, value));
+    }
+    fn load<'a, 'b>(reader: Reader<'a, 'b>) -> ASN1Result<Self::ValueTy>
+    where
+        'a: 'b,
+    {
+        reader.read_tagged(T::TAG, |reader| S::load(reader))
+    }
+}
+
+impl<U: Asn1Ty, V: Asn1ConsTy> Asn1Ty for Sequence<U, V> {
+    type ValueTy = (U::ValueTy, V::ValueTy);
+    const TAG: yasna::Tag = yasna::tags::TAG_SEQUENCE;
+    fn dump<'a>(writer: Writer<'a>, value: Self::ValueTy) {
+        writer.write_sequence(|writer| {
+            U::dump(writer.next(), value.0);
+            V::dump(writer, value.1);
+        });
+    }
+    fn load<'a, 'b>(reader: Reader<'a, 'b>) -> ASN1Result<Self::ValueTy>
+    where
+        'a: 'b,
+    {
+        reader.read_sequence(|reader| {
+            let first = U::load(reader.next())?;
+            let second = V::load(reader)?;
+            Ok((first, second))
+        })
+    }
+}
+
+impl<U: Asn1Ty, V: Asn1ConsTy> Asn1Ty for Set<U, V> {
+    type ValueTy = (U::ValueTy, V::ValueTy);
+    const TAG: yasna::Tag = yasna::tags::TAG_SET;
+    fn dump<'a>(writer: Writer<'a>, value: Self::ValueTy) {
+        writer.write_set(|writer| {
+            U::dump(writer.next(), value.0);
+            V::dump(writer, value.1);
+        });
+    }
+    fn load<'a, 'b>(reader: Reader<'a, 'b>) -> ASN1Result<Self::ValueTy>
+    where
+        'a: 'b,
+    {
+        reader.read_set(|reader| {
+            let first = U::load(reader.next(&[U::TAG])?)?;
+            let second = V::load(reader)?;
+            Ok((first, second))
+        })
+    }
+}
+
+impl Asn1Ty for U8 {
+    type ValueTy = u8;
+    const TAG: yasna::Tag = yasna::tags::TAG_INTEGER;
+    fn dump<'a>(writer: Writer<'a>, value: Self::ValueTy) {
+        writer.write_u8(value);
+    }
+    fn load<'a, 'b>(reader: Reader<'a, 'b>) -> ASN1Result<Self::ValueTy>
+    where
+        'a: 'b,
+    {
+        reader.read_u8()
+    }
+}
+
+impl Asn1Ty for I8 {
+    type ValueTy = i8;
+    const TAG: yasna::Tag = yasna::tags::TAG_INTEGER;
+    fn dump<'a>(writer: Writer<'a>, value: Self::ValueTy) {
+        writer.write_i8(value);
+    }
+    fn load<'a, 'b>(reader: Reader<'a, 'b>) -> ASN1Result<Self::ValueTy>
+    where
+        'a: 'b,
+    {
+        reader.read_i8()
+    }
+}
+
+impl Asn1Ty for BigUint {
+    type ValueTy = num_bigint::BigUint;
+    const TAG: yasna::Tag = yasna::tags::TAG_INTEGER;
+    fn dump<'a>(writer: Writer<'a>, value: Self::ValueTy) {
+        writer.write_biguint(&value);
+    }
+    fn load<'a, 'b>(reader: Reader<'a, 'b>) -> ASN1Result<Self::ValueTy>
+    where
+        'a: 'b,
+    {
+        reader.read_biguint()
+    }
+}
+
+impl Asn1Ty for Utf8Str {
+    type ValueTy = String;
+    const TAG: yasna::Tag = yasna::tags::TAG_UTF8STRING;
+    fn dump<'a>(writer: Writer<'a>, value: Self::ValueTy) {
+        writer.write_utf8_string(value.as_str());
+    }
+    fn load<'a, 'b>(reader: Reader<'a, 'b>) -> ASN1Result<Self::ValueTy>
+    where
+        'a: 'b,
+    {
+        reader.read_utf8string()
+    }
+}
+
+impl Asn1Ty for Oid {
+    type ValueTy = yasna::models::ObjectIdentifier;
+    const TAG: yasna::Tag = yasna::tags::TAG_OID;
+    fn dump<'a>(writer: Writer<'a>, value: Self::ValueTy) {
+        writer.write_oid(&value);
+    }
+    fn load<'a, 'b>(reader: Reader<'a, 'b>) -> ASN1Result<Self::ValueTy>
+    where
+        'a: 'b,
+    {
+        reader.read_oid()
+    }
+}
+
+impl Asn1Ty for UtcTime {
+    type ValueTy = yasna::models::UTCTime;
+    const TAG: yasna::Tag = yasna::tags::TAG_UTCTIME;
+    fn dump<'a>(writer: Writer<'a>, value: Self::ValueTy) {
+        writer.write_utctime(&value);
+    }
+    fn load<'a, 'b>(reader: Reader<'a, 'b>) -> ASN1Result<Self::ValueTy>
+    where
+        'a: 'b,
+    {
+        reader.read_utctime()
+    }
+}
+
+impl Asn1Ty for BitVec {
+    type ValueTy = bit_vec::BitVec;
+    const TAG: yasna::Tag = yasna::tags::TAG_BITSTRING;
+    fn dump<'a>(writer: Writer<'a>, value: Self::ValueTy) {
+        writer.write_bitvec(&value);
+    }
+    fn load<'a, 'b>(reader: Reader<'a, 'b>) -> ASN1Result<Self::ValueTy>
+    where
+        'a: 'b,
+    {
+        reader.read_bitvec()
+    }
+}
+
+impl Asn1Ty for Bytes {
+    type ValueTy = Vec<u8>;
+    const TAG: yasna::Tag = yasna::tags::TAG_OCTETSTRING;
+    fn dump<'a>(writer: Writer<'a>, value: Self::ValueTy) {
+        writer.write_bytes(&value.as_slice());
+    }
+    fn load<'a, 'b>(reader: Reader<'a, 'b>) -> ASN1Result<Self::ValueTy>
+    where
+        'a: 'b,
+    {
+        reader.read_bytes()
+    }
+}
+
+macro_rules! cons {
+    () => { Nil };
+    ($t: ty) => { Cons<$t, Nil> };
+    ($t: ty, $($tt: ty),* $(,)?) => {
+        Cons<$t, cons! { $($tt),* }>
+    };
+}
+
+macro_rules! asn1_seq_ty {
+    ($t: ty) => { Sequence<$t, Nil> };
+    ($t: ty, $($tt: ty),* $(,)?) => {
+        Sequence<$t, cons! { $($tt),* }>
+    };
+}
+
+macro_rules! asn1_set_ty {
+    ($t: ty) => { Set<$t, Nil> };
+    ($t: ty, $($tt: ty),* $(,)?) => {
+        Set<$t, cons! { $($tt),* }>
+    };
+}
+
+#[cfg(feature = "mesalock_sgx")]
+macro_rules! asn1_seq {
+    () => { () };
+    ($e: expr) => {
+        ($e, ())
+    };
+    ($e: expr , $($ee: expr),* $(,)?) => {
+        ($e, asn1_seq!{ $($ee),* } )
+    };
+}
+
+pub(crate) type Version = Tagged<CtxT0, I8>;
+pub(crate) type Serial = U8;
+pub(crate) type CertSignAlgo = asn1_seq_ty!(Oid);
+pub(crate) type ValidRange = asn1_seq_ty!(UtcTime, UtcTime);
+pub(crate) type Issuer = asn1_seq_ty!(asn1_set_ty!(asn1_seq_ty!(Oid, Utf8Str)));
+pub(crate) type Subject = Issuer;
+pub(crate) type PubKeyAlgo = asn1_seq_ty!(Oid, Oid);
+pub(crate) type PubKey = asn1_seq_ty!(PubKeyAlgo, BitVec);
+pub(crate) type SgxRaCertExt = Tagged<CtxT3, asn1_seq_ty!(asn1_seq_ty!(Oid, Bytes))>;
+pub(crate) type TbsCert = asn1_seq_ty!(
+    Version,
+    Serial,
+    CertSignAlgo,
+    Issuer,
+    ValidRange,
+    Subject,
+    PubKey,
+    SgxRaCertExt,
+);
+pub(crate) type CertSig = BitVec;
+pub(crate) type X509 = asn1_seq_ty!(TbsCert, CertSignAlgo, CertSig);
diff --git a/trusted-mesatee-sdk/teaclave_attestation/src/ias.rs b/trusted-mesatee-sdk/teaclave_attestation/src/ias.rs
new file mode 100644
index 0000000..cbfdcf2
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_attestation/src/ias.rs
@@ -0,0 +1,215 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+use crate::report::IasReport;
+use crate::AttestationError;
+use anyhow::Error;
+use anyhow::Result;
+use log::debug;
+use sgx_types::*;
+use std::collections::HashMap;
+use std::io::{Read, Write};
+use std::net::TcpStream;
+use std::prelude::v1::*;
+use std::sync::Arc;
+use teaclave_utils;
+
+extern "C" {
+    fn ocall_sgx_get_ias_socket(p_retval: *mut i32) -> sgx_status_t;
+}
+
+pub struct IasClient {
+    ias_key: String,
+    ias_hostname: &'static str,
+}
+
+impl IasClient {
+    pub fn new(ias_key: &str, production: bool) -> Self {
+        let ias_hostname = if production {
+            "as.sgx.trustedservices.intel.com"
+        } else {
+            "api.trustedservices.intel.com"
+        };
+
+        Self {
+            ias_key: ias_key.to_owned(),
+            ias_hostname,
+        }
+    }
+
+    fn get_ias_socket() -> Result<c_int> {
+        debug!("get_ias_socket");
+        let mut fd: i32 = -1i32;
+        let res = unsafe { ocall_sgx_get_ias_socket(&mut fd as _) };
+
+        if res != sgx_status_t::SGX_SUCCESS || fd < 0 {
+            Err(Error::new(AttestationError::OCallError))
+        } else {
+            Ok(fd)
+        }
+    }
+
+    fn new_tls_stream(&self) -> Result<rustls::StreamOwned<rustls::ClientSession, TcpStream>> {
+        let fd = Self::get_ias_socket()?;
+        let dns_name = webpki::DNSNameRef::try_from_ascii_str(self.ias_hostname)?;
+        let mut config = rustls::ClientConfig::new();
+        config
+            .root_store
+            .add_server_trust_anchors(&webpki_roots::TLS_SERVER_ROOTS);
+        let client = rustls::ClientSession::new(&Arc::new(config), dns_name);
+        let socket = TcpStream::new(fd)?;
+        let stream = rustls::StreamOwned::new(client, socket);
+
+        Ok(stream)
+    }
+
+    pub fn get_sigrl(&mut self, epid_group_id: u32) -> Result<Vec<u8>> {
+        let sigrl_uri = format!("/sgx/dev/attestation/v3/sigrl/{:08x}", epid_group_id);
+        let request = format!(
+            "GET {} HTTP/1.1\r\n\
+             HOST: {}\r\n\
+             Ocp-Apim-Subscription-Key: {}\r\n\
+             Connection: Close\r\n\r\n",
+            sigrl_uri, self.ias_hostname, self.ias_key
+        );
+
+        let mut stream = self.new_tls_stream()?;
+        stream.write_all(request.as_bytes())?;
+        let mut response = Vec::new();
+        stream.read_to_end(&mut response)?;
+
+        let mut headers = [httparse::EMPTY_HEADER; 16];
+        let mut http_response = httparse::Response::new(&mut headers);
+        let header_len = match http_response
+            .parse(&response)
+            .map_err(|_| Error::new(AttestationError::IasError))?
+        {
+            httparse::Status::Complete(s) => s,
+            _ => return Err(Error::new(AttestationError::IasError)),
+        };
+
+        let header_map = Self::parse_headers(&http_response);
+
+        if !header_map.contains_key("Content-Length")
+            || header_map
+                .get("Content-Length")
+                .unwrap()
+                .parse::<u32>()
+                .unwrap_or(0)
+                == 0
+        {
+            Ok(Vec::new())
+        } else {
+            let base64 = std::str::from_utf8(&response[header_len..])?;
+
+            let decoded = base64::decode(base64)?;
+            Ok(decoded)
+        }
+    }
+
+    pub fn get_report(&mut self, quote: &[u8]) -> Result<IasReport> {
+        debug!("get_report");
+        let report_uri = "/sgx/dev/attestation/v3/report";
+        let encoded_quote = base64::encode(quote);
+        let encoded_json = format!("{{\"isvEnclaveQuote\":\"{}\"}}\r\n", encoded_quote);
+
+        let request = format!(
+            "POST {} HTTP/1.1\r\n\
+             HOST: {}\r\n\
+             Ocp-Apim-Subscription-Key: {}\r\n\
+             Connection: Close\r\n\
+             Content-Length: {}\r\n\
+             Content-Type: application/json\r\n\r\n\
+             {}",
+            report_uri,
+            self.ias_hostname,
+            self.ias_key,
+            encoded_json.len(),
+            encoded_json
+        );
+        debug!("{}", request);
+
+        let mut stream = self.new_tls_stream()?;
+        stream.write_all(request.as_bytes())?;
+        let mut response = Vec::new();
+        stream.read_to_end(&mut response)?;
+
+        debug!("{}", String::from_utf8_lossy(&response));
+
+        let mut headers = [httparse::EMPTY_HEADER; 16];
+        let mut http_response = httparse::Response::new(&mut headers);
+        debug!("http_response.parse");
+        let header_len = match http_response
+            .parse(&response)
+            .map_err(|_| Error::new(AttestationError::IasError))?
+        {
+            httparse::Status::Complete(s) => s,
+            _ => return Err(Error::new(AttestationError::IasError)),
+        };
+
+        debug!("Self::parse_headers");
+        let header_map = Self::parse_headers(&http_response);
+
+        debug!("get_content_length");
+        if !header_map.contains_key("Content-Length")
+            || header_map
+                .get("Content-Length")
+                .unwrap()
+                .parse::<u32>()
+                .unwrap_or(0)
+                == 0
+        {
+            return Err(Error::new(AttestationError::IasError));
+        }
+
+        debug!("get_signature");
+        let signature = header_map
+            .get("X-IASReport-Signature")
+            .ok_or_else(|| Error::new(AttestationError::IasError))?
+            .to_owned();
+        debug!("get_signing_cert");
+        let signing_cert = {
+            let cert_str = header_map
+                .get("X-IASReport-Signing-Certificate")
+                .ok_or_else(|| Error::new(AttestationError::IasError))?;
+            let decoded_cert = teaclave_utils::percent_decode(cert_str)?;
+            // We should get two concatenated PEM files at this step.
+            let cert_content: Vec<&str> = decoded_cert.split("-----").collect();
+            cert_content[2].to_string()
+        };
+
+        debug!("get_report");
+        let report = String::from_utf8_lossy(&response[header_len..]).into_owned();
+        Ok(IasReport {
+            report,
+            signature,
+            signing_cert,
+        })
+    }
+
+    fn parse_headers(resp: &httparse::Response) -> HashMap<String, String> {
+        let mut header_map = HashMap::new();
+        for h in resp.headers.iter() {
+            header_map.insert(
+                h.name.to_owned(),
+                String::from_utf8_lossy(h.value).into_owned(),
+            );
+        }
+
+        header_map
+    }
+}
diff --git a/trusted-mesatee-sdk/teaclave_attestation/src/key.rs b/trusted-mesatee-sdk/teaclave_attestation/src/key.rs
new file mode 100644
index 0000000..6c7c827
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_attestation/src/key.rs
@@ -0,0 +1,184 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+use anyhow::Result;
+use sgx_tcrypto::SgxEccHandle;
+use sgx_types::{sgx_ec256_private_t, sgx_ec256_public_t};
+use std::prelude::v1::*;
+
+pub const CERT_VALID_DAYS: i64 = 90i64;
+
+pub struct Secp256k1KeyPair {
+    prv_k: sgx_ec256_private_t,
+    pub pub_k: sgx_ec256_public_t,
+}
+
+impl Secp256k1KeyPair {
+    pub fn new() -> Result<Self> {
+        let ecc_handle = SgxEccHandle::new();
+        ecc_handle.open().unwrap();
+        let (prv_k, pub_k) = ecc_handle.create_key_pair().unwrap();
+        ecc_handle.close().unwrap();
+        Ok(Self { prv_k, pub_k })
+    }
+
+    pub fn private_key_into_der(&self) -> Vec<u8> {
+        use bit_vec::BitVec;
+        use yasna::construct_der;
+        use yasna::models::ObjectIdentifier;
+        use yasna::Tag;
+
+        let ec_public_key_oid = ObjectIdentifier::from_slice(&[1, 2, 840, 10045, 2, 1]);
+        let prime256v1_oid = ObjectIdentifier::from_slice(&[1, 2, 840, 10045, 3, 1, 7]);
+
+        let pub_key_bytes = self.public_key_into_bytes();
+        let prv_key_bytes = self.private_key_into_bytes();
+
+        // Construct private key in DER.
+        construct_der(|writer| {
+            writer.write_sequence(|writer| {
+                writer.next().write_u8(0);
+                writer.next().write_sequence(|writer| {
+                    writer.next().write_oid(&ec_public_key_oid);
+                    writer.next().write_oid(&prime256v1_oid);
+                });
+                let inner_key_der = construct_der(|writer| {
+                    writer.write_sequence(|writer| {
+                        writer.next().write_u8(1);
+                        writer.next().write_bytes(&prv_key_bytes);
+                        writer.next().write_tagged(Tag::context(1), |writer| {
+                            writer.write_bitvec(&BitVec::from_bytes(&pub_key_bytes));
+                        });
+                    });
+                });
+                writer.next().write_bytes(&inner_key_der);
+            });
+        })
+    }
+
+    pub fn create_cert_with_extension(
+        &self,
+        issuer: &str,
+        subject: &str,
+        payload: &[u8],
+    ) -> Vec<u8> {
+        use crate::cert::*;
+        use bit_vec::BitVec;
+        use chrono::TimeZone;
+        use num_bigint::BigUint;
+        use std::time::SystemTime;
+        use std::time::UNIX_EPOCH;
+        use std::untrusted::time::SystemTimeEx;
+        use yasna::construct_der;
+        use yasna::models::{ObjectIdentifier, UTCTime};
+
+        let ecdsa_with_sha256_oid = ObjectIdentifier::from_slice(&[1, 2, 840, 10045, 4, 3, 2]);
+        let common_name_oid = ObjectIdentifier::from_slice(&[2, 5, 4, 3]);
+        let ec_public_key_oid = ObjectIdentifier::from_slice(&[1, 2, 840, 10045, 2, 1]);
+        let prime256v1_oid = ObjectIdentifier::from_slice(&[1, 2, 840, 10045, 3, 1, 7]);
+        let comment_oid = ObjectIdentifier::from_slice(&[2, 16, 840, 1, 113_730, 1, 13]);
+
+        let pub_key_bytes = self.public_key_into_bytes();
+
+        // UNIX_EPOCH is the earliest time stamp. This unwrap should constantly succeed.
+        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();
+        let issue_ts = chrono::Utc.timestamp(now.as_secs() as i64, 0);
+
+        // This is guaranteed to be a valid duration.
+        let expire = now + chrono::Duration::days(CERT_VALID_DAYS).to_std().unwrap();
+        let expire_ts = chrono::Utc.timestamp(expire.as_secs() as i64, 0);
+
+        // Construct certificate with payload in extension in DER.
+        let tbs_cert_der = construct_der(|writer| {
+            let version = 2i8;
+            let serial = 1u8;
+            let cert_sign_algo = asn1_seq!(ecdsa_with_sha256_oid.clone());
+            let issuer = asn1_seq!(asn1_seq!(asn1_seq!(
+                common_name_oid.clone(),
+                issuer.to_owned()
+            )));
+            let valid_range = asn1_seq!(
+                UTCTime::from_datetime(&issue_ts),
+                UTCTime::from_datetime(&expire_ts),
+            );
+            let subject = asn1_seq!(asn1_seq!(asn1_seq!(
+                common_name_oid.clone(),
+                subject.to_string(),
+            )));
+            let pub_key = asn1_seq!(
+                asn1_seq!(ec_public_key_oid, prime256v1_oid,),
+                BitVec::from_bytes(&pub_key_bytes),
+            );
+            let sgx_ra_cert_ext = asn1_seq!(asn1_seq!(comment_oid, payload.to_owned()));
+            let tbs_cert = asn1_seq!(
+                version,
+                serial,
+                cert_sign_algo,
+                issuer,
+                valid_range,
+                subject,
+                pub_key,
+                sgx_ra_cert_ext,
+            );
+            TbsCert::dump(writer, tbs_cert);
+        });
+
+        // There will be serious problems if this call fails. We might as well
+        // panic in this case, thus unwrap()
+        let ecc_handle = SgxEccHandle::new();
+        ecc_handle.open().unwrap();
+
+        let sig = ecc_handle
+            .ecdsa_sign_slice(&tbs_cert_der.as_slice(), &self.prv_k)
+            .unwrap();
+
+        let sig_der = yasna::construct_der(|writer| {
+            writer.write_sequence(|writer| {
+                let mut sig_x = sig.x;
+                sig_x.reverse();
+                let mut sig_y = sig.y;
+                sig_y.reverse();
+                writer.next().write_biguint(&BigUint::from_slice(&sig_x));
+                writer.next().write_biguint(&BigUint::from_slice(&sig_y));
+            });
+        });
+
+        yasna::construct_der(|writer| {
+            writer.write_sequence(|writer| {
+                writer.next().write_der(&tbs_cert_der.as_slice());
+                CertSignAlgo::dump(writer.next(), asn1_seq!(ecdsa_with_sha256_oid.clone()));
+                writer
+                    .next()
+                    .write_bitvec(&BitVec::from_bytes(&sig_der.as_slice()));
+            });
+        })
+    }
+
+    fn public_key_into_bytes(&self) -> Vec<u8> {
+        // The first byte must be 4, which indicates the uncompressed encoding.
+        let mut pub_key_bytes: Vec<u8> = vec![4];
+        pub_key_bytes.extend(self.pub_k.gx.iter().rev());
+        pub_key_bytes.extend(self.pub_k.gy.iter().rev());
+        pub_key_bytes
+    }
+
+    fn private_key_into_bytes(&self) -> Vec<u8> {
+        let mut prv_key_bytes: Vec<u8> = vec![];
+        prv_key_bytes.extend(self.prv_k.r.iter().rev());
+        prv_key_bytes
+    }
+}
diff --git a/trusted-mesatee-sdk/teaclave_attestation/src/lib.rs b/trusted-mesatee-sdk/teaclave_attestation/src/lib.rs
new file mode 100644
index 0000000..24668d9
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_attestation/src/lib.rs
@@ -0,0 +1,52 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+#![cfg_attr(feature = "mesalock_sgx", no_std)]
+#[cfg(feature = "mesalock_sgx")]
+#[macro_use]
+extern crate sgx_tstd as std;
+
+//#[macro_use]
+extern crate log;
+
+use thiserror::Error;
+
+#[derive(Error, Debug)]
+pub enum AttestationError {
+    #[error("OCall failed")]
+    OCallError,
+    #[error("Ias error")]
+    IasError,
+    #[error("Get quote error")]
+    QuoteError,
+}
+
+#[macro_use]
+mod cert;
+pub mod quote;
+pub mod verifier;
+
+use cfg_if::cfg_if;
+cfg_if! {
+    if #[cfg(feature = "mesalock_sgx")]  {
+        pub mod key;
+        mod report;
+        mod ias;
+        pub use report::IasReport;
+    } else {
+    }
+}
diff --git a/trusted-mesatee-sdk/teaclave_attestation/src/quote.rs b/trusted-mesatee-sdk/teaclave_attestation/src/quote.rs
new file mode 100644
index 0000000..ce58552
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_attestation/src/quote.rs
@@ -0,0 +1,370 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+#![allow(clippy::redundant_closure)]
+
+// Insert std prelude in the top for the sgx feature
+#[cfg(feature = "mesalock_sgx")]
+use std::prelude::v1::*;
+
+use anyhow::{Error, Result};
+use chrono::DateTime;
+use rustls;
+use serde_json;
+use serde_json::Value;
+use std::convert::TryFrom;
+use std::io::BufReader;
+use std::time::*;
+
+#[cfg(feature = "mesalock_sgx")]
+use std::untrusted::time::SystemTimeEx;
+
+use uuid::Uuid;
+
+type SignatureAlgorithms = &'static [&'static webpki::SignatureAlgorithm];
+static SUPPORTED_SIG_ALGS: SignatureAlgorithms = &[
+    &webpki::ECDSA_P256_SHA256,
+    &webpki::ECDSA_P256_SHA384,
+    &webpki::ECDSA_P384_SHA256,
+    &webpki::ECDSA_P384_SHA384,
+    &webpki::RSA_PSS_2048_8192_SHA256_LEGACY_KEY,
+    &webpki::RSA_PSS_2048_8192_SHA384_LEGACY_KEY,
+    &webpki::RSA_PSS_2048_8192_SHA512_LEGACY_KEY,
+    &webpki::RSA_PKCS1_2048_8192_SHA256,
+    &webpki::RSA_PKCS1_2048_8192_SHA384,
+    &webpki::RSA_PKCS1_2048_8192_SHA512,
+    &webpki::RSA_PKCS1_3072_8192_SHA384,
+];
+
+use thiserror::Error;
+
+#[derive(Error, Debug)]
+pub enum CertVerificationError {
+    #[error("Invalid cert format")]
+    InvalidCertFormat,
+    #[error("Bad attestation report")]
+    BadAttnReport,
+    #[error("Webpki failure")]
+    WebpkiFailure,
+}
+
+pub struct SgxReport {
+    pub cpu_svn: [u8; 16],
+    pub misc_select: u32,
+    pub attributes: [u8; 16],
+    pub mr_enclave: [u8; 32],
+    pub mr_signer: [u8; 32],
+    pub isv_prod_id: u16,
+    pub isv_svn: u16,
+    pub report_data: [u8; 64],
+}
+
+pub enum SgxQuoteVersion {
+    V1,
+    V2,
+}
+
+pub enum SgxQuoteSigType {
+    Unlinkable,
+    Linkable,
+}
+
+#[derive(PartialEq, Debug)]
+pub enum SgxQuoteStatus {
+    OK,
+    GroupOutOfDate,
+    ConfigurationNeeded,
+    UnknownBadStatus,
+}
+
+impl From<&str> for SgxQuoteStatus {
+    fn from(status: &str) -> Self {
+        match status {
+            "OK" => SgxQuoteStatus::OK,
+            "GROUP_OUT_OF_DATE" => SgxQuoteStatus::GroupOutOfDate,
+            "CONFIGURATION_NEEDED" => SgxQuoteStatus::ConfigurationNeeded,
+            _ => SgxQuoteStatus::UnknownBadStatus,
+        }
+    }
+}
+
+pub struct SgxQuoteBody {
+    pub version: SgxQuoteVersion,
+    pub signature_type: SgxQuoteSigType,
+    pub gid: u32,
+    pub isv_svn_qe: u16,
+    pub isv_svn_pce: u16,
+    pub qe_vendor_id: Uuid,
+    pub user_data: [u8; 20],
+    pub report_body: SgxReport,
+}
+
+impl SgxQuoteBody {
+    // TODO: A Result should be returned instead of Option
+    fn parse_from<'a>(bytes: &'a [u8]) -> Option<Self> {
+        let mut pos: usize = 0;
+        // TODO: It is really unnecessary to construct a Vec<u8> each time.
+        // Try to optimize this.
+        let mut take = |n: usize| -> Option<&'a [u8]> {
+            if n > 0 && bytes.len() >= pos + n {
+                let ret = Some(&bytes[pos..pos + n]);
+                pos += n;
+                ret
+            } else {
+                None
+            }
+        };
+
+        // off 0, size 2
+        let version = match u16::from_le_bytes(<[u8; 2]>::try_from(take(2)?).ok()?) {
+            1 => SgxQuoteVersion::V1,
+            2 => SgxQuoteVersion::V2,
+            _ => return None,
+        };
+
+        // off 2, size 2
+        let signature_type = match u16::from_le_bytes(<[u8; 2]>::try_from(take(2)?).ok()?) {
+            0 => SgxQuoteSigType::Unlinkable,
+            1 => SgxQuoteSigType::Linkable,
+            _ => return None,
+        };
+
+        // off 4, size 4
+        let gid = u32::from_le_bytes(<[u8; 4]>::try_from(take(4)?).ok()?);
+
+        // off 8, size 2
+        let isv_svn_qe = u16::from_le_bytes(<[u8; 2]>::try_from(take(2)?).ok()?);
+
+        // off 10, size 2
+        let isv_svn_pce = u16::from_le_bytes(<[u8; 2]>::try_from(take(2)?).ok()?);
+
+        // off 12, size 16
+        let qe_vendor_id_raw = <[u8; 16]>::try_from(take(16)?).ok()?;
+        let qe_vendor_id = Uuid::from_slice(&qe_vendor_id_raw).ok()?;
+
+        // off 28, size 20
+        let user_data = <[u8; 20]>::try_from(take(20)?).ok()?;
+
+        // off 48, size 16
+        let cpu_svn = <[u8; 16]>::try_from(take(16)?).ok()?;
+
+        // off 64, size 4
+        let misc_select = u32::from_le_bytes(<[u8; 4]>::try_from(take(4)?).ok()?);
+
+        // off 68, size 28
+        let _reserved = take(28)?;
+
+        // off 96, size 16
+        let attributes = <[u8; 16]>::try_from(take(16)?).ok()?;
+
+        // off 112, size 32
+        let mr_enclave = <[u8; 32]>::try_from(take(32)?).ok()?;
+
+        // off 144, size 32
+        let _reserved = take(32)?;
+
+        // off 176, size 32
+        let mr_signer = <[u8; 32]>::try_from(take(32)?).ok()?;
+
+        // off 208, size 96
+        let _reserved = take(96)?;
+
+        // off 304, size 2
+        let isv_prod_id = u16::from_le_bytes(<[u8; 2]>::try_from(take(2)?).ok()?);
+
+        // off 306, size 2
+        let isv_svn = u16::from_le_bytes(<[u8; 2]>::try_from(take(2)?).ok()?);
+
+        // off 308, size 60
+        let _reserved = take(60)?;
+
+        // off 368, size 64
+        let mut report_data = [0u8; 64];
+        let _report_data = take(64)?;
+        let mut _it = _report_data.iter();
+        for i in report_data.iter_mut() {
+            *i = *_it.next()?;
+        }
+
+        if pos != bytes.len() {
+            return None;
+        }
+
+        Some(Self {
+            version,
+            signature_type,
+            gid,
+            isv_svn_qe,
+            isv_svn_pce,
+            qe_vendor_id,
+            user_data,
+            report_body: SgxReport {
+                cpu_svn,
+                misc_select,
+                attributes,
+                mr_enclave,
+                mr_signer,
+                isv_prod_id,
+                isv_svn,
+                report_data,
+            },
+        })
+    }
+}
+
+pub struct SgxQuote {
+    pub freshness: Duration,
+    pub status: SgxQuoteStatus,
+    pub body: SgxQuoteBody,
+}
+
+impl SgxQuote {
+    pub fn extract_verified_quote(cert_der: &[u8], ias_report_ca_cert: &[u8]) -> Result<SgxQuote> {
+        // Before we reach here, Webpki already verifed the cert is properly signed
+        use super::cert::*;
+
+        let x509 = yasna::parse_der(cert_der, |reader| X509::load(reader))
+            .map_err(|_| CertVerificationError::InvalidCertFormat)?;
+
+        let tbs_cert: <TbsCert as Asn1Ty>::ValueTy = x509.0;
+
+        let pub_key: <PubKey as Asn1Ty>::ValueTy = ((((((tbs_cert.1).1).1).1).1).1).0;
+        let pub_k = (pub_key.1).0;
+
+        let sgx_ra_cert_ext: <SgxRaCertExt as Asn1Ty>::ValueTy =
+            (((((((tbs_cert.1).1).1).1).1).1).1).0;
+
+        let payload: Vec<u8> = ((sgx_ra_cert_ext.0).1).0;
+
+        // Extract each field
+        let mut iter = payload.split(|x| *x == 0x7C);
+        let attn_report_raw = iter
+            .next()
+            .ok_or_else(|| Error::new(CertVerificationError::InvalidCertFormat))?;
+        let sig_raw = iter
+            .next()
+            .ok_or_else(|| Error::new(CertVerificationError::InvalidCertFormat))?;
+        let sig = base64::decode(&sig_raw)?;
+        let sig_cert_raw = iter
+            .next()
+            .ok_or_else(|| Error::new(CertVerificationError::InvalidCertFormat))?;
+        let sig_cert_dec = base64::decode_config(&sig_cert_raw, base64::STANDARD)?;
+
+        let sig_cert = webpki::EndEntityCert::from(&sig_cert_dec)
+            .map_err(|_| CertVerificationError::InvalidCertFormat)?;
+
+        // Verify if the signing cert is issued by Intel CA
+        let mut ias_ca_stripped = ias_report_ca_cert.to_vec();
+        ias_ca_stripped.retain(|&x| x != 0x0d && x != 0x0a);
+        let head_len = "-----BEGIN CERTIFICATE-----".len();
+        let tail_len = "-----END CERTIFICATE-----".len();
+        let full_len = ias_ca_stripped.len();
+        let ias_ca_core: &[u8] = &ias_ca_stripped[head_len..full_len - tail_len];
+        let ias_cert_dec = base64::decode_config(ias_ca_core, base64::STANDARD)
+            .map_err(|_| CertVerificationError::InvalidCertFormat)?;
+
+        let mut ca_reader = BufReader::new(&ias_report_ca_cert[..]);
+
+        let mut root_store = rustls::RootCertStore::empty();
+        root_store
+            .add_pem_file(&mut ca_reader)
+            .expect("Failed to add CA");
+
+        let trust_anchors: Vec<webpki::TrustAnchor> = root_store
+            .roots
+            .iter()
+            .map(|cert| cert.to_trust_anchor())
+            .collect();
+
+        let chain: Vec<&[u8]> = vec![&ias_cert_dec];
+
+        let now_func = webpki::Time::try_from(SystemTime::now())
+            .map_err(|_| CertVerificationError::WebpkiFailure)?;
+
+        sig_cert
+            .verify_is_valid_tls_server_cert(
+                SUPPORTED_SIG_ALGS,
+                &webpki::TLSServerTrustAnchors(&trust_anchors),
+                &chain,
+                now_func,
+            )
+            .map_err(|_| CertVerificationError::WebpkiFailure)?;
+
+        // Verify the signature against the signing cert
+        sig_cert
+            .verify_signature(&webpki::RSA_PKCS1_2048_8192_SHA256, &attn_report_raw, &sig)
+            .map_err(|_| CertVerificationError::WebpkiFailure)?;
+
+        // Verify attestation report
+        let attn_report: Value = serde_json::from_slice(attn_report_raw)
+            .map_err(|_| CertVerificationError::BadAttnReport)?;
+
+        // 1. Check timestamp is within 24H (90day is recommended by Intel)
+        let quote_freshness = {
+            let time = attn_report["timestamp"]
+                .as_str()
+                .ok_or_else(|| Error::new(CertVerificationError::BadAttnReport))?;
+            let time_fixed = String::from(time) + "+0000";
+            let date_time = DateTime::parse_from_str(&time_fixed, "%Y-%m-%dT%H:%M:%S%.f%z")?;
+            let ts = date_time.naive_utc();
+            let now = DateTime::<chrono::offset::Utc>::from(SystemTime::now()).naive_utc();
+            u64::try_from((now - ts).num_seconds())?
+        };
+
+        // 2. Get quote status
+        let quote_status = {
+            let status_string = attn_report["isvEnclaveQuoteStatus"]
+                .as_str()
+                .ok_or_else(|| Error::new(CertVerificationError::BadAttnReport))?;
+
+            SgxQuoteStatus::from(status_string)
+        };
+
+        // 3. Get quote body
+        let quote_body = {
+            let quote_encoded = attn_report["isvEnclaveQuoteBody"]
+                .as_str()
+                .ok_or_else(|| Error::new(CertVerificationError::BadAttnReport))?;
+            let quote_raw = base64::decode(&(quote_encoded.as_bytes()))?;
+            SgxQuoteBody::parse_from(quote_raw.as_slice())
+                .ok_or_else(|| Error::new(CertVerificationError::BadAttnReport))?
+        };
+
+        let raw_pub_k = pub_k.to_bytes();
+
+        // According to RFC 5480 `Elliptic Curve Cryptography Subject Public Key Information',
+        // SEC 2.2:
+        // ``The first octet of the OCTET STRING indicates whether the key is
+        // compressed or uncompressed.  The uncompressed form is indicated
+        // by 0x04 and the compressed form is indicated by either 0x02 or
+        // 0x03 (see 2.3.3 in [SEC1]).  The public key MUST be rejected if
+        // any other value is included in the first octet.''
+        //
+        // We only accept the uncompressed form here.
+        let is_uncompressed = raw_pub_k[0] == 4;
+        let pub_k = &raw_pub_k.as_slice()[1..];
+        if !is_uncompressed || pub_k != &quote_body.report_body.report_data[..] {
+            return Err(Error::new(CertVerificationError::BadAttnReport));
+        }
+
+        Ok(SgxQuote {
+            freshness: std::time::Duration::from_secs(quote_freshness),
+            status: quote_status,
+            body: quote_body,
+        })
+    }
+}
diff --git a/trusted-mesatee-sdk/teaclave_attestation/src/report.rs b/trusted-mesatee-sdk/teaclave_attestation/src/report.rs
new file mode 100644
index 0000000..ec59f41
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_attestation/src/report.rs
@@ -0,0 +1,199 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+use crate::ias::IasClient;
+use crate::AttestationError;
+use anyhow::Error;
+use anyhow::Result;
+use log::debug;
+use sgx_rand::os::SgxRng;
+use sgx_rand::Rng;
+use sgx_tcrypto::rsgx_sha256_slice;
+use sgx_tse::{rsgx_create_report, rsgx_verify_report};
+use sgx_types::sgx_ec256_public_t;
+use sgx_types::*;
+use std::prelude::v1::*;
+use teaclave_utils;
+
+extern "C" {
+    fn occlum_ocall_sgx_init_quote(
+        p_retval: *mut sgx_status_t,
+        p_target_info: *mut sgx_target_info_t,
+        p_gid: *mut sgx_epid_group_id_t,
+    ) -> sgx_status_t;
+
+    fn occlum_ocall_sgx_calc_quote_size(
+        p_retval: *mut sgx_status_t,
+        p_sig_rl: *const u8,
+        sig_rl_size: u32,
+        p_quote_size: *mut u32,
+    ) -> sgx_status_t;
+
+    fn occlum_ocall_sgx_get_quote(
+        p_retval: *mut sgx_status_t,
+        p_sig_rl: *const u8,
+        sig_rl_size: u32,
+        p_report: *const sgx_report_t,
+        quote_type: sgx_quote_sign_type_t,
+        p_spid: *const sgx_spid_t,
+        p_nonce: *const sgx_quote_nonce_t,
+        p_qe_report: *mut sgx_report_t,
+        p_quote: *mut u8,
+        quote_size: u32,
+    ) -> sgx_status_t;
+}
+
+#[derive(Default)]
+pub struct IasReport {
+    pub report: String,
+    pub signature: String,
+    pub signing_cert: String,
+}
+
+impl IasReport {
+    pub fn new(
+        pub_k: sgx_ec256_public_t,
+        ias_key: &str,
+        ias_spid: &str,
+        production: bool,
+    ) -> Result<Self> {
+        let (target_info, epid_group_id) = Self::init_quote()?;
+        let mut ias_client = IasClient::new(ias_key, production);
+        let sigrl = ias_client.get_sigrl(u32::from_le_bytes(epid_group_id))?;
+        let report = Self::create_report(pub_k, target_info)?;
+        let quote = Self::get_quote(&sigrl, report, target_info, ias_spid)?;
+        let report = ias_client.get_report(&quote)?;
+        Ok(report)
+    }
+
+    fn init_quote() -> Result<(sgx_target_info_t, sgx_epid_group_id_t)> {
+        debug!("init_quote");
+        let mut ti: sgx_target_info_t = sgx_target_info_t::default();
+        let mut eg: sgx_epid_group_id_t = sgx_epid_group_id_t::default();
+        let mut rt: sgx_status_t = sgx_status_t::SGX_ERROR_UNEXPECTED;
+
+        let res = unsafe { occlum_ocall_sgx_init_quote(&mut rt as _, &mut ti as _, &mut eg as _) };
+
+        if res != sgx_status_t::SGX_SUCCESS || rt != sgx_status_t::SGX_SUCCESS {
+            Err(Error::new(AttestationError::OCallError))
+        } else {
+            Ok((ti, eg))
+        }
+    }
+
+    fn create_report(
+        pub_k: sgx_ec256_public_t,
+        target_info: sgx_target_info_t,
+    ) -> Result<sgx_report_t> {
+        debug!("create_report");
+        let mut report_data: sgx_report_data_t = sgx_report_data_t::default();
+        let mut pub_k_gx = pub_k.gx;
+        pub_k_gx.reverse();
+        let mut pub_k_gy = pub_k.gy;
+        pub_k_gy.reverse();
+        report_data.d[..32].clone_from_slice(&pub_k_gx);
+        report_data.d[32..].clone_from_slice(&pub_k_gy);
+
+        rsgx_create_report(&target_info, &report_data)
+            .map_err(|_| Error::new(AttestationError::IasError))
+    }
+
+    fn get_quote(
+        sigrl: &[u8],
+        report: sgx_report_t,
+        target_info: sgx_target_info_t,
+        ias_spid: &str,
+    ) -> Result<Vec<u8>> {
+        let mut rt: sgx_status_t = sgx_status_t::SGX_ERROR_UNEXPECTED;
+        let (p_sigrl, sigrl_len) = if sigrl.is_empty() {
+            (std::ptr::null(), 0)
+        } else {
+            (sigrl.as_ptr(), sigrl.len() as u32)
+        };
+        let mut quote_len: u32 = 0;
+
+        let res = unsafe {
+            occlum_ocall_sgx_calc_quote_size(&mut rt as _, p_sigrl, sigrl_len, &mut quote_len as _)
+        };
+
+        if res != sgx_status_t::SGX_SUCCESS || rt != sgx_status_t::SGX_SUCCESS {
+            return Err(Error::new(AttestationError::OCallError));
+        }
+
+        let mut quote_nonce = sgx_quote_nonce_t { rand: [0; 16] };
+        let mut os_rng = SgxRng::new()?;
+        os_rng.fill_bytes(&mut quote_nonce.rand);
+        let mut qe_report = sgx_report_t::default();
+
+        let quote_type = sgx_quote_sign_type_t::SGX_LINKABLE_SIGNATURE;
+        let spid: sgx_spid_t = teaclave_utils::decode_spid(ias_spid)?;
+
+        let mut quote = vec![0; quote_len as usize];
+
+        debug!("ocall_sgx_get_quote");
+        let res = unsafe {
+            occlum_ocall_sgx_get_quote(
+                &mut rt as _,
+                p_sigrl,
+                sigrl_len,
+                &report as _,
+                quote_type,
+                &spid as _,
+                &quote_nonce as _,
+                &mut qe_report as _,
+                quote.as_mut_ptr(),
+                quote_len,
+            )
+        };
+
+        if res != sgx_status_t::SGX_SUCCESS || rt != sgx_status_t::SGX_SUCCESS {
+            return Err(Error::new(AttestationError::OCallError));
+        }
+
+        debug!("rsgx_verify_report");
+        // Perform a check on qe_report to verify if the qe_report is valid.
+        rsgx_verify_report(&qe_report).map_err(|_| Error::new(AttestationError::IasError))?;
+
+        // Check if the qe_report is produced on the same platform.
+        if target_info.mr_enclave.m != qe_report.body.mr_enclave.m
+            || target_info.attributes.flags != qe_report.body.attributes.flags
+            || target_info.attributes.xfrm != qe_report.body.attributes.xfrm
+        {
+            return Err(Error::new(AttestationError::QuoteError));
+        }
+
+        // Check qe_report to defend against replay attack. The purpose of
+        // p_qe_report is for the ISV enclave to confirm the QUOTE it received
+        // is not modified by the untrusted SW stack, and not a replay. The
+        // implementation in QE is to generate a REPORT targeting the ISV
+        // enclave (target info from p_report) , with the lower 32Bytes in
+        // report.data = SHA256(p_nonce||p_quote). The ISV enclave can verify
+        // the p_qe_report and report.data to confirm the QUOTE has not be
+        // modified and is not a replay. It is optional.
+        let mut rhs_vec: Vec<u8> = quote_nonce.rand.to_vec();
+        rhs_vec.extend(&quote);
+        debug!("rsgx_sha256_slice");
+        let rhs_hash =
+            rsgx_sha256_slice(&rhs_vec).map_err(|_| Error::new(AttestationError::IasError))?;
+        let lhs_hash = &qe_report.body.report_data.d[..32];
+        if rhs_hash != lhs_hash {
+            return Err(Error::new(AttestationError::QuoteError));
+        }
+
+        Ok(quote)
+    }
+}
diff --git a/trusted-mesatee-sdk/teaclave_attestation/src/verifier.rs b/trusted-mesatee-sdk/teaclave_attestation/src/verifier.rs
new file mode 100644
index 0000000..591dfa4
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_attestation/src/verifier.rs
@@ -0,0 +1,153 @@
+// Licensed to the Apache Software Foundation (ASF) under one
+// or more contributor license agreements.  See the NOTICE file
+// distributed with this work for additional information
+// regarding copyright ownership.  The ASF licenses this file
+// to you under the Apache License, Version 2.0 (the
+// "License"); you may not use this file except in compliance
+// with the License.  You may obtain a copy of the License at
+//
+//   http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing,
+// software distributed under the License is distributed on an
+// "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
+// KIND, either express or implied.  See the License for the
+// specific language governing permissions and limitations
+// under the License.
+
+use crate::quote::SgxQuote;
+use std::hash::{Hash, Hasher};
+use std::vec::Vec;
+use teaclave_config::build_config::BUILD_CONFIG;
+use teaclave_utils::EnclaveMeasurement;
+
+#[derive(Clone)]
+pub struct EnclaveAttr {
+    pub measures: Vec<EnclaveMeasurement>,
+}
+
+impl PartialEq for EnclaveAttr {
+    fn eq(&self, other: &EnclaveAttr) -> bool {
+        self.measures == other.measures
+    }
+}
+
+impl Hash for EnclaveAttr {
+    fn hash<H: Hasher>(&self, state: &mut H) {
+        for m in &self.measures {
+            m.mr_enclave.hash(state);
+            m.mr_signer.hash(state);
+        }
+    }
+}
+
+#[derive(Clone)]
+pub struct SgxQuoteVerifier {
+    pub enclave_attr: EnclaveAttr,
+    pub verifier: fn(&SgxQuote) -> bool,
+}
+
+impl PartialEq for SgxQuoteVerifier {
+    fn eq(&self, other: &SgxQuoteVerifier) -> bool {
+        self.verifier as usize == other.verifier as usize && self.enclave_attr == other.enclave_attr
+    }
+}
+
+impl Eq for SgxQuoteVerifier {}
+
+impl Hash for SgxQuoteVerifier {
+    fn hash<H: Hasher>(&self, state: &mut H) {
+        self.enclave_attr.hash(state);
+        (self.verifier as usize).hash(state);
+    }
+}
+
+fn universal_quote_verifier(quote: &SgxQuote) -> bool {
+    quote.status != crate::quote::SgxQuoteStatus::UnknownBadStatus
+}
+
+impl SgxQuoteVerifier {
+    pub fn new(enclave_attr: EnclaveAttr) -> Self {
+        Self {
+            enclave_attr,
+            verifier: universal_quote_verifier,
+        }
+    }
+
+    fn verify_measures(&self, quote: &SgxQuote) -> bool {
+        let this_mr_signer = quote.body.report_body.mr_signer;
+        let this_mr_enclave = quote.body.report_body.mr_enclave;
+
+        self.enclave_attr
+            .measures
+            .iter()
+            .any(|m| m.mr_signer == this_mr_signer && m.mr_enclave == this_mr_enclave)
+    }
+
+    fn verify_cert(&self, cert_der: &[u8]) -> bool {
+        if cfg!(sgx_sim) {
+            return true;
+        }
+
+        let quote = match SgxQuote::extract_verified_quote(&cert_der, BUILD_CONFIG.ias_root_ca_cert)
+        {
+            Ok(quote) => quote,
+            Err(_) => {
+                return false;
+            }
+        };
+
+        // Enclave measures are not tested in test mode since we have
+        // a dedicated test enclave not known to production enclaves
+        if cfg!(test_mode) {
+            return (self.verifier)(&quote);
+        }
+
+        self.verify_measures(&quote) && (self.verifier)(&quote)
+    }
+}
+
+impl rustls::ServerCertVerifier for SgxQuoteVerifier {
+    fn verify_server_cert(
+        &self,
+        _roots: &rustls::RootCertStore,
+        certs: &[rustls::Certificate],
+        _hostname: webpki::DNSNameRef,
+        _ocsp: &[u8],
+    ) -> std::result::Result<rustls::ServerCertVerified, rustls::TLSError> {
+        // This call automatically verifies certificate signature
+        if certs.len() != 1 {
+            return Err(rustls::TLSError::NoCertificatesPresented);
+        }
+        if self.verify_cert(&certs[0].0) {
+            Ok(rustls::ServerCertVerified::assertion())
+        } else {
+            Err(rustls::TLSError::WebPKIError(
+                webpki::Error::ExtensionValueInvalid,
+            ))
+        }
+    }
+}
+
+impl rustls::ClientCertVerifier for SgxQuoteVerifier {
+    fn client_auth_root_subjects(&self) -> rustls::DistinguishedNames {
+        rustls::DistinguishedNames::new()
+    }
+
+    fn verify_client_cert(
+        &self,
+        certs: &[rustls::Certificate],
+    ) -> std::result::Result<rustls::ClientCertVerified, rustls::TLSError> {
+        // This call automatically verifies certificate signature
+        if certs.len() != 1 {
+            return Err(rustls::TLSError::NoCertificatesPresented);
+        }
+        if self.verify_cert(&certs[0].0) {
+            Ok(rustls::ClientCertVerified::assertion())
+        } else {
+            Err(rustls::TLSError::WebPKIError(
+                webpki::Error::ExtensionValueInvalid,
+            ))
+        }
+    }
+}
diff --git a/trusted-mesatee-sdk/teaclave_config/Cargo.lock b/trusted-mesatee-sdk/teaclave_config/Cargo.lock
new file mode 100644
index 0000000..84908df
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_config/Cargo.lock
@@ -0,0 +1,242 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+[[package]]
+name = "cc"
+version = "1.0.50"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "cfg-if"
+version = "0.1.10"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "lazy_static"
+version = "1.4.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "spin 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "log"
+version = "0.4.10"
+source = "git+https://github.com/mesalock-linux/log-sgx#1f02c0fffc360b9efb6cd319f402c4a2b28d96e7"
+dependencies = [
+ "cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_tstd 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "proc-macro2"
+version = "1.0.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "quote"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "proc-macro2 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "serde"
+version = "1.0.104"
+source = "git+https://github.com/mesalock-linux/serde-sgx#c945ac9aeb23dc799070f3afaf590a6c3ac2c1a2"
+dependencies = [
+ "sgx_tstd 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "serde"
+version = "1.0.104"
+dependencies = [
+ "sgx_tstd 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "serde_derive"
+version = "1.0.104"
+dependencies = [
+ "proc-macro2 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quote 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "syn 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "sgx_alloc"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+
+[[package]]
+name = "sgx_backtrace_sys"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "cc 1.0.50 (registry+https://github.com/rust-lang/crates.io-index)",
+ "sgx_build_helper 0.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_libc 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_build_helper"
+version = "0.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+
+[[package]]
+name = "sgx_demangle"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+
+[[package]]
+name = "sgx_libc"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_tcrypto"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_tprotected_fs"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "sgx_trts 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_trts"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "sgx_libc 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_tse"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_tseal"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "sgx_tcrypto 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_trts 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_tse 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_tstd"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "sgx_alloc 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_backtrace_sys 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_demangle 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_libc 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_tprotected_fs 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_trts 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_tseal 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "sgx_unwind 0.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "sgx_types"
+version = "1.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+
+[[package]]
+name = "sgx_unwind"
+version = "0.1.0"
+source = "git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0#71a88b647bb76a16cbc5c3e29403e2afb67f82fd"
+dependencies = [
+ "sgx_build_helper 0.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "spin"
+version = "0.5.2"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "syn"
+version = "1.0.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "proc-macro2 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quote 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "teaclave_config"
+version = "0.1.0"
+dependencies = [
+ "lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)",
+ "log 0.4.10 (git+https://github.com/mesalock-linux/log-sgx)",
+ "serde 1.0.104",
+ "serde_derive 1.0.104",
+ "sgx_tstd 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+ "toml 0.5.3 (git+https://github.com/mesalock-linux/toml-rs-sgx?tag=sgx_1.1.0)",
+]
+
+[[package]]
+name = "toml"
+version = "0.5.3"
+source = "git+https://github.com/mesalock-linux/toml-rs-sgx?tag=sgx_1.1.0#75cbb996001545c56e8cbbb0240a92ca91ca71e2"
+dependencies = [
+ "serde 1.0.104 (git+https://github.com/mesalock-linux/serde-sgx)",
+ "sgx_tstd 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)",
+]
+
+[[package]]
+name = "unicode-xid"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[metadata]
+"checksum cc 1.0.50 (registry+https://github.com/rust-lang/crates.io-index)" = "95e28fa049fda1c330bcf9d723be7663a899c4679724b34c81e9f5a326aab8cd"
+"checksum cfg-if 0.1.10 (registry+https://github.com/rust-lang/crates.io-index)" = "4785bdd1c96b2a846b2bd7cc02e86b6b3dbf14e7e53446c4f54c92a361040822"
+"checksum lazy_static 1.4.0 (registry+https://github.com/rust-lang/crates.io-index)" = "e2abad23fbc42b3700f2f279844dc832adb2b2eb069b2df918f455c4e18cc646"
+"checksum log 0.4.10 (git+https://github.com/mesalock-linux/log-sgx)" = "<none>"
+"checksum proc-macro2 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)" = "6c09721c6781493a2a492a96b5a5bf19b65917fe6728884e7c44dd0c60ca3435"
+"checksum quote 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)" = "2bdc6c187c65bca4260c9011c9e3132efe4909da44726bad24cf7572ae338d7f"
+"checksum serde 1.0.104 (git+https://github.com/mesalock-linux/serde-sgx)" = "<none>"
+"checksum sgx_alloc 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_backtrace_sys 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_build_helper 0.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_demangle 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_libc 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_tcrypto 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_tprotected_fs 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_trts 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_tse 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_tseal 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_tstd 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_types 1.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum sgx_unwind 0.1.0 (git+https://github.com/apache/teaclave-sgx-sdk?rev=v1.1.0)" = "<none>"
+"checksum spin 0.5.2 (registry+https://github.com/rust-lang/crates.io-index)" = "6e63cff320ae2c57904679ba7cb63280a3dc4613885beafb148ee7bf9aa9042d"
+"checksum syn 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)" = "0df0eb663f387145cab623dea85b09c2c5b4b0aef44e945d928e682fce71bb03"
+"checksum toml 0.5.3 (git+https://github.com/mesalock-linux/toml-rs-sgx?tag=sgx_1.1.0)" = "<none>"
+"checksum unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c"
diff --git a/trusted-mesatee-sdk/teaclave_config/Cargo.toml b/trusted-mesatee-sdk/teaclave_config/Cargo.toml
new file mode 100644
index 0000000..71346a4
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_config/Cargo.toml
@@ -0,0 +1,24 @@
+[package]
+name = "teaclave_config"
+version = "0.1.0"
+authors = ["MesaTEE Authors <developers@mesatee.org>"]
+description = "Build and runtime configurations."
+license = "Apache-2.0"
+edition = "2018"
+
+[features]
+default = []
+mesalock_sgx = ["sgx_tstd"]
+
+[dependencies]
+lazy_static = { version = "1.0.2", features = ["spin_no_std"] }
+#serde = "1.0.93"
+#serde_derive = "1.0.93"
+#sgx_tstd  = { version = "1.1.0", optional = true }
+#toml = "0.5.1"
+#log          = { version = "0.4.6" }
+serde_derive    = { git = "https://github.com/mesalock-linux/serde-sgx" }
+serde           = { git = "https://github.com/mesalock-linux/serde-sgx", features = ["derive"] }
+sgx_tstd        = { rev = "v1.1.2", git = "https://github.com/apache/teaclave-sgx-sdk.git", optional = true  }
+toml            = { git = "https://github.com/mesalock-linux/toml-rs-sgx" }
+log             = { git = "https://github.com/mesalock-linux/log-sgx" }
diff --git a/trusted-mesatee-sdk/teaclave_config/build.config.toml b/trusted-mesatee-sdk/teaclave_config/build.config.toml
new file mode 100644
index 0000000..de6a585
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_config/build.config.toml
@@ -0,0 +1,14 @@
+# Teaclave Build Config
+
+# Intel Attestation Service root CA certificate to verify attestation report
+ias_root_ca_cert = { path = "../keys/ias_root_ca_cert.pem" }
+
+# Auditors' public keys to verify their endorsement signatures
+auditor_public_keys = [
+    { path = "../keys/auditors/godzilla/godzilla.public.der" },
+    { path = "../keys/auditors/optimus_prime/optimus_prime.public.der" },
+    { path = "../keys/auditors/albus_dumbledore/albus_dumbledore.public.der"},
+]
+
+# RPC max message size
+rpc_max_message_size = 409600
diff --git a/trusted-mesatee-sdk/teaclave_config/build.rs b/trusted-mesatee-sdk/teaclave_config/build.rs
new file mode 100644
index 0000000..3692645
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_config/build.rs
@@ -0,0 +1,35 @@
+use std::env;
+use std::path::Path;
+use std::process::Command;
+use std::str;
+
+fn main() {
+    let is_sim = env::var("SGX_MODE").unwrap_or_else(|_| "HW".to_string());
+    match is_sim.as_ref() {
+        "HW" => {}
+        _ => println!("cargo:rustc-cfg=sgx_sim"),
+    }
+
+    let out_dir = env::var("OUT_DIR").expect("$OUT_DIR not set. Please build with cargo");
+    let dest_file = Path::new(&out_dir).join("build_config.rs");
+    println!("cargo:rerun-if-changed=build.config.toml");
+    println!("cargo:rerun-if-changed=build.rs");
+    let c = Command::new("cargo")
+        .args(&[
+            "run",
+            "--manifest-path",
+            "config_gen/Cargo.toml",
+            "--",
+            "build.config.toml",
+            &dest_file.to_string_lossy(),
+        ])
+        .output()
+        .expect("Cannot generate build_config.rs");
+    if !c.status.success() {
+        panic!(
+            "stdout: {:?}, stderr: {:?}",
+            str::from_utf8(&c.stderr).unwrap(),
+            str::from_utf8(&c.stderr).unwrap()
+        );
+    }
+}
diff --git a/trusted-mesatee-sdk/teaclave_config/config_gen/Cargo.lock b/trusted-mesatee-sdk/teaclave_config/config_gen/Cargo.lock
new file mode 100644
index 0000000..fd0960f
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_config/config_gen/Cargo.lock
@@ -0,0 +1,73 @@
+# This file is automatically @generated by Cargo.
+# It is not intended for manual editing.
+[[package]]
+name = "config_gen"
+version = "0.1.0"
+dependencies = [
+ "serde 1.0.105 (registry+https://github.com/rust-lang/crates.io-index)",
+ "serde_derive 1.0.105 (registry+https://github.com/rust-lang/crates.io-index)",
+ "toml 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "proc-macro2"
+version = "1.0.9"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "quote"
+version = "1.0.3"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "proc-macro2 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "serde"
+version = "1.0.105"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[[package]]
+name = "serde_derive"
+version = "1.0.105"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "proc-macro2 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quote 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "syn 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "syn"
+version = "1.0.17"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "proc-macro2 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)",
+ "quote 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)",
+ "unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "toml"
+version = "0.5.6"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+dependencies = [
+ "serde 1.0.105 (registry+https://github.com/rust-lang/crates.io-index)",
+]
+
+[[package]]
+name = "unicode-xid"
+version = "0.2.0"
+source = "registry+https://github.com/rust-lang/crates.io-index"
+
+[metadata]
+"checksum proc-macro2 1.0.9 (registry+https://github.com/rust-lang/crates.io-index)" = "6c09721c6781493a2a492a96b5a5bf19b65917fe6728884e7c44dd0c60ca3435"
+"checksum quote 1.0.3 (registry+https://github.com/rust-lang/crates.io-index)" = "2bdc6c187c65bca4260c9011c9e3132efe4909da44726bad24cf7572ae338d7f"
+"checksum serde 1.0.105 (registry+https://github.com/rust-lang/crates.io-index)" = "e707fbbf255b8fc8c3b99abb91e7257a622caeb20a9818cbadbeeede4e0932ff"
+"checksum serde_derive 1.0.105 (registry+https://github.com/rust-lang/crates.io-index)" = "ac5d00fc561ba2724df6758a17de23df5914f20e41cb00f94d5b7ae42fffaff8"
+"checksum syn 1.0.17 (registry+https://github.com/rust-lang/crates.io-index)" = "0df0eb663f387145cab623dea85b09c2c5b4b0aef44e945d928e682fce71bb03"
+"checksum toml 0.5.6 (registry+https://github.com/rust-lang/crates.io-index)" = "ffc92d160b1eef40665be3a05630d003936a3bc7da7421277846c2613e92c71a"
+"checksum unicode-xid 0.2.0 (registry+https://github.com/rust-lang/crates.io-index)" = "826e7639553986605ec5979c7dd957c7895e93eabed50ab2ffa7f6128a75097c"
diff --git a/trusted-mesatee-sdk/teaclave_config/config_gen/Cargo.toml b/trusted-mesatee-sdk/teaclave_config/config_gen/Cargo.toml
new file mode 100644
index 0000000..406bc3a
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_config/config_gen/Cargo.toml
@@ -0,0 +1,16 @@
+[package]
+name = "config_gen"
+version = "0.1.0"
+authors = ["MesaTEE Authors <developers@mesatee.org>"]
+description = "Generating build config."
+license = "Apache-2.0"
+edition = "2018"
+
+[[bin]]
+name = "config_gen"
+path = "main.rs"
+
+[dependencies]
+serde = "1.0.92"
+serde_derive = "1.0.92"
+toml = "0.5.1"
diff --git a/trusted-mesatee-sdk/teaclave_config/config_gen/main.rs b/trusted-mesatee-sdk/teaclave_config/config_gen/main.rs
new file mode 100644
index 0000000..82ce9c9
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_config/config_gen/main.rs
@@ -0,0 +1,83 @@
+use serde_derive::Deserialize;
+use serde_derive::Serialize;
+use std::env;
+use std::fs;
+use std::fs::File;
+use std::io::Write;
+use std::path::Path;
+use std::path::PathBuf;
+
+#[derive(Serialize, Deserialize)]
+struct BuildConfigToml {
+    ias_root_ca_cert: ConfigSource,
+    auditor_public_keys: Vec<ConfigSource>,
+    rpc_max_message_size: u32,
+}
+
+#[derive(Debug, Serialize, Deserialize)]
+#[serde(rename_all(serialize = "snake_case", deserialize = "snake_case"))]
+enum ConfigSource {
+    Path(PathBuf),
+}
+
+fn display_config_source(config: &ConfigSource) -> String {
+    match config {
+        ConfigSource::Path(p) => {
+            let content = &fs::read(p).expect(&format!("Failed to read file: {}", p.display()));
+            let mut output = String::new();
+            output.push_str("&[");
+            for b in content {
+                output.push_str(&format!("{}, ", b));
+            }
+            output.push_str("]");
+
+            output
+        }
+    }
+}
+
+fn main() {
+    let args: Vec<String> = env::args().collect();
+    if args.len() < 3 {
+        panic!("Please specify the path of build config toml and output path.");
+    }
+    let contents = fs::read_to_string(&args[1]).expect("Something went wrong reading the file");
+    let config: BuildConfigToml = toml::from_str(&contents).expect("Failed to parse the config.");
+
+    let ias_root_ca_cert = display_config_source(&config.ias_root_ca_cert);
+
+    let mut auditor_public_keys = String::new();
+    auditor_public_keys.push_str("&[");
+    for key in &config.auditor_public_keys {
+        let auditor_pulic_key = display_config_source(key);
+        auditor_public_keys.push_str(&format!("{}, ", auditor_pulic_key));
+    }
+    auditor_public_keys.push_str("]");
+
+    let mut build_config_generated = String::new();
+    build_config_generated.push_str(&format!(
+        r#"
+    #[derive(Debug)]
+    pub struct BuildConfig<'a> {{
+        pub ias_root_ca_cert: &'a [u8],
+        pub auditor_public_keys: &'a [&'a [u8];{}],
+        pub rpc_max_message_size: u64,
+    }}
+
+    pub static BUILD_CONFIG: BuildConfig<'static> = BuildConfig {{
+        ias_root_ca_cert: {},
+        auditor_public_keys: {},
+        rpc_max_message_size: {},
+    }};"#,
+        config.auditor_public_keys.len(),
+        ias_root_ca_cert,
+        auditor_public_keys,
+        config.rpc_max_message_size
+    ));
+
+    let dest_path = Path::new(&args[2]);
+    let mut f =
+        File::create(&dest_path).expect(&format!("Failed to create file: {}", dest_path.display()));
+    f.write_all(build_config_generated.as_bytes())
+        .expect(&format!("Failed to write file: {}", dest_path.display()));
+}
diff --git a/trusted-mesatee-sdk/teaclave_config/runtime.config.toml b/trusted-mesatee-sdk/teaclave_config/runtime.config.toml
new file mode 100644
index 0000000..528f343
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_config/runtime.config.toml
@@ -0,0 +1,36 @@
+# Teaclave Runtime Config
+#
+# Note that this config is loaded at running time. We don't have to trust the
+# content though. Maliciously crafted config from this file will not break data
+# confidentiality/integrity.
+#
+# Topology of Services
+#
+#      ┌───────────────────────────────────────────────────┐
+#      │                                                   │FNS API Endpoint
+#      │                                                   ▼
+#      │                                        ┌─────────────────────┐
+#      │                                        │Function Node Service│
+#      │          TMS Internal ┌────────────────│        (FNS)        │─┐
+#      │            Endpoint   │                └─────────────────────┘ │
+#      │                       ▼                           │            │
+# ┌────────┐       ┌───────────────────────┐               │            │  ┌──────────────────────┐
+# │  User  │       │Task Management Service│  ┌────────────┘            │  │Key Management Service│
+# │        │──────▶│         (TMS)         │  │                         ├─▶│        (KMS)         │
+# └────────┘       └───────────────────────┘  │                         │  └──────────────────────┘
+#      │   TMS API Endpoint    │              │  ┌───────────────────┐  │KMS Internal
+#      │                       │              │  │Trusted Distributed│  │  Endpoint
+#      │                       └──────────────┴─▶│    File System    │──┘
+#      │                            TDFS Internal│      (TDFS)       │
+#      │                              Endpoint   └───────────────────┘
+#      │                                                   ▲
+#      │                                                   │ TDFS API Endpoint
+#      └───────────────────────────────────────────────────┘
+
+[audit]
+enclave_info = { path = "enclave_info.toml" }
+auditor_signatures = [
+    { path = "auditors/godzilla/godzilla.sign.sha256" },
+    { path = "auditors/optimus_prime/optimus_prime.sign.sha256" },
+    { path = "auditors/albus_dumbledore/albus_dumbledore.sign.sha256" },
+]
diff --git a/trusted-mesatee-sdk/teaclave_config/src/lib.rs b/trusted-mesatee-sdk/teaclave_config/src/lib.rs
new file mode 100644
index 0000000..42d878c
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_config/src/lib.rs
@@ -0,0 +1,138 @@
+// Use sgx_tstd to replace Rust's default std
+#![cfg_attr(feature = "mesalock_sgx", no_std)]
+#[cfg(feature = "mesalock_sgx")]
+#[macro_use]
+extern crate sgx_tstd as std;
+#[macro_use]
+extern crate log;
+
+pub use runtime_config::ConfigSource;
+
+pub mod build_config {
+    #![allow(clippy::all)]
+    include!(concat!(env!("OUT_DIR"), "/build_config.rs"));
+}
+
+pub mod runtime_config {
+    #[cfg(not(feature = "mesalock_sgx"))]
+    use std::fs;
+    #[cfg(feature = "mesalock_sgx")]
+    use std::prelude::v1::*;
+    #[cfg(feature = "mesalock_sgx")]
+    use std::untrusted::fs;
+
+    use serde_derive::Deserialize;
+    use std::env;
+    use std::path::Path;
+    use std::path::PathBuf;
+    use std::string::String;
+    use std::vec::Vec;
+    use toml;
+
+    #[derive(Debug, Deserialize)]
+    pub struct RuntimeConfig {
+        pub audit: AuditConfig,
+        #[serde(skip_deserializing)]
+        pub env: EnvConfig,
+    }
+
+    #[derive(Debug, Deserialize)]
+    pub struct AuditConfig {
+        #[serde(rename(deserialize = "enclave_info"))]
+        enclave_info_source: ConfigSource,
+        #[serde(rename(deserialize = "auditor_signatures"))]
+        auditor_signatures_source: Vec<ConfigSource>,
+        #[serde(skip_deserializing)]
+        pub enclave_info: String,
+        #[serde(skip_deserializing)]
+        pub auditor_signatures: Vec<Vec<u8>>,
+    }
+
+    #[derive(Debug, Deserialize)]
+    #[serde(rename_all(deserialize = "snake_case"))]
+    pub enum ConfigSource {
+        Path(PathBuf),
+    }
+
+    #[derive(Debug, Default)]
+    pub struct EnvConfig {
+        pub ias_spid: String,
+        pub ias_key: String,
+    }
+
+    impl RuntimeConfig {
+        pub fn from_toml<T: AsRef<Path>>(path: T) -> Option<Self> {
+            use std::prelude::v1::*;
+            let contents = match fs::read_to_string(path) {
+                Ok(c) => c,
+                Err(_) => {
+                    error!("Something went wrong reading the runtime config file.");
+                    return None;
+                }
+            };
+            let mut config: RuntimeConfig = match toml::from_str(&contents) {
+                Ok(c) => c,
+                Err(_) => {
+                    error!("Something went wrong reading the runtime config file.");
+                    return None;
+                }
+            };
+
+            config.audit.enclave_info = match &config.audit.enclave_info_source {
+                ConfigSource::Path(ref enclave_info_path) => fs::read_to_string(enclave_info_path)
+                    .unwrap_or_else(|_| {
+                        panic!("Cannot find enclave info at {:?}.", enclave_info_path)
+                    }),
+            };
+
+            let mut signatures: Vec<Vec<u8>> = vec![];
+            for source in &config.audit.auditor_signatures_source {
+                let signature = match source {
+                    ConfigSource::Path(ref path) => fs::read(path)
+                        .unwrap_or_else(|_| panic!("Cannot find signature file {:?}.", path)),
+                };
+                signatures.push(signature);
+            }
+            config.audit.auditor_signatures = signatures;
+
+            if !cfg!(sgx_sim) {
+                let ias_spid = match env::var("IAS_SPID") {
+                    Ok(e) => e.trim().to_string(),
+                    Err(_) => {
+                        error!("Cannot find IAS_SPID from environment variables.");
+                        return None;
+                    }
+                };
+                let ias_key = match env::var("IAS_KEY") {
+                    Ok(e) => e.trim().to_string(),
+                    Err(_) => {
+                        error!("Cannot find IAS_KEY from environment variables.");
+                        return None;
+                    }
+                };
+                if ias_spid.len() != 32 || ias_key.len() != 32 {
+                    error!("IAS_SPID or IAS_KEY format error.");
+                    return None;
+                }
+
+                config.env = EnvConfig { ias_spid, ias_key };
+            }
+
+            Some(config)
+        }
+    }
+}
+
+#[cfg(test)]
+mod tests {
+    use super::*;
+
+    #[test]
+    fn test_runtime_config() {
+    }
+
+    #[test]
+    fn test_build_config() {
+        println!("{:?}", build_config::BUILD_CONFIG);
+    }
+}
diff --git a/trusted-mesatee-sdk/teaclave_utils/Cargo.toml b/trusted-mesatee-sdk/teaclave_utils/Cargo.toml
new file mode 100644
index 0000000..5ab8f6d
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_utils/Cargo.toml
@@ -0,0 +1,26 @@
+[package]
+name = "teaclave_utils"
+version = "0.1.0"
+authors = ["MesaTEE Authors <developers@mesatee.org>"]
+description = "MesaTEE utilities."
+license = "Apache-2.0"
+edition = "2018"
+
+[features]
+default = ["mesalock_sgx"]
+mesalock_sgx = ["sgx_tstd"]
+
+[dependencies]
+#ring         = { version = "0.16.5" }
+#serde        = { version = "1.0.105" }
+#serde_derive = { version = "1.0.105" }
+#sgx_tstd     = { version = "1.1.0", optional = true }
+#sgx_types    = { version = "1.1.0" }
+#toml         = { version = "0.5.3" }
+
+ring          = { git = "https://github.com/mesalock-linux/ring-sgx", tag = "v0.16.5" }
+sgx_tstd      = { rev = "v1.1.2", git = "https://github.com/apache/teaclave-sgx-sdk.git", optional = true }
+sgx_types     = { rev = "v1.1.2", git = "https://github.com/apache/teaclave-sgx-sdk.git"}
+serde_derive  = { git = "https://github.com/mesalock-linux/serde-sgx" }
+serde         = { git = "https://github.com/mesalock-linux/serde-sgx", features = ["derive"] }
+toml          = { git = "https://github.com/mesalock-linux/toml-rs-sgx" }
diff --git a/trusted-mesatee-sdk/teaclave_utils/src/lib.rs b/trusted-mesatee-sdk/teaclave_utils/src/lib.rs
new file mode 100644
index 0000000..8902f99
--- /dev/null
+++ b/trusted-mesatee-sdk/teaclave_utils/src/lib.rs
@@ -0,0 +1,163 @@
+#![cfg_attr(feature = "mesalock_sgx", no_std)]
+#[cfg(feature = "mesalock_sgx")]
+extern crate sgx_tstd as std;
+#[cfg(feature = "mesalock_sgx")]
+use std::prelude::v1::*;
+
+use serde::Deserializer;
+use serde_derive::Deserialize;
+
+use std::error::Error;
+use std::fmt;
+
+type Result<T> = std::result::Result<T, UtilsError>;
+use sgx_types::SGX_HASH_SIZE;
+
+pub type SgxMeasurement = [u8; SGX_HASH_SIZE];
+
+#[derive(Debug)]
+pub enum UtilsError {
+    ParseError,
+}
+
+impl fmt::Display for UtilsError {
+    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
+        write!(f, "Teaclave utils error")
+    }
+}
+
+impl Error for UtilsError {
+    fn description(&self) -> &str {
+        "Teaclave utils error"
+    }
+}
+
+fn decode_hex_digit(digit: char) -> Result<u8> {
+    match digit {
+        '0'..='9' => Ok(digit as u8 - b'0'),
+        'a'..='f' => Ok(digit as u8 - b'a' + 10),
+        'A'..='F' => Ok(digit as u8 - b'A' + 10),
+        _ => Err(UtilsError::ParseError),
+    }
+}
+
+fn decode_hex(hex: &str) -> Result<Vec<u8>> {
+    let mut r: Vec<u8> = Vec::new();
+    let mut chars = hex.chars().enumerate();
+    loop {
+        let (_, first) = match chars.next() {
+            None => break,
+            Some(elt) => elt,
+        };
+        if first == ' ' {
+            continue;
+        }
+        let (_, second) = chars.next().ok_or_else(|| UtilsError::ParseError)?;
+        r.push((decode_hex_digit(first)? << 4) | decode_hex_digit(second)?);
+    }
+    Ok(r)
+}
+
+pub fn decode_spid(hex: &str) -> Result<sgx_types::sgx_spid_t> {
+    let mut spid = sgx_types::sgx_spid_t::default();
+    let hex = hex.trim();
+
+    if hex.len() < 16 * 2 {
+        return Err(UtilsError::ParseError);
+    }
+
+    let decoded_vec = decode_hex(hex)?;
+
+    spid.id.copy_from_slice(&decoded_vec[..16]);
+
+    Ok(spid)
+}
+
+pub fn percent_decode(orig: &str) -> Result<String> {
+    let orig = orig.replace("%0A", "");
+    let v: Vec<&str> = orig.split('%').collect();
+    let mut ret = String::new();
+    ret.push_str(v[0]);
+    if v.len() > 1 {
+        for s in v[1..].iter() {
+            let digit = u8::from_str_radix(&s[0..2], 16).map_err(|_| UtilsError::ParseError)?;
+            ret.push(digit as char);
+            ret.push_str(&s[2..]);
+        }
+    }
+    Ok(ret)
+}
+
+/// Deserializes a hex string to a `SgxMeasurement` (i.e., [0; 32]).
+pub fn from_hex<'de, D>(deserializer: D) -> std::result::Result<SgxMeasurement, D::Error>
+where
+    D: Deserializer<'de>,
+{
+    use serde::de::Error;
+    use serde::Deserialize;
+    String::deserialize(deserializer).and_then(|string| {
+        let v = decode_hex(&string).map_err(|_| Error::custom("ParseError"))?;
+        let mut array = [0; SGX_HASH_SIZE];
+        let bytes = &v[..array.len()]; // panics if not enough data
+        array.copy_from_slice(bytes);
+        Ok(array)
+    })
+}
+
+#[derive(Debug, Deserialize)]
+#[serde(transparent)]
+struct EnclaveInfoToml(std::collections::HashMap<String, EnclaveMeasurement>);
+
+
+#[derive(Debug, Deserialize, Copy, Clone, Eq, PartialEq)]
+pub struct EnclaveMeasurement {
+    #[serde(deserialize_with = "from_hex")]
+    pub mr_signer: SgxMeasurement,
+    #[serde(deserialize_with = "from_hex")]
+    pub mr_enclave: SgxMeasurement,
+}
+
+impl EnclaveMeasurement {
+    pub fn new(mr_enclave: SgxMeasurement, mr_signer: SgxMeasurement) -> Self {
+        Self {
+            mr_enclave,
+            mr_signer,
+        }
+    }
+}
+
+pub fn verify_enclave_info<T, U>(enclave_info: &[u8], public_keys: &[T], signatures: &[U]) -> bool
+where
+    T: AsRef<[u8]>,
+    U: AsRef<[u8]>,
+{
+    use ring::signature;
+
+    for k in public_keys {
+        let mut verified = false;
+        for s in signatures {
+            if signature::UnparsedPublicKey::new(&signature::RSA_PKCS1_2048_8192_SHA256, k)
+                .verify(enclave_info, s.as_ref())
+                .is_ok()
+            {
+                verified = true;
+            }
+        }
+        if !verified {
+            return false;
+        }
+    }
+
+    true
+}
+
+pub fn load_enclave_info(content: &str) -> std::collections::HashMap<String, EnclaveMeasurement> {
+    let config: EnclaveInfoToml =
+        toml::from_str(&content).expect("Content not correct, unable to load enclave info.");
+    let mut info_map = std::collections::HashMap::new();
+    for (k, v) in config.0 {
+        info_map.insert(k, EnclaveMeasurement::new(v.mr_enclave, v.mr_signer));
+    }
+
+    info_map
+}
-- 
2.17.1

