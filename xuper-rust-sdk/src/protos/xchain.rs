// This file is generated by rust-protobuf 2.14.0. Do not edit
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![cfg_attr(rustfmt, rustfmt_skip)]

#![allow(box_pointers)]
#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unsafe_code)]
#![allow(unused_imports)]
#![allow(unused_results)]
//! Generated file from `xchain.proto`
use serde_repr::*;
use protobuf::Message as Message_imported_for_functions;
use protobuf::ProtobufEnum as ProtobufEnum_imported_for_functions;

/// Generated files are compatible only with the same version
/// of protobuf runtime.
// const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_2_14_0;

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Header {
    // message fields
    pub logid: ::std::string::String,
    #[serde(default)]
    pub from_node: ::std::string::String,
    #[serde(default)]
    pub error: XChainErrorEnum,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Header {
    fn default() -> &'a Header {
        <Header as ::protobuf::Message>::default_instance()
    }
}

impl Header {
    pub fn new() -> Header {
        ::std::default::Default::default()
    }

    // string logid = 1;


    pub fn get_logid(&self) -> &str {
        &self.logid
    }
    pub fn clear_logid(&mut self) {
        self.logid.clear();
    }

    // Param is passed by value, moved
    pub fn set_logid(&mut self, v: ::std::string::String) {
        self.logid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_logid(&mut self) -> &mut ::std::string::String {
        &mut self.logid
    }

    // Take field
    pub fn take_logid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.logid, ::std::string::String::new())
    }

    // string from_node = 2;


    pub fn get_from_node(&self) -> &str {
        &self.from_node
    }
    pub fn clear_from_node(&mut self) {
        self.from_node.clear();
    }

    // Param is passed by value, moved
    pub fn set_from_node(&mut self, v: ::std::string::String) {
        self.from_node = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_node(&mut self) -> &mut ::std::string::String {
        &mut self.from_node
    }

    // Take field
    pub fn take_from_node(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.from_node, ::std::string::String::new())
    }

    // .pb.XChainErrorEnum error = 3;


    pub fn get_error(&self) -> XChainErrorEnum {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = XChainErrorEnum::SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: XChainErrorEnum) {
        self.error = v;
    }
}

impl ::protobuf::Message for Header {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.logid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.from_node)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.logid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.logid);
        }
        if !self.from_node.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.from_node);
        }
        if self.error != XChainErrorEnum::SUCCESS {
            my_size += ::protobuf::rt::enum_size(3, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.logid.is_empty() {
            os.write_string(1, &self.logid)?;
        }
        if !self.from_node.is_empty() {
            os.write_string(2, &self.from_node)?;
        }
        if self.error != XChainErrorEnum::SUCCESS {
            os.write_enum(3, self.error.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Header {
        Header::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "logid",
                    |m: &Header| { &m.logid },
                    |m: &mut Header| { &mut m.logid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "from_node",
                    |m: &Header| { &m.from_node },
                    |m: &mut Header| { &mut m.from_node },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<XChainErrorEnum>>(
                    "error",
                    |m: &Header| { &m.error },
                    |m: &mut Header| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Header>(
                    "Header",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Header {
        static mut instance: ::protobuf::lazy::Lazy<Header> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Header::new)
        }
    }
}

impl ::protobuf::Clear for Header {
    fn clear(&mut self) {
        self.logid.clear();
        self.from_node.clear();
        self.error = XChainErrorEnum::SUCCESS;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Header {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Header {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TxDataAccount {
    // message fields
    pub address: ::std::string::String,
    pub amount: ::std::string::String,
    pub frozen_height: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxDataAccount {
    fn default() -> &'a TxDataAccount {
        <TxDataAccount as ::protobuf::Message>::default_instance()
    }
}

impl TxDataAccount {
    pub fn new() -> TxDataAccount {
        ::std::default::Default::default()
    }

    // string address = 1;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // string amount = 2;


    pub fn get_amount(&self) -> &str {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::string::String) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::string::String {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.amount, ::std::string::String::new())
    }

    // int64 frozen_height = 3;


    pub fn get_frozen_height(&self) -> i64 {
        self.frozen_height
    }
    pub fn clear_frozen_height(&mut self) {
        self.frozen_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_height(&mut self, v: i64) {
        self.frozen_height = v;
    }
}

impl ::protobuf::Message for TxDataAccount {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.amount)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.address);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.amount);
        }
        if self.frozen_height != 0 {
            my_size += ::protobuf::rt::value_size(3, self.frozen_height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.address.is_empty() {
            os.write_string(1, &self.address)?;
        }
        if !self.amount.is_empty() {
            os.write_string(2, &self.amount)?;
        }
        if self.frozen_height != 0 {
            os.write_int64(3, self.frozen_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxDataAccount {
        TxDataAccount::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &TxDataAccount| { &m.address },
                    |m: &mut TxDataAccount| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "amount",
                    |m: &TxDataAccount| { &m.amount },
                    |m: &mut TxDataAccount| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "frozen_height",
                    |m: &TxDataAccount| { &m.frozen_height },
                    |m: &mut TxDataAccount| { &mut m.frozen_height },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TxDataAccount>(
                    "TxDataAccount",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TxDataAccount {
        static mut instance: ::protobuf::lazy::Lazy<TxDataAccount> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TxDataAccount::new)
        }
    }
}

impl ::protobuf::Clear for TxDataAccount {
    fn clear(&mut self) {
        self.address.clear();
        self.amount.clear();
        self.frozen_height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxDataAccount {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxDataAccount {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TxData {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub txid: ::std::vec::Vec<u8>,
    pub bcname: ::std::string::String,
    pub from_addr: ::std::string::String,
    pub from_pubkey: ::std::string::String,
    pub from_scrkey: ::std::string::String,
    pub user_sign: ::std::vec::Vec<u8>,
    pub account: ::protobuf::RepeatedField<TxDataAccount>,
    pub nonce: ::std::string::String,
    pub timestamp: i64,
    pub desc: ::std::vec::Vec<u8>,
    pub version: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxData {
    fn default() -> &'a TxData {
        <TxData as ::protobuf::Message>::default_instance()
    }
}

impl TxData {
    pub fn new() -> TxData {
        ::std::default::Default::default()
    }

    // .pb.Header header = 13;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // bytes txid = 1;


    pub fn get_txid(&self) -> &[u8] {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txid, ::std::vec::Vec::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // string from_addr = 3;


    pub fn get_from_addr(&self) -> &str {
        &self.from_addr
    }
    pub fn clear_from_addr(&mut self) {
        self.from_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_from_addr(&mut self, v: ::std::string::String) {
        self.from_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_addr(&mut self) -> &mut ::std::string::String {
        &mut self.from_addr
    }

    // Take field
    pub fn take_from_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.from_addr, ::std::string::String::new())
    }

    // string from_pubkey = 4;


    pub fn get_from_pubkey(&self) -> &str {
        &self.from_pubkey
    }
    pub fn clear_from_pubkey(&mut self) {
        self.from_pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_from_pubkey(&mut self, v: ::std::string::String) {
        self.from_pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_pubkey(&mut self) -> &mut ::std::string::String {
        &mut self.from_pubkey
    }

    // Take field
    pub fn take_from_pubkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.from_pubkey, ::std::string::String::new())
    }

    // string from_scrkey = 5;


    pub fn get_from_scrkey(&self) -> &str {
        &self.from_scrkey
    }
    pub fn clear_from_scrkey(&mut self) {
        self.from_scrkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_from_scrkey(&mut self, v: ::std::string::String) {
        self.from_scrkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_scrkey(&mut self) -> &mut ::std::string::String {
        &mut self.from_scrkey
    }

    // Take field
    pub fn take_from_scrkey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.from_scrkey, ::std::string::String::new())
    }

    // bytes user_sign = 14;


    pub fn get_user_sign(&self) -> &[u8] {
        &self.user_sign
    }
    pub fn clear_user_sign(&mut self) {
        self.user_sign.clear();
    }

    // Param is passed by value, moved
    pub fn set_user_sign(&mut self, v: ::std::vec::Vec<u8>) {
        self.user_sign = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_user_sign(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.user_sign
    }

    // Take field
    pub fn take_user_sign(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.user_sign, ::std::vec::Vec::new())
    }

    // repeated .pb.TxDataAccount account = 6;


    pub fn get_account(&self) -> &[TxDataAccount] {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::protobuf::RepeatedField<TxDataAccount>) {
        self.account = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account(&mut self) -> &mut ::protobuf::RepeatedField<TxDataAccount> {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::protobuf::RepeatedField<TxDataAccount> {
        ::std::mem::replace(&mut self.account, ::protobuf::RepeatedField::new())
    }

    // string nonce = 8;


    pub fn get_nonce(&self) -> &str {
        &self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::string::String) {
        self.nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::string::String {
        &mut self.nonce
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nonce, ::std::string::String::new())
    }

    // int64 timestamp = 9;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // bytes desc = 12;


    pub fn get_desc(&self) -> &[u8] {
        &self.desc
    }
    pub fn clear_desc(&mut self) {
        self.desc.clear();
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::vec::Vec<u8>) {
        self.desc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.desc
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.desc, ::std::vec::Vec::new())
    }

    // int32 version = 15;


    pub fn get_version(&self) -> i32 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = v;
    }
}

impl ::protobuf::Message for TxData {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.account {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.from_addr)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.from_pubkey)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.from_scrkey)?;
                },
                14 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.user_sign)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.account)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nonce)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.desc)?;
                },
                15 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txid);
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if !self.from_addr.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.from_addr);
        }
        if !self.from_pubkey.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.from_pubkey);
        }
        if !self.from_scrkey.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.from_scrkey);
        }
        if !self.user_sign.is_empty() {
            my_size += ::protobuf::rt::bytes_size(14, &self.user_sign);
        }
        for value in &self.account {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.nonce);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(9, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.desc.is_empty() {
            my_size += ::protobuf::rt::bytes_size(12, &self.desc);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(15, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.txid.is_empty() {
            os.write_bytes(1, &self.txid)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if !self.from_addr.is_empty() {
            os.write_string(3, &self.from_addr)?;
        }
        if !self.from_pubkey.is_empty() {
            os.write_string(4, &self.from_pubkey)?;
        }
        if !self.from_scrkey.is_empty() {
            os.write_string(5, &self.from_scrkey)?;
        }
        if !self.user_sign.is_empty() {
            os.write_bytes(14, &self.user_sign)?;
        }
        for v in &self.account {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.nonce.is_empty() {
            os.write_string(8, &self.nonce)?;
        }
        if self.timestamp != 0 {
            os.write_int64(9, self.timestamp)?;
        }
        if !self.desc.is_empty() {
            os.write_bytes(12, &self.desc)?;
        }
        if self.version != 0 {
            os.write_int32(15, self.version)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxData {
        TxData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &TxData| { &m.header },
                    |m: &mut TxData| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txid",
                    |m: &TxData| { &m.txid },
                    |m: &mut TxData| { &mut m.txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &TxData| { &m.bcname },
                    |m: &mut TxData| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "from_addr",
                    |m: &TxData| { &m.from_addr },
                    |m: &mut TxData| { &mut m.from_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "from_pubkey",
                    |m: &TxData| { &m.from_pubkey },
                    |m: &mut TxData| { &mut m.from_pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "from_scrkey",
                    |m: &TxData| { &m.from_scrkey },
                    |m: &mut TxData| { &mut m.from_scrkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "user_sign",
                    |m: &TxData| { &m.user_sign },
                    |m: &mut TxData| { &mut m.user_sign },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TxDataAccount>>(
                    "account",
                    |m: &TxData| { &m.account },
                    |m: &mut TxData| { &mut m.account },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nonce",
                    |m: &TxData| { &m.nonce },
                    |m: &mut TxData| { &mut m.nonce },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timestamp",
                    |m: &TxData| { &m.timestamp },
                    |m: &mut TxData| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "desc",
                    |m: &TxData| { &m.desc },
                    |m: &mut TxData| { &mut m.desc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "version",
                    |m: &TxData| { &m.version },
                    |m: &mut TxData| { &mut m.version },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TxData>(
                    "TxData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TxData {
        static mut instance: ::protobuf::lazy::Lazy<TxData> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TxData::new)
        }
    }
}

impl ::protobuf::Clear for TxData {
    fn clear(&mut self) {
        self.header.clear();
        self.txid.clear();
        self.bcname.clear();
        self.from_addr.clear();
        self.from_pubkey.clear();
        self.from_scrkey.clear();
        self.user_sign.clear();
        self.account.clear();
        self.nonce.clear();
        self.timestamp = 0;
        self.desc.clear();
        self.version = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TxStatus {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub txid: ::std::vec::Vec<u8>,
    pub status: TransactionStatus,
    pub distance: i64,
    pub tx: ::protobuf::SingularPtrField<Transaction>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxStatus {
    fn default() -> &'a TxStatus {
        <TxStatus as ::protobuf::Message>::default_instance()
    }
}

impl TxStatus {
    pub fn new() -> TxStatus {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // bytes txid = 3;


    pub fn get_txid(&self) -> &[u8] {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txid, ::std::vec::Vec::new())
    }

    // .pb.TransactionStatus status = 4;


    pub fn get_status(&self) -> TransactionStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = TransactionStatus::UNDEFINE;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: TransactionStatus) {
        self.status = v;
    }

    // int64 distance = 5;


    pub fn get_distance(&self) -> i64 {
        self.distance
    }
    pub fn clear_distance(&mut self) {
        self.distance = 0;
    }

    // Param is passed by value, moved
    pub fn set_distance(&mut self, v: i64) {
        self.distance = v;
    }

    // .pb.Transaction tx = 7;


    pub fn get_tx(&self) -> &Transaction {
        self.tx.as_ref().unwrap_or_else(|| Transaction::default_instance())
    }
    pub fn clear_tx(&mut self) {
        self.tx.clear();
    }

    pub fn has_tx(&self) -> bool {
        self.tx.is_some()
    }

    // Param is passed by value, moved
    pub fn set_tx(&mut self, v: Transaction) {
        self.tx = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tx(&mut self) -> &mut Transaction {
        if self.tx.is_none() {
            self.tx.set_default();
        }
        self.tx.as_mut().unwrap()
    }

    // Take field
    pub fn take_tx(&mut self) -> Transaction {
        self.tx.take().unwrap_or_else(|| Transaction::new())
    }
}

impl ::protobuf::Message for TxStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tx {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txid)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 4, &mut self.unknown_fields)?
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.distance = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.tx)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.txid);
        }
        if self.status != TransactionStatus::UNDEFINE {
            my_size += ::protobuf::rt::enum_size(4, self.status);
        }
        if self.distance != 0 {
            my_size += ::protobuf::rt::value_size(5, self.distance, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.tx.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if !self.txid.is_empty() {
            os.write_bytes(3, &self.txid)?;
        }
        if self.status != TransactionStatus::UNDEFINE {
            os.write_enum(4, self.status.value())?;
        }
        if self.distance != 0 {
            os.write_int64(5, self.distance)?;
        }
        if let Some(ref v) = self.tx.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxStatus {
        TxStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &TxStatus| { &m.header },
                    |m: &mut TxStatus| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &TxStatus| { &m.bcname },
                    |m: &mut TxStatus| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txid",
                    |m: &TxStatus| { &m.txid },
                    |m: &mut TxStatus| { &mut m.txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<TransactionStatus>>(
                    "status",
                    |m: &TxStatus| { &m.status },
                    |m: &mut TxStatus| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "distance",
                    |m: &TxStatus| { &m.distance },
                    |m: &mut TxStatus| { &mut m.distance },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction>>(
                    "tx",
                    |m: &TxStatus| { &m.tx },
                    |m: &mut TxStatus| { &mut m.tx },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TxStatus>(
                    "TxStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TxStatus {
        static mut instance: ::protobuf::lazy::Lazy<TxStatus> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TxStatus::new)
        }
    }
}

impl ::protobuf::Clear for TxStatus {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.txid.clear();
        self.status = TransactionStatus::UNDEFINE;
        self.distance = 0;
        self.tx.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BatchTxs {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub Txs: ::protobuf::RepeatedField<TxStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BatchTxs {
    fn default() -> &'a BatchTxs {
        <BatchTxs as ::protobuf::Message>::default_instance()
    }
}

impl BatchTxs {
    pub fn new() -> BatchTxs {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // repeated .pb.TxStatus Txs = 2;


    pub fn get_Txs(&self) -> &[TxStatus] {
        &self.Txs
    }
    pub fn clear_Txs(&mut self) {
        self.Txs.clear();
    }

    // Param is passed by value, moved
    pub fn set_Txs(&mut self, v: ::protobuf::RepeatedField<TxStatus>) {
        self.Txs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_Txs(&mut self) -> &mut ::protobuf::RepeatedField<TxStatus> {
        &mut self.Txs
    }

    // Take field
    pub fn take_Txs(&mut self) -> ::protobuf::RepeatedField<TxStatus> {
        ::std::mem::replace(&mut self.Txs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BatchTxs {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Txs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.Txs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.Txs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.Txs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BatchTxs {
        BatchTxs::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &BatchTxs| { &m.header },
                    |m: &mut BatchTxs| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TxStatus>>(
                    "Txs",
                    |m: &BatchTxs| { &m.Txs },
                    |m: &mut BatchTxs| { &mut m.Txs },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<BatchTxs>(
                    "BatchTxs",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BatchTxs {
        static mut instance: ::protobuf::lazy::Lazy<BatchTxs> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(BatchTxs::new)
        }
    }
}

impl ::protobuf::Clear for BatchTxs {
    fn clear(&mut self) {
        self.header.clear();
        self.Txs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BatchTxs {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BatchTxs {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Block {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub blockid: ::std::vec::Vec<u8>,
    pub status: Block_EBlockStatus,
    pub block: ::protobuf::SingularPtrField<InternalBlock>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Block {
    fn default() -> &'a Block {
        <Block as ::protobuf::Message>::default_instance()
    }
}

impl Block {
    pub fn new() -> Block {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // bytes blockid = 3;


    pub fn get_blockid(&self) -> &[u8] {
        &self.blockid
    }
    pub fn clear_blockid(&mut self) {
        self.blockid.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockid(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blockid
    }

    // Take field
    pub fn take_blockid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blockid, ::std::vec::Vec::new())
    }

    // .pb.Block.EBlockStatus status = 4;


    pub fn get_status(&self) -> Block_EBlockStatus {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = Block_EBlockStatus::ERROR;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: Block_EBlockStatus) {
        self.status = v;
    }

    // .pb.InternalBlock block = 5;


    pub fn get_block(&self) -> &InternalBlock {
        self.block.as_ref().unwrap_or_else(|| InternalBlock::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: InternalBlock) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut InternalBlock {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> InternalBlock {
        self.block.take().unwrap_or_else(|| InternalBlock::new())
    }
}

impl ::protobuf::Message for Block {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blockid)?;
                },
                4 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.status, 4, &mut self.unknown_fields)?
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if !self.blockid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.blockid);
        }
        if self.status != Block_EBlockStatus::ERROR {
            my_size += ::protobuf::rt::enum_size(4, self.status);
        }
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if !self.blockid.is_empty() {
            os.write_bytes(3, &self.blockid)?;
        }
        if self.status != Block_EBlockStatus::ERROR {
            os.write_enum(4, self.status.value())?;
        }
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Block {
        Block::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &Block| { &m.header },
                    |m: &mut Block| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &Block| { &m.bcname },
                    |m: &mut Block| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "blockid",
                    |m: &Block| { &m.blockid },
                    |m: &mut Block| { &mut m.blockid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<Block_EBlockStatus>>(
                    "status",
                    |m: &Block| { &m.status },
                    |m: &mut Block| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InternalBlock>>(
                    "block",
                    |m: &Block| { &m.block },
                    |m: &mut Block| { &mut m.block },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Block>(
                    "Block",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Block {
        static mut instance: ::protobuf::lazy::Lazy<Block> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Block::new)
        }
    }
}

impl ::protobuf::Clear for Block {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.blockid.clear();
        self.status = Block_EBlockStatus::ERROR;
        self.block.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Block {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Block {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize_repr, Deserialize_repr))]
#[repr(u8)]
pub enum Block_EBlockStatus {
    ERROR = 0,
    TRUNK = 1,
    BRANCH = 2,
    NOEXIST = 3,
}

impl ::protobuf::ProtobufEnum for Block_EBlockStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<Block_EBlockStatus> {
        match value {
            0 => ::std::option::Option::Some(Block_EBlockStatus::ERROR),
            1 => ::std::option::Option::Some(Block_EBlockStatus::TRUNK),
            2 => ::std::option::Option::Some(Block_EBlockStatus::BRANCH),
            3 => ::std::option::Option::Some(Block_EBlockStatus::NOEXIST),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [Block_EBlockStatus] = &[
            Block_EBlockStatus::ERROR,
            Block_EBlockStatus::TRUNK,
            Block_EBlockStatus::BRANCH,
            Block_EBlockStatus::NOEXIST,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<Block_EBlockStatus>("Block.EBlockStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for Block_EBlockStatus {
}

impl ::std::default::Default for Block_EBlockStatus {
    fn default() -> Self {
        Block_EBlockStatus::ERROR
    }
}

impl ::protobuf::reflect::ProtobufValue for Block_EBlockStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BlockID {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub blockid: ::std::vec::Vec<u8>,
    pub need_content: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockID {
    fn default() -> &'a BlockID {
        <BlockID as ::protobuf::Message>::default_instance()
    }
}

impl BlockID {
    pub fn new() -> BlockID {
        ::std::default::Default::default()
    }

    // .pb.Header header = 4;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 1;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // bytes blockid = 2;


    pub fn get_blockid(&self) -> &[u8] {
        &self.blockid
    }
    pub fn clear_blockid(&mut self) {
        self.blockid.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockid(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blockid
    }

    // Take field
    pub fn take_blockid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blockid, ::std::vec::Vec::new())
    }

    // bool need_content = 3;


    pub fn get_need_content(&self) -> bool {
        self.need_content
    }
    pub fn clear_need_content(&mut self) {
        self.need_content = false;
    }

    // Param is passed by value, moved
    pub fn set_need_content(&mut self, v: bool) {
        self.need_content = v;
    }
}

impl ::protobuf::Message for BlockID {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blockid)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.need_content = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bcname);
        }
        if !self.blockid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.blockid);
        }
        if self.need_content != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(1, &self.bcname)?;
        }
        if !self.blockid.is_empty() {
            os.write_bytes(2, &self.blockid)?;
        }
        if self.need_content != false {
            os.write_bool(3, self.need_content)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockID {
        BlockID::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &BlockID| { &m.header },
                    |m: &mut BlockID| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &BlockID| { &m.bcname },
                    |m: &mut BlockID| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "blockid",
                    |m: &BlockID| { &m.blockid },
                    |m: &mut BlockID| { &mut m.blockid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "need_content",
                    |m: &BlockID| { &m.need_content },
                    |m: &mut BlockID| { &mut m.need_content },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockID>(
                    "BlockID",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockID {
        static mut instance: ::protobuf::lazy::Lazy<BlockID> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(BlockID::new)
        }
    }
}

impl ::protobuf::Clear for BlockID {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.blockid.clear();
        self.need_content = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockID {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockID {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BlockHeight {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub height: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockHeight {
    fn default() -> &'a BlockHeight {
        <BlockHeight as ::protobuf::Message>::default_instance()
    }
}

impl BlockHeight {
    pub fn new() -> BlockHeight {
        ::std::default::Default::default()
    }

    // .pb.Header header = 3;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 1;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // int64 height = 2;


    pub fn get_height(&self) -> i64 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i64) {
        self.height = v;
    }
}

impl ::protobuf::Message for BlockHeight {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bcname);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(2, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(1, &self.bcname)?;
        }
        if self.height != 0 {
            os.write_int64(2, self.height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockHeight {
        BlockHeight::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &BlockHeight| { &m.header },
                    |m: &mut BlockHeight| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &BlockHeight| { &m.bcname },
                    |m: &mut BlockHeight| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "height",
                    |m: &BlockHeight| { &m.height },
                    |m: &mut BlockHeight| { &mut m.height },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockHeight>(
                    "BlockHeight",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockHeight {
        static mut instance: ::protobuf::lazy::Lazy<BlockHeight> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(BlockHeight::new)
        }
    }
}

impl ::protobuf::Clear for BlockHeight {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockHeight {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockHeight {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CommonReply {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommonReply {
    fn default() -> &'a CommonReply {
        <CommonReply as ::protobuf::Message>::default_instance()
    }
}

impl CommonReply {
    pub fn new() -> CommonReply {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }
}

impl ::protobuf::Message for CommonReply {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommonReply {
        CommonReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &CommonReply| { &m.header },
                    |m: &mut CommonReply| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommonReply>(
                    "CommonReply",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommonReply {
        static mut instance: ::protobuf::lazy::Lazy<CommonReply> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CommonReply::new)
        }
    }
}

impl ::protobuf::Clear for CommonReply {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommonReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommonReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct CommonIn {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a CommonIn {
    fn default() -> &'a CommonIn {
        <CommonIn as ::protobuf::Message>::default_instance()
    }
}

impl CommonIn {
    pub fn new() -> CommonIn {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }
}

impl ::protobuf::Message for CommonIn {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> CommonIn {
        CommonIn::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &CommonIn| { &m.header },
                    |m: &mut CommonIn| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<CommonIn>(
                    "CommonIn",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static CommonIn {
        static mut instance: ::protobuf::lazy::Lazy<CommonIn> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(CommonIn::new)
        }
    }
}

impl ::protobuf::Clear for CommonIn {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for CommonIn {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CommonIn {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TokenDetail {
    // message fields
    pub bcname: ::std::string::String,
    pub balance: ::std::string::String,
    pub error: XChainErrorEnum,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TokenDetail {
    fn default() -> &'a TokenDetail {
        <TokenDetail as ::protobuf::Message>::default_instance()
    }
}

impl TokenDetail {
    pub fn new() -> TokenDetail {
        ::std::default::Default::default()
    }

    // string bcname = 1;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // string balance = 2;


    pub fn get_balance(&self) -> &str {
        &self.balance
    }
    pub fn clear_balance(&mut self) {
        self.balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: ::std::string::String) {
        self.balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance(&mut self) -> &mut ::std::string::String {
        &mut self.balance
    }

    // Take field
    pub fn take_balance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.balance, ::std::string::String::new())
    }

    // .pb.XChainErrorEnum error = 3;


    pub fn get_error(&self) -> XChainErrorEnum {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = XChainErrorEnum::SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: XChainErrorEnum) {
        self.error = v;
    }
}

impl ::protobuf::Message for TokenDetail {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.balance)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bcname);
        }
        if !self.balance.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.balance);
        }
        if self.error != XChainErrorEnum::SUCCESS {
            my_size += ::protobuf::rt::enum_size(3, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bcname.is_empty() {
            os.write_string(1, &self.bcname)?;
        }
        if !self.balance.is_empty() {
            os.write_string(2, &self.balance)?;
        }
        if self.error != XChainErrorEnum::SUCCESS {
            os.write_enum(3, self.error.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TokenDetail {
        TokenDetail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &TokenDetail| { &m.bcname },
                    |m: &mut TokenDetail| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "balance",
                    |m: &TokenDetail| { &m.balance },
                    |m: &mut TokenDetail| { &mut m.balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<XChainErrorEnum>>(
                    "error",
                    |m: &TokenDetail| { &m.error },
                    |m: &mut TokenDetail| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TokenDetail>(
                    "TokenDetail",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TokenDetail {
        static mut instance: ::protobuf::lazy::Lazy<TokenDetail> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TokenDetail::new)
        }
    }
}

impl ::protobuf::Clear for TokenDetail {
    fn clear(&mut self) {
        self.bcname.clear();
        self.balance.clear();
        self.error = XChainErrorEnum::SUCCESS;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TokenDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenDetail {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AddressStatus {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub address: ::std::string::String,
    pub bcs: ::protobuf::RepeatedField<TokenDetail>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddressStatus {
    fn default() -> &'a AddressStatus {
        <AddressStatus as ::protobuf::Message>::default_instance()
    }
}

impl AddressStatus {
    pub fn new() -> AddressStatus {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string address = 2;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // repeated .pb.TokenDetail bcs = 3;


    pub fn get_bcs(&self) -> &[TokenDetail] {
        &self.bcs
    }
    pub fn clear_bcs(&mut self) {
        self.bcs.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcs(&mut self, v: ::protobuf::RepeatedField<TokenDetail>) {
        self.bcs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bcs(&mut self) -> &mut ::protobuf::RepeatedField<TokenDetail> {
        &mut self.bcs
    }

    // Take field
    pub fn take_bcs(&mut self) -> ::protobuf::RepeatedField<TokenDetail> {
        ::std::mem::replace(&mut self.bcs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AddressStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bcs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bcs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.address);
        }
        for value in &self.bcs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.address.is_empty() {
            os.write_string(2, &self.address)?;
        }
        for v in &self.bcs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressStatus {
        AddressStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &AddressStatus| { &m.header },
                    |m: &mut AddressStatus| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &AddressStatus| { &m.address },
                    |m: &mut AddressStatus| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TokenDetail>>(
                    "bcs",
                    |m: &AddressStatus| { &m.bcs },
                    |m: &mut AddressStatus| { &mut m.bcs },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddressStatus>(
                    "AddressStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddressStatus {
        static mut instance: ::protobuf::lazy::Lazy<AddressStatus> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AddressStatus::new)
        }
    }
}

impl ::protobuf::Clear for AddressStatus {
    fn clear(&mut self) {
        self.header.clear();
        self.address.clear();
        self.bcs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TokenFrozenDetail {
    // message fields
    pub balance: ::std::string::String,
    pub isFrozen: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TokenFrozenDetail {
    fn default() -> &'a TokenFrozenDetail {
        <TokenFrozenDetail as ::protobuf::Message>::default_instance()
    }
}

impl TokenFrozenDetail {
    pub fn new() -> TokenFrozenDetail {
        ::std::default::Default::default()
    }

    // string balance = 1;


    pub fn get_balance(&self) -> &str {
        &self.balance
    }
    pub fn clear_balance(&mut self) {
        self.balance.clear();
    }

    // Param is passed by value, moved
    pub fn set_balance(&mut self, v: ::std::string::String) {
        self.balance = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_balance(&mut self) -> &mut ::std::string::String {
        &mut self.balance
    }

    // Take field
    pub fn take_balance(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.balance, ::std::string::String::new())
    }

    // bool isFrozen = 2;


    pub fn get_isFrozen(&self) -> bool {
        self.isFrozen
    }
    pub fn clear_isFrozen(&mut self) {
        self.isFrozen = false;
    }

    // Param is passed by value, moved
    pub fn set_isFrozen(&mut self, v: bool) {
        self.isFrozen = v;
    }
}

impl ::protobuf::Message for TokenFrozenDetail {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.balance)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.isFrozen = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.balance.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.balance);
        }
        if self.isFrozen != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.balance.is_empty() {
            os.write_string(1, &self.balance)?;
        }
        if self.isFrozen != false {
            os.write_bool(2, self.isFrozen)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TokenFrozenDetail {
        TokenFrozenDetail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "balance",
                    |m: &TokenFrozenDetail| { &m.balance },
                    |m: &mut TokenFrozenDetail| { &mut m.balance },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "isFrozen",
                    |m: &TokenFrozenDetail| { &m.isFrozen },
                    |m: &mut TokenFrozenDetail| { &mut m.isFrozen },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TokenFrozenDetail>(
                    "TokenFrozenDetail",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TokenFrozenDetail {
        static mut instance: ::protobuf::lazy::Lazy<TokenFrozenDetail> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TokenFrozenDetail::new)
        }
    }
}

impl ::protobuf::Clear for TokenFrozenDetail {
    fn clear(&mut self) {
        self.balance.clear();
        self.isFrozen = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TokenFrozenDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenFrozenDetail {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TokenFrozenDetails {
    // message fields
    pub bcname: ::std::string::String,
    pub tfd: ::protobuf::RepeatedField<TokenFrozenDetail>,
    pub error: XChainErrorEnum,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TokenFrozenDetails {
    fn default() -> &'a TokenFrozenDetails {
        <TokenFrozenDetails as ::protobuf::Message>::default_instance()
    }
}

impl TokenFrozenDetails {
    pub fn new() -> TokenFrozenDetails {
        ::std::default::Default::default()
    }

    // string bcname = 1;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // repeated .pb.TokenFrozenDetail tfd = 2;


    pub fn get_tfd(&self) -> &[TokenFrozenDetail] {
        &self.tfd
    }
    pub fn clear_tfd(&mut self) {
        self.tfd.clear();
    }

    // Param is passed by value, moved
    pub fn set_tfd(&mut self, v: ::protobuf::RepeatedField<TokenFrozenDetail>) {
        self.tfd = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tfd(&mut self) -> &mut ::protobuf::RepeatedField<TokenFrozenDetail> {
        &mut self.tfd
    }

    // Take field
    pub fn take_tfd(&mut self) -> ::protobuf::RepeatedField<TokenFrozenDetail> {
        ::std::mem::replace(&mut self.tfd, ::protobuf::RepeatedField::new())
    }

    // .pb.XChainErrorEnum error = 3;


    pub fn get_error(&self) -> XChainErrorEnum {
        self.error
    }
    pub fn clear_error(&mut self) {
        self.error = XChainErrorEnum::SUCCESS;
    }

    // Param is passed by value, moved
    pub fn set_error(&mut self, v: XChainErrorEnum) {
        self.error = v;
    }
}

impl ::protobuf::Message for TokenFrozenDetails {
    fn is_initialized(&self) -> bool {
        for v in &self.tfd {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tfd)?;
                },
                3 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.error, 3, &mut self.unknown_fields)?
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bcname);
        }
        for value in &self.tfd {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.error != XChainErrorEnum::SUCCESS {
            my_size += ::protobuf::rt::enum_size(3, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bcname.is_empty() {
            os.write_string(1, &self.bcname)?;
        }
        for v in &self.tfd {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.error != XChainErrorEnum::SUCCESS {
            os.write_enum(3, self.error.value())?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TokenFrozenDetails {
        TokenFrozenDetails::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &TokenFrozenDetails| { &m.bcname },
                    |m: &mut TokenFrozenDetails| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TokenFrozenDetail>>(
                    "tfd",
                    |m: &TokenFrozenDetails| { &m.tfd },
                    |m: &mut TokenFrozenDetails| { &mut m.tfd },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<XChainErrorEnum>>(
                    "error",
                    |m: &TokenFrozenDetails| { &m.error },
                    |m: &mut TokenFrozenDetails| { &mut m.error },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TokenFrozenDetails>(
                    "TokenFrozenDetails",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TokenFrozenDetails {
        static mut instance: ::protobuf::lazy::Lazy<TokenFrozenDetails> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TokenFrozenDetails::new)
        }
    }
}

impl ::protobuf::Clear for TokenFrozenDetails {
    fn clear(&mut self) {
        self.bcname.clear();
        self.tfd.clear();
        self.error = XChainErrorEnum::SUCCESS;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TokenFrozenDetails {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TokenFrozenDetails {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AddressBalanceStatus {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub address: ::std::string::String,
    pub tfds: ::protobuf::RepeatedField<TokenFrozenDetails>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AddressBalanceStatus {
    fn default() -> &'a AddressBalanceStatus {
        <AddressBalanceStatus as ::protobuf::Message>::default_instance()
    }
}

impl AddressBalanceStatus {
    pub fn new() -> AddressBalanceStatus {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string address = 2;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // repeated .pb.TokenFrozenDetails tfds = 3;


    pub fn get_tfds(&self) -> &[TokenFrozenDetails] {
        &self.tfds
    }
    pub fn clear_tfds(&mut self) {
        self.tfds.clear();
    }

    // Param is passed by value, moved
    pub fn set_tfds(&mut self, v: ::protobuf::RepeatedField<TokenFrozenDetails>) {
        self.tfds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tfds(&mut self) -> &mut ::protobuf::RepeatedField<TokenFrozenDetails> {
        &mut self.tfds
    }

    // Take field
    pub fn take_tfds(&mut self) -> ::protobuf::RepeatedField<TokenFrozenDetails> {
        ::std::mem::replace(&mut self.tfds, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AddressBalanceStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tfds {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tfds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.address);
        }
        for value in &self.tfds {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.address.is_empty() {
            os.write_string(2, &self.address)?;
        }
        for v in &self.tfds {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AddressBalanceStatus {
        AddressBalanceStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &AddressBalanceStatus| { &m.header },
                    |m: &mut AddressBalanceStatus| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &AddressBalanceStatus| { &m.address },
                    |m: &mut AddressBalanceStatus| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TokenFrozenDetails>>(
                    "tfds",
                    |m: &AddressBalanceStatus| { &m.tfds },
                    |m: &mut AddressBalanceStatus| { &mut m.tfds },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AddressBalanceStatus>(
                    "AddressBalanceStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AddressBalanceStatus {
        static mut instance: ::protobuf::lazy::Lazy<AddressBalanceStatus> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AddressBalanceStatus::new)
        }
    }
}

impl ::protobuf::Clear for AddressBalanceStatus {
    fn clear(&mut self) {
        self.header.clear();
        self.address.clear();
        self.tfds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AddressBalanceStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AddressBalanceStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TxInput {
    // message fields
    pub ref_txid: ::std::vec::Vec<u8>,
    pub ref_offset: i32,
    #[serde(serialize_with = "crate::wallet::serialize_bytes")]
    #[serde(deserialize_with = "crate::wallet::deserialize_bytes")]
    pub from_addr: ::std::vec::Vec<u8>,
    pub amount: ::std::vec::Vec<u8>,
    pub frozen_height: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxInput {
    fn default() -> &'a TxInput {
        <TxInput as ::protobuf::Message>::default_instance()
    }
}

impl TxInput {
    pub fn new() -> TxInput {
        ::std::default::Default::default()
    }

    // bytes ref_txid = 1;


    pub fn get_ref_txid(&self) -> &[u8] {
        &self.ref_txid
    }
    pub fn clear_ref_txid(&mut self) {
        self.ref_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_ref_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.ref_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ref_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ref_txid
    }

    // Take field
    pub fn take_ref_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ref_txid, ::std::vec::Vec::new())
    }

    // int32 ref_offset = 2;


    pub fn get_ref_offset(&self) -> i32 {
        self.ref_offset
    }
    pub fn clear_ref_offset(&mut self) {
        self.ref_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_ref_offset(&mut self, v: i32) {
        self.ref_offset = v;
    }

    // bytes from_addr = 5;


    pub fn get_from_addr(&self) -> &[u8] {
        &self.from_addr
    }
    pub fn clear_from_addr(&mut self) {
        self.from_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_from_addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.from_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_from_addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.from_addr
    }

    // Take field
    pub fn take_from_addr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.from_addr, ::std::vec::Vec::new())
    }

    // bytes amount = 6;


    pub fn get_amount(&self) -> &[u8] {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::vec::Vec<u8>) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.amount, ::std::vec::Vec::new())
    }

    // int64 frozen_height = 7;


    pub fn get_frozen_height(&self) -> i64 {
        self.frozen_height
    }
    pub fn clear_frozen_height(&mut self) {
        self.frozen_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_height(&mut self, v: i64) {
        self.frozen_height = v;
    }
}

impl ::protobuf::Message for TxInput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ref_txid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ref_offset = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.from_addr)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.amount)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.ref_txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.ref_txid);
        }
        if self.ref_offset != 0 {
            my_size += ::protobuf::rt::value_size(2, self.ref_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.from_addr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.from_addr);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.amount);
        }
        if self.frozen_height != 0 {
            my_size += ::protobuf::rt::value_size(7, self.frozen_height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.ref_txid.is_empty() {
            os.write_bytes(1, &self.ref_txid)?;
        }
        if self.ref_offset != 0 {
            os.write_int32(2, self.ref_offset)?;
        }
        if !self.from_addr.is_empty() {
            os.write_bytes(5, &self.from_addr)?;
        }
        if !self.amount.is_empty() {
            os.write_bytes(6, &self.amount)?;
        }
        if self.frozen_height != 0 {
            os.write_int64(7, self.frozen_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxInput {
        TxInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ref_txid",
                    |m: &TxInput| { &m.ref_txid },
                    |m: &mut TxInput| { &mut m.ref_txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ref_offset",
                    |m: &TxInput| { &m.ref_offset },
                    |m: &mut TxInput| { &mut m.ref_offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "from_addr",
                    |m: &TxInput| { &m.from_addr },
                    |m: &mut TxInput| { &mut m.from_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "amount",
                    |m: &TxInput| { &m.amount },
                    |m: &mut TxInput| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "frozen_height",
                    |m: &TxInput| { &m.frozen_height },
                    |m: &mut TxInput| { &mut m.frozen_height },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TxInput>(
                    "TxInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TxInput {
        static mut instance: ::protobuf::lazy::Lazy<TxInput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TxInput::new)
        }
    }
}

impl ::protobuf::Clear for TxInput {
    fn clear(&mut self) {
        self.ref_txid.clear();
        self.ref_offset = 0;
        self.from_addr.clear();
        self.amount.clear();
        self.frozen_height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TxOutput {
    // message fields
    #[serde(serialize_with = "crate::wallet::serialize_bytes")]
    #[serde(deserialize_with = "crate::wallet::deserialize_bytes")]
    pub amount: ::std::vec::Vec<u8>,
    #[serde(serialize_with = "crate::wallet::serialize_bytes")]
    #[serde(deserialize_with = "crate::wallet::deserialize_bytes")]
    pub to_addr: ::std::vec::Vec<u8>,
    pub frozen_height: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxOutput {
    fn default() -> &'a TxOutput {
        <TxOutput as ::protobuf::Message>::default_instance()
    }
}

impl TxOutput {
    pub fn new() -> TxOutput {
        ::std::default::Default::default()
    }

    // bytes amount = 1;


    pub fn get_amount(&self) -> &[u8] {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::vec::Vec<u8>) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.amount, ::std::vec::Vec::new())
    }

    // bytes to_addr = 2;


    pub fn get_to_addr(&self) -> &[u8] {
        &self.to_addr
    }
    pub fn clear_to_addr(&mut self) {
        self.to_addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_to_addr(&mut self, v: ::std::vec::Vec<u8>) {
        self.to_addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_to_addr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.to_addr
    }

    // Take field
    pub fn take_to_addr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.to_addr, ::std::vec::Vec::new())
    }

    // int64 frozen_height = 4;


    pub fn get_frozen_height(&self) -> i64 {
        self.frozen_height
    }
    pub fn clear_frozen_height(&mut self) {
        self.frozen_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_frozen_height(&mut self, v: i64) {
        self.frozen_height = v;
    }
}

impl ::protobuf::Message for TxOutput {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.amount)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.to_addr)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.frozen_height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.amount);
        }
        if !self.to_addr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.to_addr);
        }
        if self.frozen_height != 0 {
            my_size += ::protobuf::rt::value_size(4, self.frozen_height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.amount.is_empty() {
            os.write_bytes(1, &self.amount)?;
        }
        if !self.to_addr.is_empty() {
            os.write_bytes(2, &self.to_addr)?;
        }
        if self.frozen_height != 0 {
            os.write_int64(4, self.frozen_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxOutput {
        TxOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "amount",
                    |m: &TxOutput| { &m.amount },
                    |m: &mut TxOutput| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "to_addr",
                    |m: &TxOutput| { &m.to_addr },
                    |m: &mut TxOutput| { &mut m.to_addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "frozen_height",
                    |m: &TxOutput| { &m.frozen_height },
                    |m: &mut TxOutput| { &mut m.frozen_height },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TxOutput>(
                    "TxOutput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TxOutput {
        static mut instance: ::protobuf::lazy::Lazy<TxOutput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TxOutput::new)
        }
    }
}

impl ::protobuf::Clear for TxOutput {
    fn clear(&mut self) {
        self.amount.clear();
        self.to_addr.clear();
        self.frozen_height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct XuperSignature {
    // message fields
    pub public_keys: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub signature: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a XuperSignature {
    fn default() -> &'a XuperSignature {
        <XuperSignature as ::protobuf::Message>::default_instance()
    }
}

impl XuperSignature {
    pub fn new() -> XuperSignature {
        ::std::default::Default::default()
    }

    // repeated bytes public_keys = 1;


    pub fn get_public_keys(&self) -> &[::std::vec::Vec<u8>] {
        &self.public_keys
    }
    pub fn clear_public_keys(&mut self) {
        self.public_keys.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_keys(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.public_keys = v;
    }

    // Mutable pointer to the field.
    pub fn mut_public_keys(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.public_keys
    }

    // Take field
    pub fn take_public_keys(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.public_keys, ::protobuf::RepeatedField::new())
    }

    // bytes signature = 2;


    pub fn get_signature(&self) -> &[u8] {
        &self.signature
    }
    pub fn clear_signature(&mut self) {
        self.signature.clear();
    }

    // Param is passed by value, moved
    pub fn set_signature(&mut self, v: ::std::vec::Vec<u8>) {
        self.signature = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signature(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.signature
    }

    // Take field
    pub fn take_signature(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.signature, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for XuperSignature {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.public_keys)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.signature)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.public_keys {
            my_size += ::protobuf::rt::bytes_size(1, &value);
        };
        if !self.signature.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.signature);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.public_keys {
            os.write_bytes(1, &v)?;
        };
        if !self.signature.is_empty() {
            os.write_bytes(2, &self.signature)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> XuperSignature {
        XuperSignature::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "public_keys",
                    |m: &XuperSignature| { &m.public_keys },
                    |m: &mut XuperSignature| { &mut m.public_keys },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "signature",
                    |m: &XuperSignature| { &m.signature },
                    |m: &mut XuperSignature| { &mut m.signature },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<XuperSignature>(
                    "XuperSignature",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static XuperSignature {
        static mut instance: ::protobuf::lazy::Lazy<XuperSignature> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(XuperSignature::new)
        }
    }
}

impl ::protobuf::Clear for XuperSignature {
    fn clear(&mut self) {
        self.public_keys.clear();
        self.signature.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for XuperSignature {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for XuperSignature {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Transaction {
    // message fields
    pub txid: ::std::vec::Vec<u8>,
    pub blockid: ::std::vec::Vec<u8>,
    pub tx_inputs: ::protobuf::RepeatedField<TxInput>,
    #[serde(skip_serializing_if = "crate::wallet::is_empty")]
    pub tx_outputs: ::protobuf::RepeatedField<TxOutput>,
    pub desc: ::std::vec::Vec<u8>,
    pub coinbase: bool,
    pub nonce: ::std::string::String,
    pub timestamp: i64,
    pub version: i32,
    pub autogen: bool,
    pub tx_inputs_ext: ::protobuf::RepeatedField<TxInputExt>,
    pub tx_outputs_ext: ::protobuf::RepeatedField<TxOutputExt>,
    #[serde(skip_serializing_if = "crate::wallet::is_empty")]
    pub contract_requests: ::protobuf::RepeatedField<InvokeRequest>,
    pub initiator: ::std::string::String,
    #[serde(skip_serializing_if = "crate::wallet::is_empty")]
    pub auth_require: ::protobuf::RepeatedField<::std::string::String>,
    #[serde(skip_serializing_if = "crate::wallet::is_empty")]
    pub initiator_signs: ::protobuf::RepeatedField<SignatureInfo>,
    #[serde(skip_serializing_if = "crate::wallet::is_empty")]
    pub auth_require_signs: ::protobuf::RepeatedField<SignatureInfo>,
    pub received_timestamp: i64,
    pub xuper_sign: ::protobuf::SingularPtrField<XuperSignature>,
    pub modify_block: ::protobuf::SingularPtrField<ModifyBlock>,
    pub HD_info: ::protobuf::SingularPtrField<HDInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Transaction {
    fn default() -> &'a Transaction {
        <Transaction as ::protobuf::Message>::default_instance()
    }
}

impl Transaction {
    pub fn new() -> Transaction {
        ::std::default::Default::default()
    }

    // bytes txid = 1;


    pub fn get_txid(&self) -> &[u8] {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.txid, ::std::vec::Vec::new())
    }

    // bytes blockid = 2;


    pub fn get_blockid(&self) -> &[u8] {
        &self.blockid
    }
    pub fn clear_blockid(&mut self) {
        self.blockid.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockid(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blockid
    }

    // Take field
    pub fn take_blockid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blockid, ::std::vec::Vec::new())
    }

    // repeated .pb.TxInput tx_inputs = 3;


    pub fn get_tx_inputs(&self) -> &[TxInput] {
        &self.tx_inputs
    }
    pub fn clear_tx_inputs(&mut self) {
        self.tx_inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_inputs(&mut self, v: ::protobuf::RepeatedField<TxInput>) {
        self.tx_inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tx_inputs(&mut self) -> &mut ::protobuf::RepeatedField<TxInput> {
        &mut self.tx_inputs
    }

    // Take field
    pub fn take_tx_inputs(&mut self) -> ::protobuf::RepeatedField<TxInput> {
        ::std::mem::replace(&mut self.tx_inputs, ::protobuf::RepeatedField::new())
    }

    // repeated .pb.TxOutput tx_outputs = 4;


    pub fn get_tx_outputs(&self) -> &[TxOutput] {
        &self.tx_outputs
    }
    pub fn clear_tx_outputs(&mut self) {
        self.tx_outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_outputs(&mut self, v: ::protobuf::RepeatedField<TxOutput>) {
        self.tx_outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tx_outputs(&mut self) -> &mut ::protobuf::RepeatedField<TxOutput> {
        &mut self.tx_outputs
    }

    // Take field
    pub fn take_tx_outputs(&mut self) -> ::protobuf::RepeatedField<TxOutput> {
        ::std::mem::replace(&mut self.tx_outputs, ::protobuf::RepeatedField::new())
    }

    // bytes desc = 6;


    pub fn get_desc(&self) -> &[u8] {
        &self.desc
    }
    pub fn clear_desc(&mut self) {
        self.desc.clear();
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::vec::Vec<u8>) {
        self.desc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.desc
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.desc, ::std::vec::Vec::new())
    }

    // bool coinbase = 7;


    pub fn get_coinbase(&self) -> bool {
        self.coinbase
    }
    pub fn clear_coinbase(&mut self) {
        self.coinbase = false;
    }

    // Param is passed by value, moved
    pub fn set_coinbase(&mut self, v: bool) {
        self.coinbase = v;
    }

    // string nonce = 8;


    pub fn get_nonce(&self) -> &str {
        &self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce.clear();
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: ::std::string::String) {
        self.nonce = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_nonce(&mut self) -> &mut ::std::string::String {
        &mut self.nonce
    }

    // Take field
    pub fn take_nonce(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.nonce, ::std::string::String::new())
    }

    // int64 timestamp = 9;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // int32 version = 10;


    pub fn get_version(&self) -> i32 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = v;
    }

    // bool autogen = 11;


    pub fn get_autogen(&self) -> bool {
        self.autogen
    }
    pub fn clear_autogen(&mut self) {
        self.autogen = false;
    }

    // Param is passed by value, moved
    pub fn set_autogen(&mut self, v: bool) {
        self.autogen = v;
    }

    // repeated .pb.TxInputExt tx_inputs_ext = 23;


    pub fn get_tx_inputs_ext(&self) -> &[TxInputExt] {
        &self.tx_inputs_ext
    }
    pub fn clear_tx_inputs_ext(&mut self) {
        self.tx_inputs_ext.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_inputs_ext(&mut self, v: ::protobuf::RepeatedField<TxInputExt>) {
        self.tx_inputs_ext = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tx_inputs_ext(&mut self) -> &mut ::protobuf::RepeatedField<TxInputExt> {
        &mut self.tx_inputs_ext
    }

    // Take field
    pub fn take_tx_inputs_ext(&mut self) -> ::protobuf::RepeatedField<TxInputExt> {
        ::std::mem::replace(&mut self.tx_inputs_ext, ::protobuf::RepeatedField::new())
    }

    // repeated .pb.TxOutputExt tx_outputs_ext = 24;


    pub fn get_tx_outputs_ext(&self) -> &[TxOutputExt] {
        &self.tx_outputs_ext
    }
    pub fn clear_tx_outputs_ext(&mut self) {
        self.tx_outputs_ext.clear();
    }

    // Param is passed by value, moved
    pub fn set_tx_outputs_ext(&mut self, v: ::protobuf::RepeatedField<TxOutputExt>) {
        self.tx_outputs_ext = v;
    }

    // Mutable pointer to the field.
    pub fn mut_tx_outputs_ext(&mut self) -> &mut ::protobuf::RepeatedField<TxOutputExt> {
        &mut self.tx_outputs_ext
    }

    // Take field
    pub fn take_tx_outputs_ext(&mut self) -> ::protobuf::RepeatedField<TxOutputExt> {
        ::std::mem::replace(&mut self.tx_outputs_ext, ::protobuf::RepeatedField::new())
    }

    // repeated .pb.InvokeRequest contract_requests = 25;


    pub fn get_contract_requests(&self) -> &[InvokeRequest] {
        &self.contract_requests
    }
    pub fn clear_contract_requests(&mut self) {
        self.contract_requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_requests(&mut self, v: ::protobuf::RepeatedField<InvokeRequest>) {
        self.contract_requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contract_requests(&mut self) -> &mut ::protobuf::RepeatedField<InvokeRequest> {
        &mut self.contract_requests
    }

    // Take field
    pub fn take_contract_requests(&mut self) -> ::protobuf::RepeatedField<InvokeRequest> {
        ::std::mem::replace(&mut self.contract_requests, ::protobuf::RepeatedField::new())
    }

    // string initiator = 26;


    pub fn get_initiator(&self) -> &str {
        &self.initiator
    }
    pub fn clear_initiator(&mut self) {
        self.initiator.clear();
    }

    // Param is passed by value, moved
    pub fn set_initiator(&mut self, v: ::std::string::String) {
        self.initiator = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initiator(&mut self) -> &mut ::std::string::String {
        &mut self.initiator
    }

    // Take field
    pub fn take_initiator(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.initiator, ::std::string::String::new())
    }

    // repeated string auth_require = 27;


    pub fn get_auth_require(&self) -> &[::std::string::String] {
        &self.auth_require
    }
    pub fn clear_auth_require(&mut self) {
        self.auth_require.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_require(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.auth_require = v;
    }

    // Mutable pointer to the field.
    pub fn mut_auth_require(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.auth_require
    }

    // Take field
    pub fn take_auth_require(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.auth_require, ::protobuf::RepeatedField::new())
    }

    // repeated .pb.SignatureInfo initiator_signs = 28;


    pub fn get_initiator_signs(&self) -> &[SignatureInfo] {
        &self.initiator_signs
    }
    pub fn clear_initiator_signs(&mut self) {
        self.initiator_signs.clear();
    }

    // Param is passed by value, moved
    pub fn set_initiator_signs(&mut self, v: ::protobuf::RepeatedField<SignatureInfo>) {
        self.initiator_signs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_initiator_signs(&mut self) -> &mut ::protobuf::RepeatedField<SignatureInfo> {
        &mut self.initiator_signs
    }

    // Take field
    pub fn take_initiator_signs(&mut self) -> ::protobuf::RepeatedField<SignatureInfo> {
        ::std::mem::replace(&mut self.initiator_signs, ::protobuf::RepeatedField::new())
    }

    // repeated .pb.SignatureInfo auth_require_signs = 29;


    pub fn get_auth_require_signs(&self) -> &[SignatureInfo] {
        &self.auth_require_signs
    }
    pub fn clear_auth_require_signs(&mut self) {
        self.auth_require_signs.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_require_signs(&mut self, v: ::protobuf::RepeatedField<SignatureInfo>) {
        self.auth_require_signs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_auth_require_signs(&mut self) -> &mut ::protobuf::RepeatedField<SignatureInfo> {
        &mut self.auth_require_signs
    }

    // Take field
    pub fn take_auth_require_signs(&mut self) -> ::protobuf::RepeatedField<SignatureInfo> {
        ::std::mem::replace(&mut self.auth_require_signs, ::protobuf::RepeatedField::new())
    }

    // int64 received_timestamp = 30;


    pub fn get_received_timestamp(&self) -> i64 {
        self.received_timestamp
    }
    pub fn clear_received_timestamp(&mut self) {
        self.received_timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_received_timestamp(&mut self, v: i64) {
        self.received_timestamp = v;
    }

    // .pb.XuperSignature xuper_sign = 31;


    pub fn get_xuper_sign(&self) -> &XuperSignature {
        self.xuper_sign.as_ref().unwrap_or_else(|| XuperSignature::default_instance())
    }
    pub fn clear_xuper_sign(&mut self) {
        self.xuper_sign.clear();
    }

    pub fn has_xuper_sign(&self) -> bool {
        self.xuper_sign.is_some()
    }

    // Param is passed by value, moved
    pub fn set_xuper_sign(&mut self, v: XuperSignature) {
        self.xuper_sign = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_xuper_sign(&mut self) -> &mut XuperSignature {
        if self.xuper_sign.is_none() {
            self.xuper_sign.set_default();
        }
        self.xuper_sign.as_mut().unwrap()
    }

    // Take field
    pub fn take_xuper_sign(&mut self) -> XuperSignature {
        self.xuper_sign.take().unwrap_or_else(|| XuperSignature::new())
    }

    // .pb.ModifyBlock modify_block = 32;


    pub fn get_modify_block(&self) -> &ModifyBlock {
        self.modify_block.as_ref().unwrap_or_else(|| ModifyBlock::default_instance())
    }
    pub fn clear_modify_block(&mut self) {
        self.modify_block.clear();
    }

    pub fn has_modify_block(&self) -> bool {
        self.modify_block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_modify_block(&mut self, v: ModifyBlock) {
        self.modify_block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_modify_block(&mut self) -> &mut ModifyBlock {
        if self.modify_block.is_none() {
            self.modify_block.set_default();
        }
        self.modify_block.as_mut().unwrap()
    }

    // Take field
    pub fn take_modify_block(&mut self) -> ModifyBlock {
        self.modify_block.take().unwrap_or_else(|| ModifyBlock::new())
    }

    // .pb.HDInfo HD_info = 33;


    pub fn get_HD_info(&self) -> &HDInfo {
        self.HD_info.as_ref().unwrap_or_else(|| HDInfo::default_instance())
    }
    pub fn clear_HD_info(&mut self) {
        self.HD_info.clear();
    }

    pub fn has_HD_info(&self) -> bool {
        self.HD_info.is_some()
    }

    // Param is passed by value, moved
    pub fn set_HD_info(&mut self, v: HDInfo) {
        self.HD_info = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_HD_info(&mut self) -> &mut HDInfo {
        if self.HD_info.is_none() {
            self.HD_info.set_default();
        }
        self.HD_info.as_mut().unwrap()
    }

    // Take field
    pub fn take_HD_info(&mut self) -> HDInfo {
        self.HD_info.take().unwrap_or_else(|| HDInfo::new())
    }
}

impl ::protobuf::Message for Transaction {
    fn is_initialized(&self) -> bool {
        for v in &self.tx_inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tx_outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tx_inputs_ext {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.tx_outputs_ext {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contract_requests {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.initiator_signs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.auth_require_signs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.xuper_sign {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.modify_block {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.HD_info {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.txid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blockid)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tx_inputs)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tx_outputs)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.desc)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.coinbase = tmp;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.nonce)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.autogen = tmp;
                },
                23 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tx_inputs_ext)?;
                },
                24 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.tx_outputs_ext)?;
                },
                25 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.contract_requests)?;
                },
                26 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.initiator)?;
                },
                27 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.auth_require)?;
                },
                28 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.initiator_signs)?;
                },
                29 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.auth_require_signs)?;
                },
                30 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.received_timestamp = tmp;
                },
                31 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.xuper_sign)?;
                },
                32 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.modify_block)?;
                },
                33 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.HD_info)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.txid);
        }
        if !self.blockid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.blockid);
        }
        for value in &self.tx_inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tx_outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.desc.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.desc);
        }
        if self.coinbase != false {
            my_size += 2;
        }
        if !self.nonce.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.nonce);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(9, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(10, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.autogen != false {
            my_size += 2;
        }
        for value in &self.tx_inputs_ext {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.tx_outputs_ext {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.contract_requests {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.initiator.is_empty() {
            my_size += ::protobuf::rt::string_size(26, &self.initiator);
        }
        for value in &self.auth_require {
            my_size += ::protobuf::rt::string_size(27, &value);
        };
        for value in &self.initiator_signs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.auth_require_signs {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.received_timestamp != 0 {
            my_size += ::protobuf::rt::value_size(30, self.received_timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.xuper_sign.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.modify_block.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.HD_info.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.txid.is_empty() {
            os.write_bytes(1, &self.txid)?;
        }
        if !self.blockid.is_empty() {
            os.write_bytes(2, &self.blockid)?;
        }
        for v in &self.tx_inputs {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tx_outputs {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.desc.is_empty() {
            os.write_bytes(6, &self.desc)?;
        }
        if self.coinbase != false {
            os.write_bool(7, self.coinbase)?;
        }
        if !self.nonce.is_empty() {
            os.write_string(8, &self.nonce)?;
        }
        if self.timestamp != 0 {
            os.write_int64(9, self.timestamp)?;
        }
        if self.version != 0 {
            os.write_int32(10, self.version)?;
        }
        if self.autogen != false {
            os.write_bool(11, self.autogen)?;
        }
        for v in &self.tx_inputs_ext {
            os.write_tag(23, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.tx_outputs_ext {
            os.write_tag(24, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.contract_requests {
            os.write_tag(25, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.initiator.is_empty() {
            os.write_string(26, &self.initiator)?;
        }
        for v in &self.auth_require {
            os.write_string(27, &v)?;
        };
        for v in &self.initiator_signs {
            os.write_tag(28, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.auth_require_signs {
            os.write_tag(29, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.received_timestamp != 0 {
            os.write_int64(30, self.received_timestamp)?;
        }
        if let Some(ref v) = self.xuper_sign.as_ref() {
            os.write_tag(31, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.modify_block.as_ref() {
            os.write_tag(32, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.HD_info.as_ref() {
            os.write_tag(33, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Transaction {
        Transaction::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "txid",
                    |m: &Transaction| { &m.txid },
                    |m: &mut Transaction| { &mut m.txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "blockid",
                    |m: &Transaction| { &m.blockid },
                    |m: &mut Transaction| { &mut m.blockid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TxInput>>(
                    "tx_inputs",
                    |m: &Transaction| { &m.tx_inputs },
                    |m: &mut Transaction| { &mut m.tx_inputs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TxOutput>>(
                    "tx_outputs",
                    |m: &Transaction| { &m.tx_outputs },
                    |m: &mut Transaction| { &mut m.tx_outputs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "desc",
                    |m: &Transaction| { &m.desc },
                    |m: &mut Transaction| { &mut m.desc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "coinbase",
                    |m: &Transaction| { &m.coinbase },
                    |m: &mut Transaction| { &mut m.coinbase },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "nonce",
                    |m: &Transaction| { &m.nonce },
                    |m: &mut Transaction| { &mut m.nonce },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timestamp",
                    |m: &Transaction| { &m.timestamp },
                    |m: &mut Transaction| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "version",
                    |m: &Transaction| { &m.version },
                    |m: &mut Transaction| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "autogen",
                    |m: &Transaction| { &m.autogen },
                    |m: &mut Transaction| { &mut m.autogen },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TxInputExt>>(
                    "tx_inputs_ext",
                    |m: &Transaction| { &m.tx_inputs_ext },
                    |m: &mut Transaction| { &mut m.tx_inputs_ext },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TxOutputExt>>(
                    "tx_outputs_ext",
                    |m: &Transaction| { &m.tx_outputs_ext },
                    |m: &mut Transaction| { &mut m.tx_outputs_ext },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InvokeRequest>>(
                    "contract_requests",
                    |m: &Transaction| { &m.contract_requests },
                    |m: &mut Transaction| { &mut m.contract_requests },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "initiator",
                    |m: &Transaction| { &m.initiator },
                    |m: &mut Transaction| { &mut m.initiator },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "auth_require",
                    |m: &Transaction| { &m.auth_require },
                    |m: &mut Transaction| { &mut m.auth_require },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignatureInfo>>(
                    "initiator_signs",
                    |m: &Transaction| { &m.initiator_signs },
                    |m: &mut Transaction| { &mut m.initiator_signs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignatureInfo>>(
                    "auth_require_signs",
                    |m: &Transaction| { &m.auth_require_signs },
                    |m: &mut Transaction| { &mut m.auth_require_signs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "received_timestamp",
                    |m: &Transaction| { &m.received_timestamp },
                    |m: &mut Transaction| { &mut m.received_timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<XuperSignature>>(
                    "xuper_sign",
                    |m: &Transaction| { &m.xuper_sign },
                    |m: &mut Transaction| { &mut m.xuper_sign },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ModifyBlock>>(
                    "modify_block",
                    |m: &Transaction| { &m.modify_block },
                    |m: &mut Transaction| { &mut m.modify_block },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<HDInfo>>(
                    "HD_info",
                    |m: &Transaction| { &m.HD_info },
                    |m: &mut Transaction| { &mut m.HD_info },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Transaction>(
                    "Transaction",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Transaction {
        static mut instance: ::protobuf::lazy::Lazy<Transaction> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Transaction::new)
        }
    }
}

impl ::protobuf::Clear for Transaction {
    fn clear(&mut self) {
        self.txid.clear();
        self.blockid.clear();
        self.tx_inputs.clear();
        self.tx_outputs.clear();
        self.desc.clear();
        self.coinbase = false;
        self.nonce.clear();
        self.timestamp = 0;
        self.version = 0;
        self.autogen = false;
        self.tx_inputs_ext.clear();
        self.tx_outputs_ext.clear();
        self.contract_requests.clear();
        self.initiator.clear();
        self.auth_require.clear();
        self.initiator_signs.clear();
        self.auth_require_signs.clear();
        self.received_timestamp = 0;
        self.xuper_sign.clear();
        self.modify_block.clear();
        self.HD_info.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Transaction {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Transaction {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct LedgerMeta {
    // message fields
    pub root_blockid: ::std::vec::Vec<u8>,
    pub tip_blockid: ::std::vec::Vec<u8>,
    pub trunk_height: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a LedgerMeta {
    fn default() -> &'a LedgerMeta {
        <LedgerMeta as ::protobuf::Message>::default_instance()
    }
}

impl LedgerMeta {
    pub fn new() -> LedgerMeta {
        ::std::default::Default::default()
    }

    // bytes root_blockid = 1;


    pub fn get_root_blockid(&self) -> &[u8] {
        &self.root_blockid
    }
    pub fn clear_root_blockid(&mut self) {
        self.root_blockid.clear();
    }

    // Param is passed by value, moved
    pub fn set_root_blockid(&mut self, v: ::std::vec::Vec<u8>) {
        self.root_blockid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_root_blockid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.root_blockid
    }

    // Take field
    pub fn take_root_blockid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.root_blockid, ::std::vec::Vec::new())
    }

    // bytes tip_blockid = 2;


    pub fn get_tip_blockid(&self) -> &[u8] {
        &self.tip_blockid
    }
    pub fn clear_tip_blockid(&mut self) {
        self.tip_blockid.clear();
    }

    // Param is passed by value, moved
    pub fn set_tip_blockid(&mut self, v: ::std::vec::Vec<u8>) {
        self.tip_blockid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_tip_blockid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.tip_blockid
    }

    // Take field
    pub fn take_tip_blockid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.tip_blockid, ::std::vec::Vec::new())
    }

    // int64 trunk_height = 3;


    pub fn get_trunk_height(&self) -> i64 {
        self.trunk_height
    }
    pub fn clear_trunk_height(&mut self) {
        self.trunk_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_trunk_height(&mut self, v: i64) {
        self.trunk_height = v;
    }
}

impl ::protobuf::Message for LedgerMeta {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.root_blockid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.tip_blockid)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.trunk_height = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.root_blockid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.root_blockid);
        }
        if !self.tip_blockid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.tip_blockid);
        }
        if self.trunk_height != 0 {
            my_size += ::protobuf::rt::value_size(3, self.trunk_height, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.root_blockid.is_empty() {
            os.write_bytes(1, &self.root_blockid)?;
        }
        if !self.tip_blockid.is_empty() {
            os.write_bytes(2, &self.tip_blockid)?;
        }
        if self.trunk_height != 0 {
            os.write_int64(3, self.trunk_height)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> LedgerMeta {
        LedgerMeta::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "root_blockid",
                    |m: &LedgerMeta| { &m.root_blockid },
                    |m: &mut LedgerMeta| { &mut m.root_blockid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "tip_blockid",
                    |m: &LedgerMeta| { &m.tip_blockid },
                    |m: &mut LedgerMeta| { &mut m.tip_blockid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "trunk_height",
                    |m: &LedgerMeta| { &m.trunk_height },
                    |m: &mut LedgerMeta| { &mut m.trunk_height },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<LedgerMeta>(
                    "LedgerMeta",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static LedgerMeta {
        static mut instance: ::protobuf::lazy::Lazy<LedgerMeta> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(LedgerMeta::new)
        }
    }
}

impl ::protobuf::Clear for LedgerMeta {
    fn clear(&mut self) {
        self.root_blockid.clear();
        self.tip_blockid.clear();
        self.trunk_height = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for LedgerMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LedgerMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UtxoMeta {
    // message fields
    pub latest_blockid: ::std::vec::Vec<u8>,
    pub lock_key_list: ::protobuf::RepeatedField<::std::string::String>,
    pub utxo_total: ::std::string::String,
    pub avgDelay: i64,
    pub unconfirmTxAmount: i64,
    pub max_block_size: i64,
    pub reserved_contracts: ::protobuf::RepeatedField<InvokeRequest>,
    pub forbidden_contract: ::protobuf::SingularPtrField<InvokeRequest>,
    pub new_account_resource_amount: i64,
    pub irreversibleBlockHeight: i64,
    pub irreversibleSlideWindow: i64,
    pub gasPrice: ::protobuf::SingularPtrField<GasPrice>,
    pub group_chain_contract: ::protobuf::SingularPtrField<InvokeRequest>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UtxoMeta {
    fn default() -> &'a UtxoMeta {
        <UtxoMeta as ::protobuf::Message>::default_instance()
    }
}

impl UtxoMeta {
    pub fn new() -> UtxoMeta {
        ::std::default::Default::default()
    }

    // bytes latest_blockid = 1;


    pub fn get_latest_blockid(&self) -> &[u8] {
        &self.latest_blockid
    }
    pub fn clear_latest_blockid(&mut self) {
        self.latest_blockid.clear();
    }

    // Param is passed by value, moved
    pub fn set_latest_blockid(&mut self, v: ::std::vec::Vec<u8>) {
        self.latest_blockid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_latest_blockid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.latest_blockid
    }

    // Take field
    pub fn take_latest_blockid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.latest_blockid, ::std::vec::Vec::new())
    }

    // repeated string lock_key_list = 2;


    pub fn get_lock_key_list(&self) -> &[::std::string::String] {
        &self.lock_key_list
    }
    pub fn clear_lock_key_list(&mut self) {
        self.lock_key_list.clear();
    }

    // Param is passed by value, moved
    pub fn set_lock_key_list(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.lock_key_list = v;
    }

    // Mutable pointer to the field.
    pub fn mut_lock_key_list(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.lock_key_list
    }

    // Take field
    pub fn take_lock_key_list(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.lock_key_list, ::protobuf::RepeatedField::new())
    }

    // string utxo_total = 3;


    pub fn get_utxo_total(&self) -> &str {
        &self.utxo_total
    }
    pub fn clear_utxo_total(&mut self) {
        self.utxo_total.clear();
    }

    // Param is passed by value, moved
    pub fn set_utxo_total(&mut self, v: ::std::string::String) {
        self.utxo_total = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_utxo_total(&mut self) -> &mut ::std::string::String {
        &mut self.utxo_total
    }

    // Take field
    pub fn take_utxo_total(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.utxo_total, ::std::string::String::new())
    }

    // int64 avgDelay = 4;


    pub fn get_avgDelay(&self) -> i64 {
        self.avgDelay
    }
    pub fn clear_avgDelay(&mut self) {
        self.avgDelay = 0;
    }

    // Param is passed by value, moved
    pub fn set_avgDelay(&mut self, v: i64) {
        self.avgDelay = v;
    }

    // int64 unconfirmTxAmount = 5;


    pub fn get_unconfirmTxAmount(&self) -> i64 {
        self.unconfirmTxAmount
    }
    pub fn clear_unconfirmTxAmount(&mut self) {
        self.unconfirmTxAmount = 0;
    }

    // Param is passed by value, moved
    pub fn set_unconfirmTxAmount(&mut self, v: i64) {
        self.unconfirmTxAmount = v;
    }

    // int64 max_block_size = 6;


    pub fn get_max_block_size(&self) -> i64 {
        self.max_block_size
    }
    pub fn clear_max_block_size(&mut self) {
        self.max_block_size = 0;
    }

    // Param is passed by value, moved
    pub fn set_max_block_size(&mut self, v: i64) {
        self.max_block_size = v;
    }

    // repeated .pb.InvokeRequest reserved_contracts = 7;


    pub fn get_reserved_contracts(&self) -> &[InvokeRequest] {
        &self.reserved_contracts
    }
    pub fn clear_reserved_contracts(&mut self) {
        self.reserved_contracts.clear();
    }

    // Param is passed by value, moved
    pub fn set_reserved_contracts(&mut self, v: ::protobuf::RepeatedField<InvokeRequest>) {
        self.reserved_contracts = v;
    }

    // Mutable pointer to the field.
    pub fn mut_reserved_contracts(&mut self) -> &mut ::protobuf::RepeatedField<InvokeRequest> {
        &mut self.reserved_contracts
    }

    // Take field
    pub fn take_reserved_contracts(&mut self) -> ::protobuf::RepeatedField<InvokeRequest> {
        ::std::mem::replace(&mut self.reserved_contracts, ::protobuf::RepeatedField::new())
    }

    // .pb.InvokeRequest forbidden_contract = 8;


    pub fn get_forbidden_contract(&self) -> &InvokeRequest {
        self.forbidden_contract.as_ref().unwrap_or_else(|| InvokeRequest::default_instance())
    }
    pub fn clear_forbidden_contract(&mut self) {
        self.forbidden_contract.clear();
    }

    pub fn has_forbidden_contract(&self) -> bool {
        self.forbidden_contract.is_some()
    }

    // Param is passed by value, moved
    pub fn set_forbidden_contract(&mut self, v: InvokeRequest) {
        self.forbidden_contract = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_forbidden_contract(&mut self) -> &mut InvokeRequest {
        if self.forbidden_contract.is_none() {
            self.forbidden_contract.set_default();
        }
        self.forbidden_contract.as_mut().unwrap()
    }

    // Take field
    pub fn take_forbidden_contract(&mut self) -> InvokeRequest {
        self.forbidden_contract.take().unwrap_or_else(|| InvokeRequest::new())
    }

    // int64 new_account_resource_amount = 9;


    pub fn get_new_account_resource_amount(&self) -> i64 {
        self.new_account_resource_amount
    }
    pub fn clear_new_account_resource_amount(&mut self) {
        self.new_account_resource_amount = 0;
    }

    // Param is passed by value, moved
    pub fn set_new_account_resource_amount(&mut self, v: i64) {
        self.new_account_resource_amount = v;
    }

    // int64 irreversibleBlockHeight = 10;


    pub fn get_irreversibleBlockHeight(&self) -> i64 {
        self.irreversibleBlockHeight
    }
    pub fn clear_irreversibleBlockHeight(&mut self) {
        self.irreversibleBlockHeight = 0;
    }

    // Param is passed by value, moved
    pub fn set_irreversibleBlockHeight(&mut self, v: i64) {
        self.irreversibleBlockHeight = v;
    }

    // int64 irreversibleSlideWindow = 11;


    pub fn get_irreversibleSlideWindow(&self) -> i64 {
        self.irreversibleSlideWindow
    }
    pub fn clear_irreversibleSlideWindow(&mut self) {
        self.irreversibleSlideWindow = 0;
    }

    // Param is passed by value, moved
    pub fn set_irreversibleSlideWindow(&mut self, v: i64) {
        self.irreversibleSlideWindow = v;
    }

    // .pb.GasPrice gasPrice = 12;


    pub fn get_gasPrice(&self) -> &GasPrice {
        self.gasPrice.as_ref().unwrap_or_else(|| GasPrice::default_instance())
    }
    pub fn clear_gasPrice(&mut self) {
        self.gasPrice.clear();
    }

    pub fn has_gasPrice(&self) -> bool {
        self.gasPrice.is_some()
    }

    // Param is passed by value, moved
    pub fn set_gasPrice(&mut self, v: GasPrice) {
        self.gasPrice = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_gasPrice(&mut self) -> &mut GasPrice {
        if self.gasPrice.is_none() {
            self.gasPrice.set_default();
        }
        self.gasPrice.as_mut().unwrap()
    }

    // Take field
    pub fn take_gasPrice(&mut self) -> GasPrice {
        self.gasPrice.take().unwrap_or_else(|| GasPrice::new())
    }

    // .pb.InvokeRequest group_chain_contract = 13;


    pub fn get_group_chain_contract(&self) -> &InvokeRequest {
        self.group_chain_contract.as_ref().unwrap_or_else(|| InvokeRequest::default_instance())
    }
    pub fn clear_group_chain_contract(&mut self) {
        self.group_chain_contract.clear();
    }

    pub fn has_group_chain_contract(&self) -> bool {
        self.group_chain_contract.is_some()
    }

    // Param is passed by value, moved
    pub fn set_group_chain_contract(&mut self, v: InvokeRequest) {
        self.group_chain_contract = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_group_chain_contract(&mut self) -> &mut InvokeRequest {
        if self.group_chain_contract.is_none() {
            self.group_chain_contract.set_default();
        }
        self.group_chain_contract.as_mut().unwrap()
    }

    // Take field
    pub fn take_group_chain_contract(&mut self) -> InvokeRequest {
        self.group_chain_contract.take().unwrap_or_else(|| InvokeRequest::new())
    }
}

impl ::protobuf::Message for UtxoMeta {
    fn is_initialized(&self) -> bool {
        for v in &self.reserved_contracts {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.forbidden_contract {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.gasPrice {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.group_chain_contract {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.latest_blockid)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.lock_key_list)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.utxo_total)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.avgDelay = tmp;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.unconfirmTxAmount = tmp;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.max_block_size = tmp;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.reserved_contracts)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.forbidden_contract)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.new_account_resource_amount = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.irreversibleBlockHeight = tmp;
                },
                11 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.irreversibleSlideWindow = tmp;
                },
                12 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.gasPrice)?;
                },
                13 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.group_chain_contract)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.latest_blockid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.latest_blockid);
        }
        for value in &self.lock_key_list {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if !self.utxo_total.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.utxo_total);
        }
        if self.avgDelay != 0 {
            my_size += ::protobuf::rt::value_size(4, self.avgDelay, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.unconfirmTxAmount != 0 {
            my_size += ::protobuf::rt::value_size(5, self.unconfirmTxAmount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.max_block_size != 0 {
            my_size += ::protobuf::rt::value_size(6, self.max_block_size, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.reserved_contracts {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.forbidden_contract.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.new_account_resource_amount != 0 {
            my_size += ::protobuf::rt::value_size(9, self.new_account_resource_amount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.irreversibleBlockHeight != 0 {
            my_size += ::protobuf::rt::value_size(10, self.irreversibleBlockHeight, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.irreversibleSlideWindow != 0 {
            my_size += ::protobuf::rt::value_size(11, self.irreversibleSlideWindow, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.gasPrice.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.group_chain_contract.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.latest_blockid.is_empty() {
            os.write_bytes(1, &self.latest_blockid)?;
        }
        for v in &self.lock_key_list {
            os.write_string(2, &v)?;
        };
        if !self.utxo_total.is_empty() {
            os.write_string(3, &self.utxo_total)?;
        }
        if self.avgDelay != 0 {
            os.write_int64(4, self.avgDelay)?;
        }
        if self.unconfirmTxAmount != 0 {
            os.write_int64(5, self.unconfirmTxAmount)?;
        }
        if self.max_block_size != 0 {
            os.write_int64(6, self.max_block_size)?;
        }
        for v in &self.reserved_contracts {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.forbidden_contract.as_ref() {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.new_account_resource_amount != 0 {
            os.write_int64(9, self.new_account_resource_amount)?;
        }
        if self.irreversibleBlockHeight != 0 {
            os.write_int64(10, self.irreversibleBlockHeight)?;
        }
        if self.irreversibleSlideWindow != 0 {
            os.write_int64(11, self.irreversibleSlideWindow)?;
        }
        if let Some(ref v) = self.gasPrice.as_ref() {
            os.write_tag(12, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.group_chain_contract.as_ref() {
            os.write_tag(13, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UtxoMeta {
        UtxoMeta::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "latest_blockid",
                    |m: &UtxoMeta| { &m.latest_blockid },
                    |m: &mut UtxoMeta| { &mut m.latest_blockid },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "lock_key_list",
                    |m: &UtxoMeta| { &m.lock_key_list },
                    |m: &mut UtxoMeta| { &mut m.lock_key_list },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "utxo_total",
                    |m: &UtxoMeta| { &m.utxo_total },
                    |m: &mut UtxoMeta| { &mut m.utxo_total },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "avgDelay",
                    |m: &UtxoMeta| { &m.avgDelay },
                    |m: &mut UtxoMeta| { &mut m.avgDelay },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "unconfirmTxAmount",
                    |m: &UtxoMeta| { &m.unconfirmTxAmount },
                    |m: &mut UtxoMeta| { &mut m.unconfirmTxAmount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "max_block_size",
                    |m: &UtxoMeta| { &m.max_block_size },
                    |m: &mut UtxoMeta| { &mut m.max_block_size },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InvokeRequest>>(
                    "reserved_contracts",
                    |m: &UtxoMeta| { &m.reserved_contracts },
                    |m: &mut UtxoMeta| { &mut m.reserved_contracts },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InvokeRequest>>(
                    "forbidden_contract",
                    |m: &UtxoMeta| { &m.forbidden_contract },
                    |m: &mut UtxoMeta| { &mut m.forbidden_contract },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "new_account_resource_amount",
                    |m: &UtxoMeta| { &m.new_account_resource_amount },
                    |m: &mut UtxoMeta| { &mut m.new_account_resource_amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "irreversibleBlockHeight",
                    |m: &UtxoMeta| { &m.irreversibleBlockHeight },
                    |m: &mut UtxoMeta| { &mut m.irreversibleBlockHeight },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "irreversibleSlideWindow",
                    |m: &UtxoMeta| { &m.irreversibleSlideWindow },
                    |m: &mut UtxoMeta| { &mut m.irreversibleSlideWindow },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<GasPrice>>(
                    "gasPrice",
                    |m: &UtxoMeta| { &m.gasPrice },
                    |m: &mut UtxoMeta| { &mut m.gasPrice },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InvokeRequest>>(
                    "group_chain_contract",
                    |m: &UtxoMeta| { &m.group_chain_contract },
                    |m: &mut UtxoMeta| { &mut m.group_chain_contract },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UtxoMeta>(
                    "UtxoMeta",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UtxoMeta {
        static mut instance: ::protobuf::lazy::Lazy<UtxoMeta> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UtxoMeta::new)
        }
    }
}

impl ::protobuf::Clear for UtxoMeta {
    fn clear(&mut self) {
        self.latest_blockid.clear();
        self.lock_key_list.clear();
        self.utxo_total.clear();
        self.avgDelay = 0;
        self.unconfirmTxAmount = 0;
        self.max_block_size = 0;
        self.reserved_contracts.clear();
        self.forbidden_contract.clear();
        self.new_account_resource_amount = 0;
        self.irreversibleBlockHeight = 0;
        self.irreversibleSlideWindow = 0;
        self.gasPrice.clear();
        self.group_chain_contract.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UtxoMeta {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UtxoMeta {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GasPrice {
    // message fields
    pub cpu_rate: i64,
    pub mem_rate: i64,
    pub disk_rate: i64,
    pub xfee_rate: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GasPrice {
    fn default() -> &'a GasPrice {
        <GasPrice as ::protobuf::Message>::default_instance()
    }
}

impl GasPrice {
    pub fn new() -> GasPrice {
        ::std::default::Default::default()
    }

    // int64 cpu_rate = 1;


    pub fn get_cpu_rate(&self) -> i64 {
        self.cpu_rate
    }
    pub fn clear_cpu_rate(&mut self) {
        self.cpu_rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_cpu_rate(&mut self, v: i64) {
        self.cpu_rate = v;
    }

    // int64 mem_rate = 2;


    pub fn get_mem_rate(&self) -> i64 {
        self.mem_rate
    }
    pub fn clear_mem_rate(&mut self) {
        self.mem_rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_mem_rate(&mut self, v: i64) {
        self.mem_rate = v;
    }

    // int64 disk_rate = 3;


    pub fn get_disk_rate(&self) -> i64 {
        self.disk_rate
    }
    pub fn clear_disk_rate(&mut self) {
        self.disk_rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_disk_rate(&mut self, v: i64) {
        self.disk_rate = v;
    }

    // int64 xfee_rate = 4;


    pub fn get_xfee_rate(&self) -> i64 {
        self.xfee_rate
    }
    pub fn clear_xfee_rate(&mut self) {
        self.xfee_rate = 0;
    }

    // Param is passed by value, moved
    pub fn set_xfee_rate(&mut self, v: i64) {
        self.xfee_rate = v;
    }
}

impl ::protobuf::Message for GasPrice {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.cpu_rate = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.mem_rate = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.disk_rate = tmp;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.xfee_rate = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.cpu_rate != 0 {
            my_size += ::protobuf::rt::value_size(1, self.cpu_rate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.mem_rate != 0 {
            my_size += ::protobuf::rt::value_size(2, self.mem_rate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.disk_rate != 0 {
            my_size += ::protobuf::rt::value_size(3, self.disk_rate, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.xfee_rate != 0 {
            my_size += ::protobuf::rt::value_size(4, self.xfee_rate, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.cpu_rate != 0 {
            os.write_int64(1, self.cpu_rate)?;
        }
        if self.mem_rate != 0 {
            os.write_int64(2, self.mem_rate)?;
        }
        if self.disk_rate != 0 {
            os.write_int64(3, self.disk_rate)?;
        }
        if self.xfee_rate != 0 {
            os.write_int64(4, self.xfee_rate)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GasPrice {
        GasPrice::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "cpu_rate",
                    |m: &GasPrice| { &m.cpu_rate },
                    |m: &mut GasPrice| { &mut m.cpu_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "mem_rate",
                    |m: &GasPrice| { &m.mem_rate },
                    |m: &mut GasPrice| { &mut m.mem_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "disk_rate",
                    |m: &GasPrice| { &m.disk_rate },
                    |m: &mut GasPrice| { &mut m.disk_rate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "xfee_rate",
                    |m: &GasPrice| { &m.xfee_rate },
                    |m: &mut GasPrice| { &mut m.xfee_rate },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GasPrice>(
                    "GasPrice",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GasPrice {
        static mut instance: ::protobuf::lazy::Lazy<GasPrice> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GasPrice::new)
        }
    }
}

impl ::protobuf::Clear for GasPrice {
    fn clear(&mut self) {
        self.cpu_rate = 0;
        self.mem_rate = 0;
        self.disk_rate = 0;
        self.xfee_rate = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GasPrice {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GasPrice {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct InternalBlock {
    // message fields
    pub version: i32,
    pub nonce: i32,
    pub blockid: ::std::vec::Vec<u8>,
    pub pre_hash: ::std::vec::Vec<u8>,
    pub proposer: ::std::vec::Vec<u8>,
    pub sign: ::std::vec::Vec<u8>,
    pub pubkey: ::std::vec::Vec<u8>,
    pub merkle_root: ::std::vec::Vec<u8>,
    pub height: i64,
    pub timestamp: i64,
    pub transactions: ::protobuf::RepeatedField<Transaction>,
    pub tx_count: i32,
    pub merkle_tree: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    pub curTerm: i64,
    pub curBlockNum: i64,
    pub failed_txs: ::std::collections::HashMap<::std::string::String, ::std::string::String>,
    pub targetBits: i32,
    pub Justify: ::protobuf::SingularPtrField<super::chainedbft::QuorumCert>,
    pub in_trunk: bool,
    pub next_hash: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InternalBlock {
    fn default() -> &'a InternalBlock {
        <InternalBlock as ::protobuf::Message>::default_instance()
    }
}

impl InternalBlock {
    pub fn new() -> InternalBlock {
        ::std::default::Default::default()
    }

    // int32 version = 1;


    pub fn get_version(&self) -> i32 {
        self.version
    }
    pub fn clear_version(&mut self) {
        self.version = 0;
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: i32) {
        self.version = v;
    }

    // int32 nonce = 2;


    pub fn get_nonce(&self) -> i32 {
        self.nonce
    }
    pub fn clear_nonce(&mut self) {
        self.nonce = 0;
    }

    // Param is passed by value, moved
    pub fn set_nonce(&mut self, v: i32) {
        self.nonce = v;
    }

    // bytes blockid = 3;


    pub fn get_blockid(&self) -> &[u8] {
        &self.blockid
    }
    pub fn clear_blockid(&mut self) {
        self.blockid.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockid(&mut self, v: ::std::vec::Vec<u8>) {
        self.blockid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_blockid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.blockid
    }

    // Take field
    pub fn take_blockid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.blockid, ::std::vec::Vec::new())
    }

    // bytes pre_hash = 4;


    pub fn get_pre_hash(&self) -> &[u8] {
        &self.pre_hash
    }
    pub fn clear_pre_hash(&mut self) {
        self.pre_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_pre_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.pre_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pre_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pre_hash
    }

    // Take field
    pub fn take_pre_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pre_hash, ::std::vec::Vec::new())
    }

    // bytes proposer = 5;


    pub fn get_proposer(&self) -> &[u8] {
        &self.proposer
    }
    pub fn clear_proposer(&mut self) {
        self.proposer.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposer(&mut self, v: ::std::vec::Vec<u8>) {
        self.proposer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposer(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.proposer
    }

    // Take field
    pub fn take_proposer(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.proposer, ::std::vec::Vec::new())
    }

    // bytes sign = 6;


    pub fn get_sign(&self) -> &[u8] {
        &self.sign
    }
    pub fn clear_sign(&mut self) {
        self.sign.clear();
    }

    // Param is passed by value, moved
    pub fn set_sign(&mut self, v: ::std::vec::Vec<u8>) {
        self.sign = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sign(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sign
    }

    // Take field
    pub fn take_sign(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sign, ::std::vec::Vec::new())
    }

    // bytes pubkey = 7;


    pub fn get_pubkey(&self) -> &[u8] {
        &self.pubkey
    }
    pub fn clear_pubkey(&mut self) {
        self.pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pubkey
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pubkey, ::std::vec::Vec::new())
    }

    // bytes merkle_root = 8;


    pub fn get_merkle_root(&self) -> &[u8] {
        &self.merkle_root
    }
    pub fn clear_merkle_root(&mut self) {
        self.merkle_root.clear();
    }

    // Param is passed by value, moved
    pub fn set_merkle_root(&mut self, v: ::std::vec::Vec<u8>) {
        self.merkle_root = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_merkle_root(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.merkle_root
    }

    // Take field
    pub fn take_merkle_root(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.merkle_root, ::std::vec::Vec::new())
    }

    // int64 height = 9;


    pub fn get_height(&self) -> i64 {
        self.height
    }
    pub fn clear_height(&mut self) {
        self.height = 0;
    }

    // Param is passed by value, moved
    pub fn set_height(&mut self, v: i64) {
        self.height = v;
    }

    // int64 timestamp = 10;


    pub fn get_timestamp(&self) -> i64 {
        self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp = 0;
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: i64) {
        self.timestamp = v;
    }

    // repeated .pb.Transaction transactions = 11;


    pub fn get_transactions(&self) -> &[Transaction] {
        &self.transactions
    }
    pub fn clear_transactions(&mut self) {
        self.transactions.clear();
    }

    // Param is passed by value, moved
    pub fn set_transactions(&mut self, v: ::protobuf::RepeatedField<Transaction>) {
        self.transactions = v;
    }

    // Mutable pointer to the field.
    pub fn mut_transactions(&mut self) -> &mut ::protobuf::RepeatedField<Transaction> {
        &mut self.transactions
    }

    // Take field
    pub fn take_transactions(&mut self) -> ::protobuf::RepeatedField<Transaction> {
        ::std::mem::replace(&mut self.transactions, ::protobuf::RepeatedField::new())
    }

    // int32 tx_count = 12;


    pub fn get_tx_count(&self) -> i32 {
        self.tx_count
    }
    pub fn clear_tx_count(&mut self) {
        self.tx_count = 0;
    }

    // Param is passed by value, moved
    pub fn set_tx_count(&mut self, v: i32) {
        self.tx_count = v;
    }

    // repeated bytes merkle_tree = 13;


    pub fn get_merkle_tree(&self) -> &[::std::vec::Vec<u8>] {
        &self.merkle_tree
    }
    pub fn clear_merkle_tree(&mut self) {
        self.merkle_tree.clear();
    }

    // Param is passed by value, moved
    pub fn set_merkle_tree(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.merkle_tree = v;
    }

    // Mutable pointer to the field.
    pub fn mut_merkle_tree(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.merkle_tree
    }

    // Take field
    pub fn take_merkle_tree(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.merkle_tree, ::protobuf::RepeatedField::new())
    }

    // int64 curTerm = 16;


    pub fn get_curTerm(&self) -> i64 {
        self.curTerm
    }
    pub fn clear_curTerm(&mut self) {
        self.curTerm = 0;
    }

    // Param is passed by value, moved
    pub fn set_curTerm(&mut self, v: i64) {
        self.curTerm = v;
    }

    // int64 curBlockNum = 17;


    pub fn get_curBlockNum(&self) -> i64 {
        self.curBlockNum
    }
    pub fn clear_curBlockNum(&mut self) {
        self.curBlockNum = 0;
    }

    // Param is passed by value, moved
    pub fn set_curBlockNum(&mut self, v: i64) {
        self.curBlockNum = v;
    }

    // repeated .pb.InternalBlock.FailedTxsEntry failed_txs = 18;


    pub fn get_failed_txs(&self) -> &::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &self.failed_txs
    }
    pub fn clear_failed_txs(&mut self) {
        self.failed_txs.clear();
    }

    // Param is passed by value, moved
    pub fn set_failed_txs(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::string::String>) {
        self.failed_txs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_failed_txs(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        &mut self.failed_txs
    }

    // Take field
    pub fn take_failed_txs(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::string::String> {
        ::std::mem::replace(&mut self.failed_txs, ::std::collections::HashMap::new())
    }

    // int32 targetBits = 19;


    pub fn get_targetBits(&self) -> i32 {
        self.targetBits
    }
    pub fn clear_targetBits(&mut self) {
        self.targetBits = 0;
    }

    // Param is passed by value, moved
    pub fn set_targetBits(&mut self, v: i32) {
        self.targetBits = v;
    }

    // .pb.QuorumCert Justify = 20;


    pub fn get_Justify(&self) -> &super::chainedbft::QuorumCert {
        self.Justify.as_ref().unwrap_or_else(|| super::chainedbft::QuorumCert::default_instance())
    }
    pub fn clear_Justify(&mut self) {
        self.Justify.clear();
    }

    pub fn has_Justify(&self) -> bool {
        self.Justify.is_some()
    }

    // Param is passed by value, moved
    pub fn set_Justify(&mut self, v: super::chainedbft::QuorumCert) {
        self.Justify = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Justify(&mut self) -> &mut super::chainedbft::QuorumCert {
        if self.Justify.is_none() {
            self.Justify.set_default();
        }
        self.Justify.as_mut().unwrap()
    }

    // Take field
    pub fn take_Justify(&mut self) -> super::chainedbft::QuorumCert {
        self.Justify.take().unwrap_or_else(|| super::chainedbft::QuorumCert::new())
    }

    // bool in_trunk = 14;


    pub fn get_in_trunk(&self) -> bool {
        self.in_trunk
    }
    pub fn clear_in_trunk(&mut self) {
        self.in_trunk = false;
    }

    // Param is passed by value, moved
    pub fn set_in_trunk(&mut self, v: bool) {
        self.in_trunk = v;
    }

    // bytes next_hash = 15;


    pub fn get_next_hash(&self) -> &[u8] {
        &self.next_hash
    }
    pub fn clear_next_hash(&mut self) {
        self.next_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_next_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.next_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_next_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.next_hash
    }

    // Take field
    pub fn take_next_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.next_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for InternalBlock {
    fn is_initialized(&self) -> bool {
        for v in &self.transactions {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.Justify {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.version = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.nonce = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.blockid)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pre_hash)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.proposer)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sign)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pubkey)?;
                },
                8 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.merkle_root)?;
                },
                9 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.height = tmp;
                },
                10 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.timestamp = tmp;
                },
                11 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.transactions)?;
                },
                12 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.tx_count = tmp;
                },
                13 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.merkle_tree)?;
                },
                16 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.curTerm = tmp;
                },
                17 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.curBlockNum = tmp;
                },
                18 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(wire_type, is, &mut self.failed_txs)?;
                },
                19 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.targetBits = tmp;
                },
                20 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.Justify)?;
                },
                14 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.in_trunk = tmp;
                },
                15 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.next_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.version != 0 {
            my_size += ::protobuf::rt::value_size(1, self.version, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.nonce != 0 {
            my_size += ::protobuf::rt::value_size(2, self.nonce, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.blockid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.blockid);
        }
        if !self.pre_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.pre_hash);
        }
        if !self.proposer.is_empty() {
            my_size += ::protobuf::rt::bytes_size(5, &self.proposer);
        }
        if !self.sign.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.sign);
        }
        if !self.pubkey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.pubkey);
        }
        if !self.merkle_root.is_empty() {
            my_size += ::protobuf::rt::bytes_size(8, &self.merkle_root);
        }
        if self.height != 0 {
            my_size += ::protobuf::rt::value_size(9, self.height, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.timestamp != 0 {
            my_size += ::protobuf::rt::value_size(10, self.timestamp, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.transactions {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if self.tx_count != 0 {
            my_size += ::protobuf::rt::value_size(12, self.tx_count, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.merkle_tree {
            my_size += ::protobuf::rt::bytes_size(13, &value);
        };
        if self.curTerm != 0 {
            my_size += ::protobuf::rt::value_size(16, self.curTerm, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.curBlockNum != 0 {
            my_size += ::protobuf::rt::value_size(17, self.curBlockNum, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(18, &self.failed_txs);
        if self.targetBits != 0 {
            my_size += ::protobuf::rt::value_size(19, self.targetBits, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.Justify.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.in_trunk != false {
            my_size += 2;
        }
        if !self.next_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(15, &self.next_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.version != 0 {
            os.write_int32(1, self.version)?;
        }
        if self.nonce != 0 {
            os.write_int32(2, self.nonce)?;
        }
        if !self.blockid.is_empty() {
            os.write_bytes(3, &self.blockid)?;
        }
        if !self.pre_hash.is_empty() {
            os.write_bytes(4, &self.pre_hash)?;
        }
        if !self.proposer.is_empty() {
            os.write_bytes(5, &self.proposer)?;
        }
        if !self.sign.is_empty() {
            os.write_bytes(6, &self.sign)?;
        }
        if !self.pubkey.is_empty() {
            os.write_bytes(7, &self.pubkey)?;
        }
        if !self.merkle_root.is_empty() {
            os.write_bytes(8, &self.merkle_root)?;
        }
        if self.height != 0 {
            os.write_int64(9, self.height)?;
        }
        if self.timestamp != 0 {
            os.write_int64(10, self.timestamp)?;
        }
        for v in &self.transactions {
            os.write_tag(11, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if self.tx_count != 0 {
            os.write_int32(12, self.tx_count)?;
        }
        for v in &self.merkle_tree {
            os.write_bytes(13, &v)?;
        };
        if self.curTerm != 0 {
            os.write_int64(16, self.curTerm)?;
        }
        if self.curBlockNum != 0 {
            os.write_int64(17, self.curBlockNum)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(18, &self.failed_txs, os)?;
        if self.targetBits != 0 {
            os.write_int32(19, self.targetBits)?;
        }
        if let Some(ref v) = self.Justify.as_ref() {
            os.write_tag(20, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.in_trunk != false {
            os.write_bool(14, self.in_trunk)?;
        }
        if !self.next_hash.is_empty() {
            os.write_bytes(15, &self.next_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InternalBlock {
        InternalBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "version",
                    |m: &InternalBlock| { &m.version },
                    |m: &mut InternalBlock| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "nonce",
                    |m: &InternalBlock| { &m.nonce },
                    |m: &mut InternalBlock| { &mut m.nonce },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "blockid",
                    |m: &InternalBlock| { &m.blockid },
                    |m: &mut InternalBlock| { &mut m.blockid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pre_hash",
                    |m: &InternalBlock| { &m.pre_hash },
                    |m: &mut InternalBlock| { &mut m.pre_hash },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "proposer",
                    |m: &InternalBlock| { &m.proposer },
                    |m: &mut InternalBlock| { &mut m.proposer },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "sign",
                    |m: &InternalBlock| { &m.sign },
                    |m: &mut InternalBlock| { &mut m.sign },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pubkey",
                    |m: &InternalBlock| { &m.pubkey },
                    |m: &mut InternalBlock| { &mut m.pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "merkle_root",
                    |m: &InternalBlock| { &m.merkle_root },
                    |m: &mut InternalBlock| { &mut m.merkle_root },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "height",
                    |m: &InternalBlock| { &m.height },
                    |m: &mut InternalBlock| { &mut m.height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "timestamp",
                    |m: &InternalBlock| { &m.timestamp },
                    |m: &mut InternalBlock| { &mut m.timestamp },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Transaction>>(
                    "transactions",
                    |m: &InternalBlock| { &m.transactions },
                    |m: &mut InternalBlock| { &mut m.transactions },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "tx_count",
                    |m: &InternalBlock| { &m.tx_count },
                    |m: &mut InternalBlock| { &mut m.tx_count },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "merkle_tree",
                    |m: &InternalBlock| { &m.merkle_tree },
                    |m: &mut InternalBlock| { &mut m.merkle_tree },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "curTerm",
                    |m: &InternalBlock| { &m.curTerm },
                    |m: &mut InternalBlock| { &mut m.curTerm },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "curBlockNum",
                    |m: &InternalBlock| { &m.curBlockNum },
                    |m: &mut InternalBlock| { &mut m.curBlockNum },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeString>(
                    "failed_txs",
                    |m: &InternalBlock| { &m.failed_txs },
                    |m: &mut InternalBlock| { &mut m.failed_txs },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "targetBits",
                    |m: &InternalBlock| { &m.targetBits },
                    |m: &mut InternalBlock| { &mut m.targetBits },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<super::chainedbft::QuorumCert>>(
                    "Justify",
                    |m: &InternalBlock| { &m.Justify },
                    |m: &mut InternalBlock| { &mut m.Justify },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "in_trunk",
                    |m: &InternalBlock| { &m.in_trunk },
                    |m: &mut InternalBlock| { &mut m.in_trunk },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "next_hash",
                    |m: &InternalBlock| { &m.next_hash },
                    |m: &mut InternalBlock| { &mut m.next_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<InternalBlock>(
                    "InternalBlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InternalBlock {
        static mut instance: ::protobuf::lazy::Lazy<InternalBlock> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(InternalBlock::new)
        }
    }
}

impl ::protobuf::Clear for InternalBlock {
    fn clear(&mut self) {
        self.version = 0;
        self.nonce = 0;
        self.blockid.clear();
        self.pre_hash.clear();
        self.proposer.clear();
        self.sign.clear();
        self.pubkey.clear();
        self.merkle_root.clear();
        self.height = 0;
        self.timestamp = 0;
        self.transactions.clear();
        self.tx_count = 0;
        self.merkle_tree.clear();
        self.curTerm = 0;
        self.curBlockNum = 0;
        self.failed_txs.clear();
        self.targetBits = 0;
        self.Justify.clear();
        self.in_trunk = false;
        self.next_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InternalBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InternalBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BCStatus {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub meta: ::protobuf::SingularPtrField<LedgerMeta>,
    pub block: ::protobuf::SingularPtrField<InternalBlock>,
    pub utxoMeta: ::protobuf::SingularPtrField<UtxoMeta>,
    pub branchBlockid: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BCStatus {
    fn default() -> &'a BCStatus {
        <BCStatus as ::protobuf::Message>::default_instance()
    }
}

impl BCStatus {
    pub fn new() -> BCStatus {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // .pb.LedgerMeta meta = 3;


    pub fn get_meta(&self) -> &LedgerMeta {
        self.meta.as_ref().unwrap_or_else(|| LedgerMeta::default_instance())
    }
    pub fn clear_meta(&mut self) {
        self.meta.clear();
    }

    pub fn has_meta(&self) -> bool {
        self.meta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_meta(&mut self, v: LedgerMeta) {
        self.meta = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_meta(&mut self) -> &mut LedgerMeta {
        if self.meta.is_none() {
            self.meta.set_default();
        }
        self.meta.as_mut().unwrap()
    }

    // Take field
    pub fn take_meta(&mut self) -> LedgerMeta {
        self.meta.take().unwrap_or_else(|| LedgerMeta::new())
    }

    // .pb.InternalBlock block = 4;


    pub fn get_block(&self) -> &InternalBlock {
        self.block.as_ref().unwrap_or_else(|| InternalBlock::default_instance())
    }
    pub fn clear_block(&mut self) {
        self.block.clear();
    }

    pub fn has_block(&self) -> bool {
        self.block.is_some()
    }

    // Param is passed by value, moved
    pub fn set_block(&mut self, v: InternalBlock) {
        self.block = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_block(&mut self) -> &mut InternalBlock {
        if self.block.is_none() {
            self.block.set_default();
        }
        self.block.as_mut().unwrap()
    }

    // Take field
    pub fn take_block(&mut self) -> InternalBlock {
        self.block.take().unwrap_or_else(|| InternalBlock::new())
    }

    // .pb.UtxoMeta utxoMeta = 5;


    pub fn get_utxoMeta(&self) -> &UtxoMeta {
        self.utxoMeta.as_ref().unwrap_or_else(|| UtxoMeta::default_instance())
    }
    pub fn clear_utxoMeta(&mut self) {
        self.utxoMeta.clear();
    }

    pub fn has_utxoMeta(&self) -> bool {
        self.utxoMeta.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utxoMeta(&mut self, v: UtxoMeta) {
        self.utxoMeta = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_utxoMeta(&mut self) -> &mut UtxoMeta {
        if self.utxoMeta.is_none() {
            self.utxoMeta.set_default();
        }
        self.utxoMeta.as_mut().unwrap()
    }

    // Take field
    pub fn take_utxoMeta(&mut self) -> UtxoMeta {
        self.utxoMeta.take().unwrap_or_else(|| UtxoMeta::new())
    }

    // repeated string branchBlockid = 6;


    pub fn get_branchBlockid(&self) -> &[::std::string::String] {
        &self.branchBlockid
    }
    pub fn clear_branchBlockid(&mut self) {
        self.branchBlockid.clear();
    }

    // Param is passed by value, moved
    pub fn set_branchBlockid(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.branchBlockid = v;
    }

    // Mutable pointer to the field.
    pub fn mut_branchBlockid(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.branchBlockid
    }

    // Take field
    pub fn take_branchBlockid(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.branchBlockid, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BCStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.meta {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.block {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.utxoMeta {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.meta)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.block)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.utxoMeta)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.branchBlockid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if let Some(ref v) = self.meta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.block.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.utxoMeta.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.branchBlockid {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if let Some(ref v) = self.meta.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.block.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.utxoMeta.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.branchBlockid {
            os.write_string(6, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BCStatus {
        BCStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &BCStatus| { &m.header },
                    |m: &mut BCStatus| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &BCStatus| { &m.bcname },
                    |m: &mut BCStatus| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<LedgerMeta>>(
                    "meta",
                    |m: &BCStatus| { &m.meta },
                    |m: &mut BCStatus| { &mut m.meta },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InternalBlock>>(
                    "block",
                    |m: &BCStatus| { &m.block },
                    |m: &mut BCStatus| { &mut m.block },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UtxoMeta>>(
                    "utxoMeta",
                    |m: &BCStatus| { &m.utxoMeta },
                    |m: &mut BCStatus| { &mut m.utxoMeta },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "branchBlockid",
                    |m: &BCStatus| { &m.branchBlockid },
                    |m: &mut BCStatus| { &mut m.branchBlockid },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<BCStatus>(
                    "BCStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BCStatus {
        static mut instance: ::protobuf::lazy::Lazy<BCStatus> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(BCStatus::new)
        }
    }
}

impl ::protobuf::Clear for BCStatus {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.meta.clear();
        self.block.clear();
        self.utxoMeta.clear();
        self.branchBlockid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BCStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BCStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BCTipStatus {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub is_trunk_tip: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BCTipStatus {
    fn default() -> &'a BCTipStatus {
        <BCTipStatus as ::protobuf::Message>::default_instance()
    }
}

impl BCTipStatus {
    pub fn new() -> BCTipStatus {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // bool is_trunk_tip = 2;


    pub fn get_is_trunk_tip(&self) -> bool {
        self.is_trunk_tip
    }
    pub fn clear_is_trunk_tip(&mut self) {
        self.is_trunk_tip = false;
    }

    // Param is passed by value, moved
    pub fn set_is_trunk_tip(&mut self, v: bool) {
        self.is_trunk_tip = v;
    }
}

impl ::protobuf::Message for BCTipStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_trunk_tip = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.is_trunk_tip != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.is_trunk_tip != false {
            os.write_bool(2, self.is_trunk_tip)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BCTipStatus {
        BCTipStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &BCTipStatus| { &m.header },
                    |m: &mut BCTipStatus| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_trunk_tip",
                    |m: &BCTipStatus| { &m.is_trunk_tip },
                    |m: &mut BCTipStatus| { &mut m.is_trunk_tip },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<BCTipStatus>(
                    "BCTipStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BCTipStatus {
        static mut instance: ::protobuf::lazy::Lazy<BCTipStatus> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(BCTipStatus::new)
        }
    }
}

impl ::protobuf::Clear for BCTipStatus {
    fn clear(&mut self) {
        self.header.clear();
        self.is_trunk_tip = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BCTipStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BCTipStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BlockChains {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub blockchains: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BlockChains {
    fn default() -> &'a BlockChains {
        <BlockChains as ::protobuf::Message>::default_instance()
    }
}

impl BlockChains {
    pub fn new() -> BlockChains {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // repeated string blockchains = 2;


    pub fn get_blockchains(&self) -> &[::std::string::String] {
        &self.blockchains
    }
    pub fn clear_blockchains(&mut self) {
        self.blockchains.clear();
    }

    // Param is passed by value, moved
    pub fn set_blockchains(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.blockchains = v;
    }

    // Mutable pointer to the field.
    pub fn mut_blockchains(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.blockchains
    }

    // Take field
    pub fn take_blockchains(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.blockchains, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for BlockChains {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.blockchains)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.blockchains {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.blockchains {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BlockChains {
        BlockChains::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &BlockChains| { &m.header },
                    |m: &mut BlockChains| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "blockchains",
                    |m: &BlockChains| { &m.blockchains },
                    |m: &mut BlockChains| { &mut m.blockchains },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<BlockChains>(
                    "BlockChains",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BlockChains {
        static mut instance: ::protobuf::lazy::Lazy<BlockChains> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(BlockChains::new)
        }
    }
}

impl ::protobuf::Clear for BlockChains {
    fn clear(&mut self) {
        self.header.clear();
        self.blockchains.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BlockChains {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BlockChains {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Speeds {
    // message fields
    pub SumSpeeds: ::std::collections::HashMap<::std::string::String, f64>,
    pub BcSpeeds: ::std::collections::HashMap<::std::string::String, BCSpeeds>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Speeds {
    fn default() -> &'a Speeds {
        <Speeds as ::protobuf::Message>::default_instance()
    }
}

impl Speeds {
    pub fn new() -> Speeds {
        ::std::default::Default::default()
    }

    // repeated .pb.Speeds.SumSpeedsEntry SumSpeeds = 1;


    pub fn get_SumSpeeds(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
        &self.SumSpeeds
    }
    pub fn clear_SumSpeeds(&mut self) {
        self.SumSpeeds.clear();
    }

    // Param is passed by value, moved
    pub fn set_SumSpeeds(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
        self.SumSpeeds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_SumSpeeds(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
        &mut self.SumSpeeds
    }

    // Take field
    pub fn take_SumSpeeds(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
        ::std::mem::replace(&mut self.SumSpeeds, ::std::collections::HashMap::new())
    }

    // repeated .pb.Speeds.BcSpeedsEntry BcSpeeds = 2;


    pub fn get_BcSpeeds(&self) -> &::std::collections::HashMap<::std::string::String, BCSpeeds> {
        &self.BcSpeeds
    }
    pub fn clear_BcSpeeds(&mut self) {
        self.BcSpeeds.clear();
    }

    // Param is passed by value, moved
    pub fn set_BcSpeeds(&mut self, v: ::std::collections::HashMap<::std::string::String, BCSpeeds>) {
        self.BcSpeeds = v;
    }

    // Mutable pointer to the field.
    pub fn mut_BcSpeeds(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, BCSpeeds> {
        &mut self.BcSpeeds
    }

    // Take field
    pub fn take_BcSpeeds(&mut self) -> ::std::collections::HashMap<::std::string::String, BCSpeeds> {
        ::std::mem::replace(&mut self.BcSpeeds, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for Speeds {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(wire_type, is, &mut self.SumSpeeds)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<BCSpeeds>>(wire_type, is, &mut self.BcSpeeds)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(1, &self.SumSpeeds);
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<BCSpeeds>>(2, &self.BcSpeeds);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(1, &self.SumSpeeds, os)?;
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<BCSpeeds>>(2, &self.BcSpeeds, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Speeds {
        Speeds::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(
                    "SumSpeeds",
                    |m: &Speeds| { &m.SumSpeeds },
                    |m: &mut Speeds| { &mut m.SumSpeeds },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<BCSpeeds>>(
                    "BcSpeeds",
                    |m: &Speeds| { &m.BcSpeeds },
                    |m: &mut Speeds| { &mut m.BcSpeeds },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Speeds>(
                    "Speeds",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Speeds {
        static mut instance: ::protobuf::lazy::Lazy<Speeds> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Speeds::new)
        }
    }
}

impl ::protobuf::Clear for Speeds {
    fn clear(&mut self) {
        self.SumSpeeds.clear();
        self.BcSpeeds.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Speeds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Speeds {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct BCSpeeds {
    // message fields
    pub BcSpeed: ::std::collections::HashMap<::std::string::String, f64>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a BCSpeeds {
    fn default() -> &'a BCSpeeds {
        <BCSpeeds as ::protobuf::Message>::default_instance()
    }
}

impl BCSpeeds {
    pub fn new() -> BCSpeeds {
        ::std::default::Default::default()
    }

    // repeated .pb.BCSpeeds.BcSpeedEntry BcSpeed = 1;


    pub fn get_BcSpeed(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
        &self.BcSpeed
    }
    pub fn clear_BcSpeed(&mut self) {
        self.BcSpeed.clear();
    }

    // Param is passed by value, moved
    pub fn set_BcSpeed(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
        self.BcSpeed = v;
    }

    // Mutable pointer to the field.
    pub fn mut_BcSpeed(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
        &mut self.BcSpeed
    }

    // Take field
    pub fn take_BcSpeed(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
        ::std::mem::replace(&mut self.BcSpeed, ::std::collections::HashMap::new())
    }
}

impl ::protobuf::Message for BCSpeeds {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(wire_type, is, &mut self.BcSpeed)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(1, &self.BcSpeed);
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(1, &self.BcSpeed, os)?;
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> BCSpeeds {
        BCSpeeds::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(
                    "BcSpeed",
                    |m: &BCSpeeds| { &m.BcSpeed },
                    |m: &mut BCSpeeds| { &mut m.BcSpeed },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<BCSpeeds>(
                    "BCSpeeds",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static BCSpeeds {
        static mut instance: ::protobuf::lazy::Lazy<BCSpeeds> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(BCSpeeds::new)
        }
    }
}

impl ::protobuf::Clear for BCSpeeds {
    fn clear(&mut self) {
        self.BcSpeed.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for BCSpeeds {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BCSpeeds {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SystemsStatus {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcs_status: ::protobuf::RepeatedField<BCStatus>,
    pub speeds: ::protobuf::SingularPtrField<Speeds>,
    pub peerUrls: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SystemsStatus {
    fn default() -> &'a SystemsStatus {
        <SystemsStatus as ::protobuf::Message>::default_instance()
    }
}

impl SystemsStatus {
    pub fn new() -> SystemsStatus {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // repeated .pb.BCStatus bcs_status = 2;


    pub fn get_bcs_status(&self) -> &[BCStatus] {
        &self.bcs_status
    }
    pub fn clear_bcs_status(&mut self) {
        self.bcs_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcs_status(&mut self, v: ::protobuf::RepeatedField<BCStatus>) {
        self.bcs_status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_bcs_status(&mut self) -> &mut ::protobuf::RepeatedField<BCStatus> {
        &mut self.bcs_status
    }

    // Take field
    pub fn take_bcs_status(&mut self) -> ::protobuf::RepeatedField<BCStatus> {
        ::std::mem::replace(&mut self.bcs_status, ::protobuf::RepeatedField::new())
    }

    // .pb.Speeds speeds = 3;


    pub fn get_speeds(&self) -> &Speeds {
        self.speeds.as_ref().unwrap_or_else(|| Speeds::default_instance())
    }
    pub fn clear_speeds(&mut self) {
        self.speeds.clear();
    }

    pub fn has_speeds(&self) -> bool {
        self.speeds.is_some()
    }

    // Param is passed by value, moved
    pub fn set_speeds(&mut self, v: Speeds) {
        self.speeds = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_speeds(&mut self) -> &mut Speeds {
        if self.speeds.is_none() {
            self.speeds.set_default();
        }
        self.speeds.as_mut().unwrap()
    }

    // Take field
    pub fn take_speeds(&mut self) -> Speeds {
        self.speeds.take().unwrap_or_else(|| Speeds::new())
    }

    // repeated string peerUrls = 4;


    pub fn get_peerUrls(&self) -> &[::std::string::String] {
        &self.peerUrls
    }
    pub fn clear_peerUrls(&mut self) {
        self.peerUrls.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerUrls(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.peerUrls = v;
    }

    // Mutable pointer to the field.
    pub fn mut_peerUrls(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.peerUrls
    }

    // Take field
    pub fn take_peerUrls(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.peerUrls, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for SystemsStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.bcs_status {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.speeds {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.bcs_status)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.speeds)?;
                },
                4 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.peerUrls)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.bcs_status {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if let Some(ref v) = self.speeds.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.peerUrls {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.bcs_status {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if let Some(ref v) = self.speeds.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.peerUrls {
            os.write_string(4, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SystemsStatus {
        SystemsStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &SystemsStatus| { &m.header },
                    |m: &mut SystemsStatus| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<BCStatus>>(
                    "bcs_status",
                    |m: &SystemsStatus| { &m.bcs_status },
                    |m: &mut SystemsStatus| { &mut m.bcs_status },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Speeds>>(
                    "speeds",
                    |m: &SystemsStatus| { &m.speeds },
                    |m: &mut SystemsStatus| { &mut m.speeds },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "peerUrls",
                    |m: &SystemsStatus| { &m.peerUrls },
                    |m: &mut SystemsStatus| { &mut m.peerUrls },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SystemsStatus>(
                    "SystemsStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SystemsStatus {
        static mut instance: ::protobuf::lazy::Lazy<SystemsStatus> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SystemsStatus::new)
        }
    }
}

impl ::protobuf::Clear for SystemsStatus {
    fn clear(&mut self) {
        self.header.clear();
        self.bcs_status.clear();
        self.speeds.clear();
        self.peerUrls.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SystemsStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SystemsStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SystemsStatusReply {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub systems_status: ::protobuf::SingularPtrField<SystemsStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SystemsStatusReply {
    fn default() -> &'a SystemsStatusReply {
        <SystemsStatusReply as ::protobuf::Message>::default_instance()
    }
}

impl SystemsStatusReply {
    pub fn new() -> SystemsStatusReply {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // .pb.SystemsStatus systems_status = 2;


    pub fn get_systems_status(&self) -> &SystemsStatus {
        self.systems_status.as_ref().unwrap_or_else(|| SystemsStatus::default_instance())
    }
    pub fn clear_systems_status(&mut self) {
        self.systems_status.clear();
    }

    pub fn has_systems_status(&self) -> bool {
        self.systems_status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_systems_status(&mut self, v: SystemsStatus) {
        self.systems_status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_systems_status(&mut self) -> &mut SystemsStatus {
        if self.systems_status.is_none() {
            self.systems_status.set_default();
        }
        self.systems_status.as_mut().unwrap()
    }

    // Take field
    pub fn take_systems_status(&mut self) -> SystemsStatus {
        self.systems_status.take().unwrap_or_else(|| SystemsStatus::new())
    }
}

impl ::protobuf::Message for SystemsStatusReply {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.systems_status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.systems_status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.systems_status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.systems_status.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SystemsStatusReply {
        SystemsStatusReply::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &SystemsStatusReply| { &m.header },
                    |m: &mut SystemsStatusReply| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SystemsStatus>>(
                    "systems_status",
                    |m: &SystemsStatusReply| { &m.systems_status },
                    |m: &mut SystemsStatusReply| { &mut m.systems_status },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SystemsStatusReply>(
                    "SystemsStatusReply",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SystemsStatusReply {
        static mut instance: ::protobuf::lazy::Lazy<SystemsStatusReply> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SystemsStatusReply::new)
        }
    }
}

impl ::protobuf::Clear for SystemsStatusReply {
    fn clear(&mut self) {
        self.header.clear();
        self.systems_status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SystemsStatusReply {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SystemsStatusReply {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct RawUrl {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub rawUrl: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a RawUrl {
    fn default() -> &'a RawUrl {
        <RawUrl as ::protobuf::Message>::default_instance()
    }
}

impl RawUrl {
    pub fn new() -> RawUrl {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string rawUrl = 2;


    pub fn get_rawUrl(&self) -> &str {
        &self.rawUrl
    }
    pub fn clear_rawUrl(&mut self) {
        self.rawUrl.clear();
    }

    // Param is passed by value, moved
    pub fn set_rawUrl(&mut self, v: ::std::string::String) {
        self.rawUrl = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_rawUrl(&mut self) -> &mut ::std::string::String {
        &mut self.rawUrl
    }

    // Take field
    pub fn take_rawUrl(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.rawUrl, ::std::string::String::new())
    }
}

impl ::protobuf::Message for RawUrl {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.rawUrl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.rawUrl.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.rawUrl);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.rawUrl.is_empty() {
            os.write_string(2, &self.rawUrl)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> RawUrl {
        RawUrl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &RawUrl| { &m.header },
                    |m: &mut RawUrl| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "rawUrl",
                    |m: &RawUrl| { &m.rawUrl },
                    |m: &mut RawUrl| { &mut m.rawUrl },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<RawUrl>(
                    "RawUrl",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static RawUrl {
        static mut instance: ::protobuf::lazy::Lazy<RawUrl> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(RawUrl::new)
        }
    }
}

impl ::protobuf::Clear for RawUrl {
    fn clear(&mut self) {
        self.header.clear();
        self.rawUrl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for RawUrl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for RawUrl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Utxo {
    // message fields
    #[serde(serialize_with = "crate::wallet::serialize_bytes")]
    #[serde(deserialize_with = "crate::wallet::deserialize_bytes")]
    pub amount: ::std::vec::Vec<u8>,
    #[serde(serialize_with = "crate::wallet::serialize_bytes")]
    #[serde(deserialize_with = "crate::wallet::deserialize_bytes")]
    pub toAddr: ::std::vec::Vec<u8>,
    #[serde(default)]
    #[serde(serialize_with = "crate::wallet::serialize_bytes")]
    #[serde(deserialize_with = "crate::wallet::deserialize_bytes")]
    pub toPubkey: ::std::vec::Vec<u8>,
    #[serde(serialize_with = "crate::wallet::serialize_bytes")]
    #[serde(deserialize_with = "crate::wallet::deserialize_bytes")]
    pub refTxid: ::std::vec::Vec<u8>,
    #[serde(default)]
    pub refOffset: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Utxo {
    fn default() -> &'a Utxo {
        <Utxo as ::protobuf::Message>::default_instance()
    }
}

impl Utxo {
    pub fn new() -> Utxo {
        ::std::default::Default::default()
    }

    // bytes amount = 1;


    pub fn get_amount(&self) -> &[u8] {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::vec::Vec<u8>) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.amount, ::std::vec::Vec::new())
    }

    // bytes toAddr = 2;


    pub fn get_toAddr(&self) -> &[u8] {
        &self.toAddr
    }
    pub fn clear_toAddr(&mut self) {
        self.toAddr.clear();
    }

    // Param is passed by value, moved
    pub fn set_toAddr(&mut self, v: ::std::vec::Vec<u8>) {
        self.toAddr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toAddr(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.toAddr
    }

    // Take field
    pub fn take_toAddr(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.toAddr, ::std::vec::Vec::new())
    }

    // bytes toPubkey = 3;


    pub fn get_toPubkey(&self) -> &[u8] {
        &self.toPubkey
    }
    pub fn clear_toPubkey(&mut self) {
        self.toPubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_toPubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.toPubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_toPubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.toPubkey
    }

    // Take field
    pub fn take_toPubkey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.toPubkey, ::std::vec::Vec::new())
    }

    // bytes refTxid = 4;


    pub fn get_refTxid(&self) -> &[u8] {
        &self.refTxid
    }
    pub fn clear_refTxid(&mut self) {
        self.refTxid.clear();
    }

    // Param is passed by value, moved
    pub fn set_refTxid(&mut self, v: ::std::vec::Vec<u8>) {
        self.refTxid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_refTxid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.refTxid
    }

    // Take field
    pub fn take_refTxid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.refTxid, ::std::vec::Vec::new())
    }

    // int32 refOffset = 5;


    pub fn get_refOffset(&self) -> i32 {
        self.refOffset
    }
    pub fn clear_refOffset(&mut self) {
        self.refOffset = 0;
    }

    // Param is passed by value, moved
    pub fn set_refOffset(&mut self, v: i32) {
        self.refOffset = v;
    }
}

impl ::protobuf::Message for Utxo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.amount)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.toAddr)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.toPubkey)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.refTxid)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.refOffset = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.amount);
        }
        if !self.toAddr.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.toAddr);
        }
        if !self.toPubkey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.toPubkey);
        }
        if !self.refTxid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.refTxid);
        }
        if self.refOffset != 0 {
            my_size += ::protobuf::rt::value_size(5, self.refOffset, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.amount.is_empty() {
            os.write_bytes(1, &self.amount)?;
        }
        if !self.toAddr.is_empty() {
            os.write_bytes(2, &self.toAddr)?;
        }
        if !self.toPubkey.is_empty() {
            os.write_bytes(3, &self.toPubkey)?;
        }
        if !self.refTxid.is_empty() {
            os.write_bytes(4, &self.refTxid)?;
        }
        if self.refOffset != 0 {
            os.write_int32(5, self.refOffset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Utxo {
        Utxo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "amount",
                    |m: &Utxo| { &m.amount },
                    |m: &mut Utxo| { &mut m.amount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "toAddr",
                    |m: &Utxo| { &m.toAddr },
                    |m: &mut Utxo| { &mut m.toAddr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "toPubkey",
                    |m: &Utxo| { &m.toPubkey },
                    |m: &mut Utxo| { &mut m.toPubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "refTxid",
                    |m: &Utxo| { &m.refTxid },
                    |m: &mut Utxo| { &mut m.refTxid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "refOffset",
                    |m: &Utxo| { &m.refOffset },
                    |m: &mut Utxo| { &mut m.refOffset },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Utxo>(
                    "Utxo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Utxo {
        static mut instance: ::protobuf::lazy::Lazy<Utxo> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Utxo::new)
        }
    }
}

impl ::protobuf::Clear for Utxo {
    fn clear(&mut self) {
        self.amount.clear();
        self.toAddr.clear();
        self.toPubkey.clear();
        self.refTxid.clear();
        self.refOffset = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Utxo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Utxo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UtxoInput {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub address: ::std::string::String,
    pub publickey: ::std::string::String,
    pub totalNeed: ::std::string::String,
    pub userSign: ::std::vec::Vec<u8>,
    pub needLock: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UtxoInput {
    fn default() -> &'a UtxoInput {
        <UtxoInput as ::protobuf::Message>::default_instance()
    }
}

impl UtxoInput {
    pub fn new() -> UtxoInput {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // string publickey = 4;


    pub fn get_publickey(&self) -> &str {
        &self.publickey
    }
    pub fn clear_publickey(&mut self) {
        self.publickey.clear();
    }

    // Param is passed by value, moved
    pub fn set_publickey(&mut self, v: ::std::string::String) {
        self.publickey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_publickey(&mut self) -> &mut ::std::string::String {
        &mut self.publickey
    }

    // Take field
    pub fn take_publickey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.publickey, ::std::string::String::new())
    }

    // string totalNeed = 5;


    pub fn get_totalNeed(&self) -> &str {
        &self.totalNeed
    }
    pub fn clear_totalNeed(&mut self) {
        self.totalNeed.clear();
    }

    // Param is passed by value, moved
    pub fn set_totalNeed(&mut self, v: ::std::string::String) {
        self.totalNeed = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_totalNeed(&mut self) -> &mut ::std::string::String {
        &mut self.totalNeed
    }

    // Take field
    pub fn take_totalNeed(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.totalNeed, ::std::string::String::new())
    }

    // bytes userSign = 7;


    pub fn get_userSign(&self) -> &[u8] {
        &self.userSign
    }
    pub fn clear_userSign(&mut self) {
        self.userSign.clear();
    }

    // Param is passed by value, moved
    pub fn set_userSign(&mut self, v: ::std::vec::Vec<u8>) {
        self.userSign = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_userSign(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.userSign
    }

    // Take field
    pub fn take_userSign(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.userSign, ::std::vec::Vec::new())
    }

    // bool needLock = 8;


    pub fn get_needLock(&self) -> bool {
        self.needLock
    }
    pub fn clear_needLock(&mut self) {
        self.needLock = false;
    }

    // Param is passed by value, moved
    pub fn set_needLock(&mut self, v: bool) {
        self.needLock = v;
    }
}

impl ::protobuf::Message for UtxoInput {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.publickey)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.totalNeed)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.userSign)?;
                },
                8 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needLock = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        if !self.publickey.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.publickey);
        }
        if !self.totalNeed.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.totalNeed);
        }
        if !self.userSign.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.userSign);
        }
        if self.needLock != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        if !self.publickey.is_empty() {
            os.write_string(4, &self.publickey)?;
        }
        if !self.totalNeed.is_empty() {
            os.write_string(5, &self.totalNeed)?;
        }
        if !self.userSign.is_empty() {
            os.write_bytes(7, &self.userSign)?;
        }
        if self.needLock != false {
            os.write_bool(8, self.needLock)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UtxoInput {
        UtxoInput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &UtxoInput| { &m.header },
                    |m: &mut UtxoInput| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &UtxoInput| { &m.bcname },
                    |m: &mut UtxoInput| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &UtxoInput| { &m.address },
                    |m: &mut UtxoInput| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "publickey",
                    |m: &UtxoInput| { &m.publickey },
                    |m: &mut UtxoInput| { &mut m.publickey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "totalNeed",
                    |m: &UtxoInput| { &m.totalNeed },
                    |m: &mut UtxoInput| { &mut m.totalNeed },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "userSign",
                    |m: &UtxoInput| { &m.userSign },
                    |m: &mut UtxoInput| { &mut m.userSign },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "needLock",
                    |m: &UtxoInput| { &m.needLock },
                    |m: &mut UtxoInput| { &mut m.needLock },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UtxoInput>(
                    "UtxoInput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UtxoInput {
        static mut instance: ::protobuf::lazy::Lazy<UtxoInput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UtxoInput::new)
        }
    }
}

impl ::protobuf::Clear for UtxoInput {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.address.clear();
        self.publickey.clear();
        self.totalNeed.clear();
        self.userSign.clear();
        self.needLock = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UtxoInput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UtxoInput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UtxoOutput {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub utxoList: ::protobuf::RepeatedField<Utxo>,
    pub totalSelected: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UtxoOutput {
    fn default() -> &'a UtxoOutput {
        <UtxoOutput as ::protobuf::Message>::default_instance()
    }
}

impl UtxoOutput {
    pub fn new() -> UtxoOutput {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // repeated .pb.Utxo utxoList = 2;


    pub fn get_utxoList(&self) -> &[Utxo] {
        &self.utxoList
    }
    pub fn clear_utxoList(&mut self) {
        self.utxoList.clear();
    }

    // Param is passed by value, moved
    pub fn set_utxoList(&mut self, v: ::protobuf::RepeatedField<Utxo>) {
        self.utxoList = v;
    }

    // Mutable pointer to the field.
    pub fn mut_utxoList(&mut self) -> &mut ::protobuf::RepeatedField<Utxo> {
        &mut self.utxoList
    }

    // Take field
    pub fn take_utxoList(&mut self) -> ::protobuf::RepeatedField<Utxo> {
        ::std::mem::replace(&mut self.utxoList, ::protobuf::RepeatedField::new())
    }

    // string totalSelected = 3;


    pub fn get_totalSelected(&self) -> &str {
        &self.totalSelected
    }
    pub fn clear_totalSelected(&mut self) {
        self.totalSelected.clear();
    }

    // Param is passed by value, moved
    pub fn set_totalSelected(&mut self, v: ::std::string::String) {
        self.totalSelected = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_totalSelected(&mut self) -> &mut ::std::string::String {
        &mut self.totalSelected
    }

    // Take field
    pub fn take_totalSelected(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.totalSelected, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UtxoOutput {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.utxoList {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.utxoList)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.totalSelected)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.utxoList {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.totalSelected.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.totalSelected);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.utxoList {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.totalSelected.is_empty() {
            os.write_string(3, &self.totalSelected)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UtxoOutput {
        UtxoOutput::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &UtxoOutput| { &m.header },
                    |m: &mut UtxoOutput| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Utxo>>(
                    "utxoList",
                    |m: &UtxoOutput| { &m.utxoList },
                    |m: &mut UtxoOutput| { &mut m.utxoList },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "totalSelected",
                    |m: &UtxoOutput| { &m.totalSelected },
                    |m: &mut UtxoOutput| { &mut m.totalSelected },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UtxoOutput>(
                    "UtxoOutput",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UtxoOutput {
        static mut instance: ::protobuf::lazy::Lazy<UtxoOutput> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UtxoOutput::new)
        }
    }
}

impl ::protobuf::Clear for UtxoOutput {
    fn clear(&mut self) {
        self.header.clear();
        self.utxoList.clear();
        self.totalSelected.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UtxoOutput {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UtxoOutput {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NativeCodeDesc {
    // message fields
    pub name: ::std::string::String,
    pub version: ::std::string::String,
    pub digest: ::std::vec::Vec<u8>,
    pub prevVersion: ::std::string::String,
    pub xuperApiVersion: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NativeCodeDesc {
    fn default() -> &'a NativeCodeDesc {
        <NativeCodeDesc as ::protobuf::Message>::default_instance()
    }
}

impl NativeCodeDesc {
    pub fn new() -> NativeCodeDesc {
        ::std::default::Default::default()
    }

    // string name = 1;


    pub fn get_name(&self) -> &str {
        &self.name
    }
    pub fn clear_name(&mut self) {
        self.name.clear();
    }

    // Param is passed by value, moved
    pub fn set_name(&mut self, v: ::std::string::String) {
        self.name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_name(&mut self) -> &mut ::std::string::String {
        &mut self.name
    }

    // Take field
    pub fn take_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.name, ::std::string::String::new())
    }

    // string version = 2;


    pub fn get_version(&self) -> &str {
        &self.version
    }
    pub fn clear_version(&mut self) {
        self.version.clear();
    }

    // Param is passed by value, moved
    pub fn set_version(&mut self, v: ::std::string::String) {
        self.version = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_version(&mut self) -> &mut ::std::string::String {
        &mut self.version
    }

    // Take field
    pub fn take_version(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.version, ::std::string::String::new())
    }

    // bytes digest = 3;


    pub fn get_digest(&self) -> &[u8] {
        &self.digest
    }
    pub fn clear_digest(&mut self) {
        self.digest.clear();
    }

    // Param is passed by value, moved
    pub fn set_digest(&mut self, v: ::std::vec::Vec<u8>) {
        self.digest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_digest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.digest
    }

    // Take field
    pub fn take_digest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.digest, ::std::vec::Vec::new())
    }

    // string prevVersion = 4;


    pub fn get_prevVersion(&self) -> &str {
        &self.prevVersion
    }
    pub fn clear_prevVersion(&mut self) {
        self.prevVersion.clear();
    }

    // Param is passed by value, moved
    pub fn set_prevVersion(&mut self, v: ::std::string::String) {
        self.prevVersion = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_prevVersion(&mut self) -> &mut ::std::string::String {
        &mut self.prevVersion
    }

    // Take field
    pub fn take_prevVersion(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.prevVersion, ::std::string::String::new())
    }

    // int32 xuperApiVersion = 5;


    pub fn get_xuperApiVersion(&self) -> i32 {
        self.xuperApiVersion
    }
    pub fn clear_xuperApiVersion(&mut self) {
        self.xuperApiVersion = 0;
    }

    // Param is passed by value, moved
    pub fn set_xuperApiVersion(&mut self, v: i32) {
        self.xuperApiVersion = v;
    }
}

impl ::protobuf::Message for NativeCodeDesc {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.version)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.digest)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.prevVersion)?;
                },
                5 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.xuperApiVersion = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.version.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.version);
        }
        if !self.digest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.digest);
        }
        if !self.prevVersion.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.prevVersion);
        }
        if self.xuperApiVersion != 0 {
            my_size += ::protobuf::rt::value_size(5, self.xuperApiVersion, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.version.is_empty() {
            os.write_string(2, &self.version)?;
        }
        if !self.digest.is_empty() {
            os.write_bytes(3, &self.digest)?;
        }
        if !self.prevVersion.is_empty() {
            os.write_string(4, &self.prevVersion)?;
        }
        if self.xuperApiVersion != 0 {
            os.write_int32(5, self.xuperApiVersion)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NativeCodeDesc {
        NativeCodeDesc::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "name",
                    |m: &NativeCodeDesc| { &m.name },
                    |m: &mut NativeCodeDesc| { &mut m.name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "version",
                    |m: &NativeCodeDesc| { &m.version },
                    |m: &mut NativeCodeDesc| { &mut m.version },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "digest",
                    |m: &NativeCodeDesc| { &m.digest },
                    |m: &mut NativeCodeDesc| { &mut m.digest },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "prevVersion",
                    |m: &NativeCodeDesc| { &m.prevVersion },
                    |m: &mut NativeCodeDesc| { &mut m.prevVersion },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "xuperApiVersion",
                    |m: &NativeCodeDesc| { &m.xuperApiVersion },
                    |m: &mut NativeCodeDesc| { &mut m.xuperApiVersion },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<NativeCodeDesc>(
                    "NativeCodeDesc",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NativeCodeDesc {
        static mut instance: ::protobuf::lazy::Lazy<NativeCodeDesc> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(NativeCodeDesc::new)
        }
    }
}

impl ::protobuf::Clear for NativeCodeDesc {
    fn clear(&mut self) {
        self.name.clear();
        self.version.clear();
        self.digest.clear();
        self.prevVersion.clear();
        self.xuperApiVersion = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NativeCodeDesc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NativeCodeDesc {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct WasmCodeDesc {
    // message fields
    pub runtime: ::std::string::String,
    pub compiler: ::std::string::String,
    pub digest: ::std::vec::Vec<u8>,
    pub vm_compiler: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a WasmCodeDesc {
    fn default() -> &'a WasmCodeDesc {
        <WasmCodeDesc as ::protobuf::Message>::default_instance()
    }
}

impl WasmCodeDesc {
    pub fn new() -> WasmCodeDesc {
        ::std::default::Default::default()
    }

    // string runtime = 1;


    pub fn get_runtime(&self) -> &str {
        &self.runtime
    }
    pub fn clear_runtime(&mut self) {
        self.runtime.clear();
    }

    // Param is passed by value, moved
    pub fn set_runtime(&mut self, v: ::std::string::String) {
        self.runtime = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_runtime(&mut self) -> &mut ::std::string::String {
        &mut self.runtime
    }

    // Take field
    pub fn take_runtime(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.runtime, ::std::string::String::new())
    }

    // string compiler = 2;


    pub fn get_compiler(&self) -> &str {
        &self.compiler
    }
    pub fn clear_compiler(&mut self) {
        self.compiler.clear();
    }

    // Param is passed by value, moved
    pub fn set_compiler(&mut self, v: ::std::string::String) {
        self.compiler = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_compiler(&mut self) -> &mut ::std::string::String {
        &mut self.compiler
    }

    // Take field
    pub fn take_compiler(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.compiler, ::std::string::String::new())
    }

    // bytes digest = 3;


    pub fn get_digest(&self) -> &[u8] {
        &self.digest
    }
    pub fn clear_digest(&mut self) {
        self.digest.clear();
    }

    // Param is passed by value, moved
    pub fn set_digest(&mut self, v: ::std::vec::Vec<u8>) {
        self.digest = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_digest(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.digest
    }

    // Take field
    pub fn take_digest(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.digest, ::std::vec::Vec::new())
    }

    // string vm_compiler = 4;


    pub fn get_vm_compiler(&self) -> &str {
        &self.vm_compiler
    }
    pub fn clear_vm_compiler(&mut self) {
        self.vm_compiler.clear();
    }

    // Param is passed by value, moved
    pub fn set_vm_compiler(&mut self, v: ::std::string::String) {
        self.vm_compiler = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_vm_compiler(&mut self) -> &mut ::std::string::String {
        &mut self.vm_compiler
    }

    // Take field
    pub fn take_vm_compiler(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.vm_compiler, ::std::string::String::new())
    }
}

impl ::protobuf::Message for WasmCodeDesc {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.runtime)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.compiler)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.digest)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.vm_compiler)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.runtime.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.runtime);
        }
        if !self.compiler.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.compiler);
        }
        if !self.digest.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.digest);
        }
        if !self.vm_compiler.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.vm_compiler);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.runtime.is_empty() {
            os.write_string(1, &self.runtime)?;
        }
        if !self.compiler.is_empty() {
            os.write_string(2, &self.compiler)?;
        }
        if !self.digest.is_empty() {
            os.write_bytes(3, &self.digest)?;
        }
        if !self.vm_compiler.is_empty() {
            os.write_string(4, &self.vm_compiler)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> WasmCodeDesc {
        WasmCodeDesc::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "runtime",
                    |m: &WasmCodeDesc| { &m.runtime },
                    |m: &mut WasmCodeDesc| { &mut m.runtime },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "compiler",
                    |m: &WasmCodeDesc| { &m.compiler },
                    |m: &mut WasmCodeDesc| { &mut m.compiler },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "digest",
                    |m: &WasmCodeDesc| { &m.digest },
                    |m: &mut WasmCodeDesc| { &mut m.digest },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "vm_compiler",
                    |m: &WasmCodeDesc| { &m.vm_compiler },
                    |m: &mut WasmCodeDesc| { &mut m.vm_compiler },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<WasmCodeDesc>(
                    "WasmCodeDesc",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static WasmCodeDesc {
        static mut instance: ::protobuf::lazy::Lazy<WasmCodeDesc> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(WasmCodeDesc::new)
        }
    }
}

impl ::protobuf::Clear for WasmCodeDesc {
    fn clear(&mut self) {
        self.runtime.clear();
        self.compiler.clear();
        self.digest.clear();
        self.vm_compiler.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for WasmCodeDesc {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for WasmCodeDesc {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DeployNativeCodeRequest {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub desc: ::protobuf::SingularPtrField<NativeCodeDesc>,
    pub code: ::std::vec::Vec<u8>,
    pub address: ::std::string::String,
    pub pubkey: ::std::vec::Vec<u8>,
    pub sign: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeployNativeCodeRequest {
    fn default() -> &'a DeployNativeCodeRequest {
        <DeployNativeCodeRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeployNativeCodeRequest {
    pub fn new() -> DeployNativeCodeRequest {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // .pb.NativeCodeDesc desc = 3;


    pub fn get_desc(&self) -> &NativeCodeDesc {
        self.desc.as_ref().unwrap_or_else(|| NativeCodeDesc::default_instance())
    }
    pub fn clear_desc(&mut self) {
        self.desc.clear();
    }

    pub fn has_desc(&self) -> bool {
        self.desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: NativeCodeDesc) {
        self.desc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut NativeCodeDesc {
        if self.desc.is_none() {
            self.desc.set_default();
        }
        self.desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc(&mut self) -> NativeCodeDesc {
        self.desc.take().unwrap_or_else(|| NativeCodeDesc::new())
    }

    // bytes code = 4;


    pub fn get_code(&self) -> &[u8] {
        &self.code
    }
    pub fn clear_code(&mut self) {
        self.code.clear();
    }

    // Param is passed by value, moved
    pub fn set_code(&mut self, v: ::std::vec::Vec<u8>) {
        self.code = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_code(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.code
    }

    // Take field
    pub fn take_code(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.code, ::std::vec::Vec::new())
    }

    // string address = 5;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // bytes pubkey = 6;


    pub fn get_pubkey(&self) -> &[u8] {
        &self.pubkey
    }
    pub fn clear_pubkey(&mut self) {
        self.pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pubkey
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pubkey, ::std::vec::Vec::new())
    }

    // bytes sign = 7;


    pub fn get_sign(&self) -> &[u8] {
        &self.sign
    }
    pub fn clear_sign(&mut self) {
        self.sign.clear();
    }

    // Param is passed by value, moved
    pub fn set_sign(&mut self, v: ::std::vec::Vec<u8>) {
        self.sign = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sign(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sign
    }

    // Take field
    pub fn take_sign(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sign, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for DeployNativeCodeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.desc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.desc)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.code)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pubkey)?;
                },
                7 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sign)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if let Some(ref v) = self.desc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.code);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.address);
        }
        if !self.pubkey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(6, &self.pubkey);
        }
        if !self.sign.is_empty() {
            my_size += ::protobuf::rt::bytes_size(7, &self.sign);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if let Some(ref v) = self.desc.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.code.is_empty() {
            os.write_bytes(4, &self.code)?;
        }
        if !self.address.is_empty() {
            os.write_string(5, &self.address)?;
        }
        if !self.pubkey.is_empty() {
            os.write_bytes(6, &self.pubkey)?;
        }
        if !self.sign.is_empty() {
            os.write_bytes(7, &self.sign)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeployNativeCodeRequest {
        DeployNativeCodeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &DeployNativeCodeRequest| { &m.header },
                    |m: &mut DeployNativeCodeRequest| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &DeployNativeCodeRequest| { &m.bcname },
                    |m: &mut DeployNativeCodeRequest| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NativeCodeDesc>>(
                    "desc",
                    |m: &DeployNativeCodeRequest| { &m.desc },
                    |m: &mut DeployNativeCodeRequest| { &mut m.desc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "code",
                    |m: &DeployNativeCodeRequest| { &m.code },
                    |m: &mut DeployNativeCodeRequest| { &mut m.code },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &DeployNativeCodeRequest| { &m.address },
                    |m: &mut DeployNativeCodeRequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pubkey",
                    |m: &DeployNativeCodeRequest| { &m.pubkey },
                    |m: &mut DeployNativeCodeRequest| { &mut m.pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "sign",
                    |m: &DeployNativeCodeRequest| { &m.sign },
                    |m: &mut DeployNativeCodeRequest| { &mut m.sign },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeployNativeCodeRequest>(
                    "DeployNativeCodeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeployNativeCodeRequest {
        static mut instance: ::protobuf::lazy::Lazy<DeployNativeCodeRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DeployNativeCodeRequest::new)
        }
    }
}

impl ::protobuf::Clear for DeployNativeCodeRequest {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.desc.clear();
        self.code.clear();
        self.address.clear();
        self.pubkey.clear();
        self.sign.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeployNativeCodeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeployNativeCodeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DeployNativeCodeResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DeployNativeCodeResponse {
    fn default() -> &'a DeployNativeCodeResponse {
        <DeployNativeCodeResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeployNativeCodeResponse {
    pub fn new() -> DeployNativeCodeResponse {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }
}

impl ::protobuf::Message for DeployNativeCodeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DeployNativeCodeResponse {
        DeployNativeCodeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &DeployNativeCodeResponse| { &m.header },
                    |m: &mut DeployNativeCodeResponse| { &mut m.header },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DeployNativeCodeResponse>(
                    "DeployNativeCodeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DeployNativeCodeResponse {
        static mut instance: ::protobuf::lazy::Lazy<DeployNativeCodeResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DeployNativeCodeResponse::new)
        }
    }
}

impl ::protobuf::Clear for DeployNativeCodeResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DeployNativeCodeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeployNativeCodeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NativeCodeStatus {
    // message fields
    pub desc: ::protobuf::SingularPtrField<NativeCodeDesc>,
    pub status: i32,
    pub healthy: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NativeCodeStatus {
    fn default() -> &'a NativeCodeStatus {
        <NativeCodeStatus as ::protobuf::Message>::default_instance()
    }
}

impl NativeCodeStatus {
    pub fn new() -> NativeCodeStatus {
        ::std::default::Default::default()
    }

    // .pb.NativeCodeDesc desc = 1;


    pub fn get_desc(&self) -> &NativeCodeDesc {
        self.desc.as_ref().unwrap_or_else(|| NativeCodeDesc::default_instance())
    }
    pub fn clear_desc(&mut self) {
        self.desc.clear();
    }

    pub fn has_desc(&self) -> bool {
        self.desc.is_some()
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: NativeCodeDesc) {
        self.desc = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut NativeCodeDesc {
        if self.desc.is_none() {
            self.desc.set_default();
        }
        self.desc.as_mut().unwrap()
    }

    // Take field
    pub fn take_desc(&mut self) -> NativeCodeDesc {
        self.desc.take().unwrap_or_else(|| NativeCodeDesc::new())
    }

    // int32 status = 2;


    pub fn get_status(&self) -> i32 {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = v;
    }

    // bool healthy = 3;


    pub fn get_healthy(&self) -> bool {
        self.healthy
    }
    pub fn clear_healthy(&mut self) {
        self.healthy = false;
    }

    // Param is passed by value, moved
    pub fn set_healthy(&mut self, v: bool) {
        self.healthy = v;
    }
}

impl ::protobuf::Message for NativeCodeStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.desc {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.desc)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.healthy = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.desc.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.status != 0 {
            my_size += ::protobuf::rt::value_size(2, self.status, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.healthy != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.desc.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.status != 0 {
            os.write_int32(2, self.status)?;
        }
        if self.healthy != false {
            os.write_bool(3, self.healthy)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NativeCodeStatus {
        NativeCodeStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NativeCodeDesc>>(
                    "desc",
                    |m: &NativeCodeStatus| { &m.desc },
                    |m: &mut NativeCodeStatus| { &mut m.desc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "status",
                    |m: &NativeCodeStatus| { &m.status },
                    |m: &mut NativeCodeStatus| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "healthy",
                    |m: &NativeCodeStatus| { &m.healthy },
                    |m: &mut NativeCodeStatus| { &mut m.healthy },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<NativeCodeStatus>(
                    "NativeCodeStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NativeCodeStatus {
        static mut instance: ::protobuf::lazy::Lazy<NativeCodeStatus> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(NativeCodeStatus::new)
        }
    }
}

impl ::protobuf::Clear for NativeCodeStatus {
    fn clear(&mut self) {
        self.desc.clear();
        self.status = 0;
        self.healthy = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NativeCodeStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NativeCodeStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NativeCodeStatusRequest {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NativeCodeStatusRequest {
    fn default() -> &'a NativeCodeStatusRequest {
        <NativeCodeStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl NativeCodeStatusRequest {
    pub fn new() -> NativeCodeStatusRequest {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }
}

impl ::protobuf::Message for NativeCodeStatusRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NativeCodeStatusRequest {
        NativeCodeStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &NativeCodeStatusRequest| { &m.header },
                    |m: &mut NativeCodeStatusRequest| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &NativeCodeStatusRequest| { &m.bcname },
                    |m: &mut NativeCodeStatusRequest| { &mut m.bcname },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<NativeCodeStatusRequest>(
                    "NativeCodeStatusRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NativeCodeStatusRequest {
        static mut instance: ::protobuf::lazy::Lazy<NativeCodeStatusRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(NativeCodeStatusRequest::new)
        }
    }
}

impl ::protobuf::Clear for NativeCodeStatusRequest {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NativeCodeStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NativeCodeStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct NativeCodeStatusResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub status: ::protobuf::RepeatedField<NativeCodeStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a NativeCodeStatusResponse {
    fn default() -> &'a NativeCodeStatusResponse {
        <NativeCodeStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl NativeCodeStatusResponse {
    pub fn new() -> NativeCodeStatusResponse {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // repeated .pb.NativeCodeStatus status = 2;


    pub fn get_status(&self) -> &[NativeCodeStatus] {
        &self.status
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: ::protobuf::RepeatedField<NativeCodeStatus>) {
        self.status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_status(&mut self) -> &mut ::protobuf::RepeatedField<NativeCodeStatus> {
        &mut self.status
    }

    // Take field
    pub fn take_status(&mut self) -> ::protobuf::RepeatedField<NativeCodeStatus> {
        ::std::mem::replace(&mut self.status, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for NativeCodeStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.status {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.status {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> NativeCodeStatusResponse {
        NativeCodeStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &NativeCodeStatusResponse| { &m.header },
                    |m: &mut NativeCodeStatusResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<NativeCodeStatus>>(
                    "status",
                    |m: &NativeCodeStatusResponse| { &m.status },
                    |m: &mut NativeCodeStatusResponse| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<NativeCodeStatusResponse>(
                    "NativeCodeStatusResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static NativeCodeStatusResponse {
        static mut instance: ::protobuf::lazy::Lazy<NativeCodeStatusResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(NativeCodeStatusResponse::new)
        }
    }
}

impl ::protobuf::Clear for NativeCodeStatusResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for NativeCodeStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NativeCodeStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DposCandidatesRequest {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DposCandidatesRequest {
    fn default() -> &'a DposCandidatesRequest {
        <DposCandidatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl DposCandidatesRequest {
    pub fn new() -> DposCandidatesRequest {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DposCandidatesRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DposCandidatesRequest {
        DposCandidatesRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &DposCandidatesRequest| { &m.header },
                    |m: &mut DposCandidatesRequest| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &DposCandidatesRequest| { &m.bcname },
                    |m: &mut DposCandidatesRequest| { &mut m.bcname },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DposCandidatesRequest>(
                    "DposCandidatesRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DposCandidatesRequest {
        static mut instance: ::protobuf::lazy::Lazy<DposCandidatesRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DposCandidatesRequest::new)
        }
    }
}

impl ::protobuf::Clear for DposCandidatesRequest {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DposCandidatesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DposCandidatesRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DposCandidatesResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub candidatesInfo: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DposCandidatesResponse {
    fn default() -> &'a DposCandidatesResponse {
        <DposCandidatesResponse as ::protobuf::Message>::default_instance()
    }
}

impl DposCandidatesResponse {
    pub fn new() -> DposCandidatesResponse {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // repeated string candidatesInfo = 2;


    pub fn get_candidatesInfo(&self) -> &[::std::string::String] {
        &self.candidatesInfo
    }
    pub fn clear_candidatesInfo(&mut self) {
        self.candidatesInfo.clear();
    }

    // Param is passed by value, moved
    pub fn set_candidatesInfo(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.candidatesInfo = v;
    }

    // Mutable pointer to the field.
    pub fn mut_candidatesInfo(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.candidatesInfo
    }

    // Take field
    pub fn take_candidatesInfo(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.candidatesInfo, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DposCandidatesResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.candidatesInfo)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.candidatesInfo {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.candidatesInfo {
            os.write_string(2, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DposCandidatesResponse {
        DposCandidatesResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &DposCandidatesResponse| { &m.header },
                    |m: &mut DposCandidatesResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "candidatesInfo",
                    |m: &DposCandidatesResponse| { &m.candidatesInfo },
                    |m: &mut DposCandidatesResponse| { &mut m.candidatesInfo },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DposCandidatesResponse>(
                    "DposCandidatesResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DposCandidatesResponse {
        static mut instance: ::protobuf::lazy::Lazy<DposCandidatesResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DposCandidatesResponse::new)
        }
    }
}

impl ::protobuf::Clear for DposCandidatesResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.candidatesInfo.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DposCandidatesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DposCandidatesResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DposNominateRecordsRequest {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub address: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DposNominateRecordsRequest {
    fn default() -> &'a DposNominateRecordsRequest {
        <DposNominateRecordsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DposNominateRecordsRequest {
    pub fn new() -> DposNominateRecordsRequest {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DposNominateRecordsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DposNominateRecordsRequest {
        DposNominateRecordsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &DposNominateRecordsRequest| { &m.header },
                    |m: &mut DposNominateRecordsRequest| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &DposNominateRecordsRequest| { &m.bcname },
                    |m: &mut DposNominateRecordsRequest| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &DposNominateRecordsRequest| { &m.address },
                    |m: &mut DposNominateRecordsRequest| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DposNominateRecordsRequest>(
                    "DposNominateRecordsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DposNominateRecordsRequest {
        static mut instance: ::protobuf::lazy::Lazy<DposNominateRecordsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DposNominateRecordsRequest::new)
        }
    }
}

impl ::protobuf::Clear for DposNominateRecordsRequest {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DposNominateRecordsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DposNominateRecordsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DposNominateInfo {
    // message fields
    pub candidate: ::std::string::String,
    pub txid: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DposNominateInfo {
    fn default() -> &'a DposNominateInfo {
        <DposNominateInfo as ::protobuf::Message>::default_instance()
    }
}

impl DposNominateInfo {
    pub fn new() -> DposNominateInfo {
        ::std::default::Default::default()
    }

    // string candidate = 1;


    pub fn get_candidate(&self) -> &str {
        &self.candidate
    }
    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::std::string::String) {
        self.candidate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut ::std::string::String {
        &mut self.candidate
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.candidate, ::std::string::String::new())
    }

    // string txid = 2;


    pub fn get_txid(&self) -> &str {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::string::String) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::string::String {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.txid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DposNominateInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.candidate)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.candidate.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.candidate);
        }
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.candidate.is_empty() {
            os.write_string(1, &self.candidate)?;
        }
        if !self.txid.is_empty() {
            os.write_string(2, &self.txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DposNominateInfo {
        DposNominateInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "candidate",
                    |m: &DposNominateInfo| { &m.candidate },
                    |m: &mut DposNominateInfo| { &mut m.candidate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "txid",
                    |m: &DposNominateInfo| { &m.txid },
                    |m: &mut DposNominateInfo| { &mut m.txid },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DposNominateInfo>(
                    "DposNominateInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DposNominateInfo {
        static mut instance: ::protobuf::lazy::Lazy<DposNominateInfo> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DposNominateInfo::new)
        }
    }
}

impl ::protobuf::Clear for DposNominateInfo {
    fn clear(&mut self) {
        self.candidate.clear();
        self.txid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DposNominateInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DposNominateInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DposNominateRecordsResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub nominateRecords: ::protobuf::RepeatedField<DposNominateInfo>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DposNominateRecordsResponse {
    fn default() -> &'a DposNominateRecordsResponse {
        <DposNominateRecordsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DposNominateRecordsResponse {
    pub fn new() -> DposNominateRecordsResponse {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // repeated .pb.DposNominateInfo nominateRecords = 2;


    pub fn get_nominateRecords(&self) -> &[DposNominateInfo] {
        &self.nominateRecords
    }
    pub fn clear_nominateRecords(&mut self) {
        self.nominateRecords.clear();
    }

    // Param is passed by value, moved
    pub fn set_nominateRecords(&mut self, v: ::protobuf::RepeatedField<DposNominateInfo>) {
        self.nominateRecords = v;
    }

    // Mutable pointer to the field.
    pub fn mut_nominateRecords(&mut self) -> &mut ::protobuf::RepeatedField<DposNominateInfo> {
        &mut self.nominateRecords
    }

    // Take field
    pub fn take_nominateRecords(&mut self) -> ::protobuf::RepeatedField<DposNominateInfo> {
        ::std::mem::replace(&mut self.nominateRecords, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DposNominateRecordsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.nominateRecords {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.nominateRecords)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.nominateRecords {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.nominateRecords {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DposNominateRecordsResponse {
        DposNominateRecordsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &DposNominateRecordsResponse| { &m.header },
                    |m: &mut DposNominateRecordsResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DposNominateInfo>>(
                    "nominateRecords",
                    |m: &DposNominateRecordsResponse| { &m.nominateRecords },
                    |m: &mut DposNominateRecordsResponse| { &mut m.nominateRecords },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DposNominateRecordsResponse>(
                    "DposNominateRecordsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DposNominateRecordsResponse {
        static mut instance: ::protobuf::lazy::Lazy<DposNominateRecordsResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DposNominateRecordsResponse::new)
        }
    }
}

impl ::protobuf::Clear for DposNominateRecordsResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.nominateRecords.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DposNominateRecordsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DposNominateRecordsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DposNomineeRecordsRequest {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub address: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DposNomineeRecordsRequest {
    fn default() -> &'a DposNomineeRecordsRequest {
        <DposNomineeRecordsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DposNomineeRecordsRequest {
    pub fn new() -> DposNomineeRecordsRequest {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DposNomineeRecordsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DposNomineeRecordsRequest {
        DposNomineeRecordsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &DposNomineeRecordsRequest| { &m.header },
                    |m: &mut DposNomineeRecordsRequest| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &DposNomineeRecordsRequest| { &m.bcname },
                    |m: &mut DposNomineeRecordsRequest| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &DposNomineeRecordsRequest| { &m.address },
                    |m: &mut DposNomineeRecordsRequest| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DposNomineeRecordsRequest>(
                    "DposNomineeRecordsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DposNomineeRecordsRequest {
        static mut instance: ::protobuf::lazy::Lazy<DposNomineeRecordsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DposNomineeRecordsRequest::new)
        }
    }
}

impl ::protobuf::Clear for DposNomineeRecordsRequest {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DposNomineeRecordsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DposNomineeRecordsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DposNomineeRecordsResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub txid: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DposNomineeRecordsResponse {
    fn default() -> &'a DposNomineeRecordsResponse {
        <DposNomineeRecordsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DposNomineeRecordsResponse {
    pub fn new() -> DposNomineeRecordsResponse {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string txid = 2;


    pub fn get_txid(&self) -> &str {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::string::String) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::string::String {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.txid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DposNomineeRecordsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.txid.is_empty() {
            os.write_string(2, &self.txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DposNomineeRecordsResponse {
        DposNomineeRecordsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &DposNomineeRecordsResponse| { &m.header },
                    |m: &mut DposNomineeRecordsResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "txid",
                    |m: &DposNomineeRecordsResponse| { &m.txid },
                    |m: &mut DposNomineeRecordsResponse| { &mut m.txid },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DposNomineeRecordsResponse>(
                    "DposNomineeRecordsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DposNomineeRecordsResponse {
        static mut instance: ::protobuf::lazy::Lazy<DposNomineeRecordsResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DposNomineeRecordsResponse::new)
        }
    }
}

impl ::protobuf::Clear for DposNomineeRecordsResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.txid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DposNomineeRecordsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DposNomineeRecordsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DposVoteRecordsRequest {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub address: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DposVoteRecordsRequest {
    fn default() -> &'a DposVoteRecordsRequest {
        <DposVoteRecordsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DposVoteRecordsRequest {
    pub fn new() -> DposVoteRecordsRequest {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DposVoteRecordsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DposVoteRecordsRequest {
        DposVoteRecordsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &DposVoteRecordsRequest| { &m.header },
                    |m: &mut DposVoteRecordsRequest| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &DposVoteRecordsRequest| { &m.bcname },
                    |m: &mut DposVoteRecordsRequest| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &DposVoteRecordsRequest| { &m.address },
                    |m: &mut DposVoteRecordsRequest| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DposVoteRecordsRequest>(
                    "DposVoteRecordsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DposVoteRecordsRequest {
        static mut instance: ::protobuf::lazy::Lazy<DposVoteRecordsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DposVoteRecordsRequest::new)
        }
    }
}

impl ::protobuf::Clear for DposVoteRecordsRequest {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DposVoteRecordsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DposVoteRecordsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct voteRecord {
    // message fields
    pub candidate: ::std::string::String,
    pub txid: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a voteRecord {
    fn default() -> &'a voteRecord {
        <voteRecord as ::protobuf::Message>::default_instance()
    }
}

impl voteRecord {
    pub fn new() -> voteRecord {
        ::std::default::Default::default()
    }

    // string candidate = 1;


    pub fn get_candidate(&self) -> &str {
        &self.candidate
    }
    pub fn clear_candidate(&mut self) {
        self.candidate.clear();
    }

    // Param is passed by value, moved
    pub fn set_candidate(&mut self, v: ::std::string::String) {
        self.candidate = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_candidate(&mut self) -> &mut ::std::string::String {
        &mut self.candidate
    }

    // Take field
    pub fn take_candidate(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.candidate, ::std::string::String::new())
    }

    // string txid = 2;


    pub fn get_txid(&self) -> &str {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::string::String) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::string::String {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.txid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for voteRecord {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.candidate)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.candidate.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.candidate);
        }
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.candidate.is_empty() {
            os.write_string(1, &self.candidate)?;
        }
        if !self.txid.is_empty() {
            os.write_string(2, &self.txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> voteRecord {
        voteRecord::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "candidate",
                    |m: &voteRecord| { &m.candidate },
                    |m: &mut voteRecord| { &mut m.candidate },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "txid",
                    |m: &voteRecord| { &m.txid },
                    |m: &mut voteRecord| { &mut m.txid },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<voteRecord>(
                    "voteRecord",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static voteRecord {
        static mut instance: ::protobuf::lazy::Lazy<voteRecord> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(voteRecord::new)
        }
    }
}

impl ::protobuf::Clear for voteRecord {
    fn clear(&mut self) {
        self.candidate.clear();
        self.txid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for voteRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for voteRecord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DposVoteRecordsResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub voteTxidRecords: ::protobuf::RepeatedField<voteRecord>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DposVoteRecordsResponse {
    fn default() -> &'a DposVoteRecordsResponse {
        <DposVoteRecordsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DposVoteRecordsResponse {
    pub fn new() -> DposVoteRecordsResponse {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // repeated .pb.voteRecord voteTxidRecords = 2;


    pub fn get_voteTxidRecords(&self) -> &[voteRecord] {
        &self.voteTxidRecords
    }
    pub fn clear_voteTxidRecords(&mut self) {
        self.voteTxidRecords.clear();
    }

    // Param is passed by value, moved
    pub fn set_voteTxidRecords(&mut self, v: ::protobuf::RepeatedField<voteRecord>) {
        self.voteTxidRecords = v;
    }

    // Mutable pointer to the field.
    pub fn mut_voteTxidRecords(&mut self) -> &mut ::protobuf::RepeatedField<voteRecord> {
        &mut self.voteTxidRecords
    }

    // Take field
    pub fn take_voteTxidRecords(&mut self) -> ::protobuf::RepeatedField<voteRecord> {
        ::std::mem::replace(&mut self.voteTxidRecords, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DposVoteRecordsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.voteTxidRecords {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.voteTxidRecords)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.voteTxidRecords {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.voteTxidRecords {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DposVoteRecordsResponse {
        DposVoteRecordsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &DposVoteRecordsResponse| { &m.header },
                    |m: &mut DposVoteRecordsResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<voteRecord>>(
                    "voteTxidRecords",
                    |m: &DposVoteRecordsResponse| { &m.voteTxidRecords },
                    |m: &mut DposVoteRecordsResponse| { &mut m.voteTxidRecords },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DposVoteRecordsResponse>(
                    "DposVoteRecordsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DposVoteRecordsResponse {
        static mut instance: ::protobuf::lazy::Lazy<DposVoteRecordsResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DposVoteRecordsResponse::new)
        }
    }
}

impl ::protobuf::Clear for DposVoteRecordsResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.voteTxidRecords.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DposVoteRecordsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DposVoteRecordsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DposVotedRecordsRequest {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub address: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DposVotedRecordsRequest {
    fn default() -> &'a DposVotedRecordsRequest {
        <DposVotedRecordsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DposVotedRecordsRequest {
    pub fn new() -> DposVotedRecordsRequest {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DposVotedRecordsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DposVotedRecordsRequest {
        DposVotedRecordsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &DposVotedRecordsRequest| { &m.header },
                    |m: &mut DposVotedRecordsRequest| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &DposVotedRecordsRequest| { &m.bcname },
                    |m: &mut DposVotedRecordsRequest| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &DposVotedRecordsRequest| { &m.address },
                    |m: &mut DposVotedRecordsRequest| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DposVotedRecordsRequest>(
                    "DposVotedRecordsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DposVotedRecordsRequest {
        static mut instance: ::protobuf::lazy::Lazy<DposVotedRecordsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DposVotedRecordsRequest::new)
        }
    }
}

impl ::protobuf::Clear for DposVotedRecordsRequest {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DposVotedRecordsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DposVotedRecordsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct votedRecord {
    // message fields
    pub voter: ::std::string::String,
    pub txid: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a votedRecord {
    fn default() -> &'a votedRecord {
        <votedRecord as ::protobuf::Message>::default_instance()
    }
}

impl votedRecord {
    pub fn new() -> votedRecord {
        ::std::default::Default::default()
    }

    // string voter = 1;


    pub fn get_voter(&self) -> &str {
        &self.voter
    }
    pub fn clear_voter(&mut self) {
        self.voter.clear();
    }

    // Param is passed by value, moved
    pub fn set_voter(&mut self, v: ::std::string::String) {
        self.voter = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_voter(&mut self) -> &mut ::std::string::String {
        &mut self.voter
    }

    // Take field
    pub fn take_voter(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.voter, ::std::string::String::new())
    }

    // string txid = 2;


    pub fn get_txid(&self) -> &str {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::string::String) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::string::String {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.txid, ::std::string::String::new())
    }
}

impl ::protobuf::Message for votedRecord {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.voter)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.txid)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.voter.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.voter);
        }
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.txid);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.voter.is_empty() {
            os.write_string(1, &self.voter)?;
        }
        if !self.txid.is_empty() {
            os.write_string(2, &self.txid)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> votedRecord {
        votedRecord::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "voter",
                    |m: &votedRecord| { &m.voter },
                    |m: &mut votedRecord| { &mut m.voter },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "txid",
                    |m: &votedRecord| { &m.txid },
                    |m: &mut votedRecord| { &mut m.txid },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<votedRecord>(
                    "votedRecord",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static votedRecord {
        static mut instance: ::protobuf::lazy::Lazy<votedRecord> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(votedRecord::new)
        }
    }
}

impl ::protobuf::Clear for votedRecord {
    fn clear(&mut self) {
        self.voter.clear();
        self.txid.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for votedRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for votedRecord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DposVotedRecordsResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub votedTxidRecords: ::protobuf::RepeatedField<votedRecord>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DposVotedRecordsResponse {
    fn default() -> &'a DposVotedRecordsResponse {
        <DposVotedRecordsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DposVotedRecordsResponse {
    pub fn new() -> DposVotedRecordsResponse {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // repeated .pb.votedRecord votedTxidRecords = 2;


    pub fn get_votedTxidRecords(&self) -> &[votedRecord] {
        &self.votedTxidRecords
    }
    pub fn clear_votedTxidRecords(&mut self) {
        self.votedTxidRecords.clear();
    }

    // Param is passed by value, moved
    pub fn set_votedTxidRecords(&mut self, v: ::protobuf::RepeatedField<votedRecord>) {
        self.votedTxidRecords = v;
    }

    // Mutable pointer to the field.
    pub fn mut_votedTxidRecords(&mut self) -> &mut ::protobuf::RepeatedField<votedRecord> {
        &mut self.votedTxidRecords
    }

    // Take field
    pub fn take_votedTxidRecords(&mut self) -> ::protobuf::RepeatedField<votedRecord> {
        ::std::mem::replace(&mut self.votedTxidRecords, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DposVotedRecordsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.votedTxidRecords {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.votedTxidRecords)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.votedTxidRecords {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.votedTxidRecords {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DposVotedRecordsResponse {
        DposVotedRecordsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &DposVotedRecordsResponse| { &m.header },
                    |m: &mut DposVotedRecordsResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<votedRecord>>(
                    "votedTxidRecords",
                    |m: &DposVotedRecordsResponse| { &m.votedTxidRecords },
                    |m: &mut DposVotedRecordsResponse| { &mut m.votedTxidRecords },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DposVotedRecordsResponse>(
                    "DposVotedRecordsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DposVotedRecordsResponse {
        static mut instance: ::protobuf::lazy::Lazy<DposVotedRecordsResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DposVotedRecordsResponse::new)
        }
    }
}

impl ::protobuf::Clear for DposVotedRecordsResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.votedTxidRecords.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DposVotedRecordsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DposVotedRecordsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DposCheckResultsRequest {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub term: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DposCheckResultsRequest {
    fn default() -> &'a DposCheckResultsRequest {
        <DposCheckResultsRequest as ::protobuf::Message>::default_instance()
    }
}

impl DposCheckResultsRequest {
    pub fn new() -> DposCheckResultsRequest {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // int64 term = 3;


    pub fn get_term(&self) -> i64 {
        self.term
    }
    pub fn clear_term(&mut self) {
        self.term = 0;
    }

    // Param is passed by value, moved
    pub fn set_term(&mut self, v: i64) {
        self.term = v;
    }
}

impl ::protobuf::Message for DposCheckResultsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.term = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if self.term != 0 {
            my_size += ::protobuf::rt::value_size(3, self.term, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if self.term != 0 {
            os.write_int64(3, self.term)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DposCheckResultsRequest {
        DposCheckResultsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &DposCheckResultsRequest| { &m.header },
                    |m: &mut DposCheckResultsRequest| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &DposCheckResultsRequest| { &m.bcname },
                    |m: &mut DposCheckResultsRequest| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "term",
                    |m: &DposCheckResultsRequest| { &m.term },
                    |m: &mut DposCheckResultsRequest| { &mut m.term },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DposCheckResultsRequest>(
                    "DposCheckResultsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DposCheckResultsRequest {
        static mut instance: ::protobuf::lazy::Lazy<DposCheckResultsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DposCheckResultsRequest::new)
        }
    }
}

impl ::protobuf::Clear for DposCheckResultsRequest {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.term = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DposCheckResultsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DposCheckResultsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DposCheckResultsResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub term: i64,
    pub checkResult: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DposCheckResultsResponse {
    fn default() -> &'a DposCheckResultsResponse {
        <DposCheckResultsResponse as ::protobuf::Message>::default_instance()
    }
}

impl DposCheckResultsResponse {
    pub fn new() -> DposCheckResultsResponse {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // int64 term = 2;


    pub fn get_term(&self) -> i64 {
        self.term
    }
    pub fn clear_term(&mut self) {
        self.term = 0;
    }

    // Param is passed by value, moved
    pub fn set_term(&mut self, v: i64) {
        self.term = v;
    }

    // repeated string checkResult = 3;


    pub fn get_checkResult(&self) -> &[::std::string::String] {
        &self.checkResult
    }
    pub fn clear_checkResult(&mut self) {
        self.checkResult.clear();
    }

    // Param is passed by value, moved
    pub fn set_checkResult(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.checkResult = v;
    }

    // Mutable pointer to the field.
    pub fn mut_checkResult(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.checkResult
    }

    // Take field
    pub fn take_checkResult(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.checkResult, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DposCheckResultsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.term = tmp;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.checkResult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.term != 0 {
            my_size += ::protobuf::rt::value_size(2, self.term, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.checkResult {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.term != 0 {
            os.write_int64(2, self.term)?;
        }
        for v in &self.checkResult {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DposCheckResultsResponse {
        DposCheckResultsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &DposCheckResultsResponse| { &m.header },
                    |m: &mut DposCheckResultsResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "term",
                    |m: &DposCheckResultsResponse| { &m.term },
                    |m: &mut DposCheckResultsResponse| { &mut m.term },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "checkResult",
                    |m: &DposCheckResultsResponse| { &m.checkResult },
                    |m: &mut DposCheckResultsResponse| { &mut m.checkResult },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DposCheckResultsResponse>(
                    "DposCheckResultsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DposCheckResultsResponse {
        static mut instance: ::protobuf::lazy::Lazy<DposCheckResultsResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DposCheckResultsResponse::new)
        }
    }
}

impl ::protobuf::Clear for DposCheckResultsResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.term = 0;
        self.checkResult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DposCheckResultsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DposCheckResultsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DposStatusRequest {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DposStatusRequest {
    fn default() -> &'a DposStatusRequest {
        <DposStatusRequest as ::protobuf::Message>::default_instance()
    }
}

impl DposStatusRequest {
    pub fn new() -> DposStatusRequest {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }
}

impl ::protobuf::Message for DposStatusRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DposStatusRequest {
        DposStatusRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &DposStatusRequest| { &m.header },
                    |m: &mut DposStatusRequest| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &DposStatusRequest| { &m.bcname },
                    |m: &mut DposStatusRequest| { &mut m.bcname },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DposStatusRequest>(
                    "DposStatusRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DposStatusRequest {
        static mut instance: ::protobuf::lazy::Lazy<DposStatusRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DposStatusRequest::new)
        }
    }
}

impl ::protobuf::Clear for DposStatusRequest {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DposStatusRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DposStatusRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DposStatusResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub status: ::protobuf::SingularPtrField<DposStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DposStatusResponse {
    fn default() -> &'a DposStatusResponse {
        <DposStatusResponse as ::protobuf::Message>::default_instance()
    }
}

impl DposStatusResponse {
    pub fn new() -> DposStatusResponse {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // .pb.DposStatus status = 2;


    pub fn get_status(&self) -> &DposStatus {
        self.status.as_ref().unwrap_or_else(|| DposStatus::default_instance())
    }
    pub fn clear_status(&mut self) {
        self.status.clear();
    }

    pub fn has_status(&self) -> bool {
        self.status.is_some()
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: DposStatus) {
        self.status = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_status(&mut self) -> &mut DposStatus {
        if self.status.is_none() {
            self.status.set_default();
        }
        self.status.as_mut().unwrap()
    }

    // Take field
    pub fn take_status(&mut self) -> DposStatus {
        self.status.take().unwrap_or_else(|| DposStatus::new())
    }
}

impl ::protobuf::Message for DposStatusResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.status.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.status.as_ref() {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DposStatusResponse {
        DposStatusResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &DposStatusResponse| { &m.header },
                    |m: &mut DposStatusResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<DposStatus>>(
                    "status",
                    |m: &DposStatusResponse| { &m.status },
                    |m: &mut DposStatusResponse| { &mut m.status },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DposStatusResponse>(
                    "DposStatusResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DposStatusResponse {
        static mut instance: ::protobuf::lazy::Lazy<DposStatusResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DposStatusResponse::new)
        }
    }
}

impl ::protobuf::Clear for DposStatusResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DposStatusResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DposStatusResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct DposStatus {
    // message fields
    pub term: i64,
    pub block_num: i64,
    pub proposer: ::std::string::String,
    pub proposer_num: i64,
    pub checkResult: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a DposStatus {
    fn default() -> &'a DposStatus {
        <DposStatus as ::protobuf::Message>::default_instance()
    }
}

impl DposStatus {
    pub fn new() -> DposStatus {
        ::std::default::Default::default()
    }

    // int64 term = 1;


    pub fn get_term(&self) -> i64 {
        self.term
    }
    pub fn clear_term(&mut self) {
        self.term = 0;
    }

    // Param is passed by value, moved
    pub fn set_term(&mut self, v: i64) {
        self.term = v;
    }

    // int64 block_num = 2;


    pub fn get_block_num(&self) -> i64 {
        self.block_num
    }
    pub fn clear_block_num(&mut self) {
        self.block_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_block_num(&mut self, v: i64) {
        self.block_num = v;
    }

    // string proposer = 3;


    pub fn get_proposer(&self) -> &str {
        &self.proposer
    }
    pub fn clear_proposer(&mut self) {
        self.proposer.clear();
    }

    // Param is passed by value, moved
    pub fn set_proposer(&mut self, v: ::std::string::String) {
        self.proposer = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_proposer(&mut self) -> &mut ::std::string::String {
        &mut self.proposer
    }

    // Take field
    pub fn take_proposer(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.proposer, ::std::string::String::new())
    }

    // int64 proposer_num = 4;


    pub fn get_proposer_num(&self) -> i64 {
        self.proposer_num
    }
    pub fn clear_proposer_num(&mut self) {
        self.proposer_num = 0;
    }

    // Param is passed by value, moved
    pub fn set_proposer_num(&mut self, v: i64) {
        self.proposer_num = v;
    }

    // repeated string checkResult = 5;


    pub fn get_checkResult(&self) -> &[::std::string::String] {
        &self.checkResult
    }
    pub fn clear_checkResult(&mut self) {
        self.checkResult.clear();
    }

    // Param is passed by value, moved
    pub fn set_checkResult(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.checkResult = v;
    }

    // Mutable pointer to the field.
    pub fn mut_checkResult(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.checkResult
    }

    // Take field
    pub fn take_checkResult(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.checkResult, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for DposStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.term = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.block_num = tmp;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.proposer)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.proposer_num = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.checkResult)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.term != 0 {
            my_size += ::protobuf::rt::value_size(1, self.term, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.block_num != 0 {
            my_size += ::protobuf::rt::value_size(2, self.block_num, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.proposer.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.proposer);
        }
        if self.proposer_num != 0 {
            my_size += ::protobuf::rt::value_size(4, self.proposer_num, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.checkResult {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.term != 0 {
            os.write_int64(1, self.term)?;
        }
        if self.block_num != 0 {
            os.write_int64(2, self.block_num)?;
        }
        if !self.proposer.is_empty() {
            os.write_string(3, &self.proposer)?;
        }
        if self.proposer_num != 0 {
            os.write_int64(4, self.proposer_num)?;
        }
        for v in &self.checkResult {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> DposStatus {
        DposStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "term",
                    |m: &DposStatus| { &m.term },
                    |m: &mut DposStatus| { &mut m.term },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "block_num",
                    |m: &DposStatus| { &m.block_num },
                    |m: &mut DposStatus| { &mut m.block_num },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "proposer",
                    |m: &DposStatus| { &m.proposer },
                    |m: &mut DposStatus| { &mut m.proposer },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "proposer_num",
                    |m: &DposStatus| { &m.proposer_num },
                    |m: &mut DposStatus| { &mut m.proposer_num },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "checkResult",
                    |m: &DposStatus| { &m.checkResult },
                    |m: &mut DposStatus| { &mut m.checkResult },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<DposStatus>(
                    "DposStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static DposStatus {
        static mut instance: ::protobuf::lazy::Lazy<DposStatus> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(DposStatus::new)
        }
    }
}

impl ::protobuf::Clear for DposStatus {
    fn clear(&mut self) {
        self.term = 0;
        self.block_num = 0;
        self.proposer.clear();
        self.proposer_num = 0;
        self.checkResult.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for DposStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DposStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct InvokeRPCRequest {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub requests: ::protobuf::RepeatedField<InvokeRequest>,
    pub initiator: ::std::string::String,
    pub auth_require: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InvokeRPCRequest {
    fn default() -> &'a InvokeRPCRequest {
        <InvokeRPCRequest as ::protobuf::Message>::default_instance()
    }
}

impl InvokeRPCRequest {
    pub fn new() -> InvokeRPCRequest {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // repeated .pb.InvokeRequest requests = 3;


    pub fn get_requests(&self) -> &[InvokeRequest] {
        &self.requests
    }
    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::protobuf::RepeatedField<InvokeRequest>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::protobuf::RepeatedField<InvokeRequest> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::protobuf::RepeatedField<InvokeRequest> {
        ::std::mem::replace(&mut self.requests, ::protobuf::RepeatedField::new())
    }

    // string initiator = 4;


    pub fn get_initiator(&self) -> &str {
        &self.initiator
    }
    pub fn clear_initiator(&mut self) {
        self.initiator.clear();
    }

    // Param is passed by value, moved
    pub fn set_initiator(&mut self, v: ::std::string::String) {
        self.initiator = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_initiator(&mut self) -> &mut ::std::string::String {
        &mut self.initiator
    }

    // Take field
    pub fn take_initiator(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.initiator, ::std::string::String::new())
    }

    // repeated string auth_require = 5;


    pub fn get_auth_require(&self) -> &[::std::string::String] {
        &self.auth_require
    }
    pub fn clear_auth_require(&mut self) {
        self.auth_require.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth_require(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.auth_require = v;
    }

    // Mutable pointer to the field.
    pub fn mut_auth_require(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.auth_require
    }

    // Take field
    pub fn take_auth_require(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.auth_require, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for InvokeRPCRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.requests {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requests)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.initiator)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.auth_require)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        for value in &self.requests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.initiator.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.initiator);
        }
        for value in &self.auth_require {
            my_size += ::protobuf::rt::string_size(5, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        for v in &self.requests {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.initiator.is_empty() {
            os.write_string(4, &self.initiator)?;
        }
        for v in &self.auth_require {
            os.write_string(5, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InvokeRPCRequest {
        InvokeRPCRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &InvokeRPCRequest| { &m.header },
                    |m: &mut InvokeRPCRequest| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &InvokeRPCRequest| { &m.bcname },
                    |m: &mut InvokeRPCRequest| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InvokeRequest>>(
                    "requests",
                    |m: &InvokeRPCRequest| { &m.requests },
                    |m: &mut InvokeRPCRequest| { &mut m.requests },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "initiator",
                    |m: &InvokeRPCRequest| { &m.initiator },
                    |m: &mut InvokeRPCRequest| { &mut m.initiator },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "auth_require",
                    |m: &InvokeRPCRequest| { &m.auth_require },
                    |m: &mut InvokeRPCRequest| { &mut m.auth_require },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<InvokeRPCRequest>(
                    "InvokeRPCRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InvokeRPCRequest {
        static mut instance: ::protobuf::lazy::Lazy<InvokeRPCRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(InvokeRPCRequest::new)
        }
    }
}

impl ::protobuf::Clear for InvokeRPCRequest {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.requests.clear();
        self.initiator.clear();
        self.auth_require.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InvokeRPCRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvokeRPCRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct InvokeRPCResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub response: ::protobuf::SingularPtrField<InvokeResponse>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InvokeRPCResponse {
    fn default() -> &'a InvokeRPCResponse {
        <InvokeRPCResponse as ::protobuf::Message>::default_instance()
    }
}

impl InvokeRPCResponse {
    pub fn new() -> InvokeRPCResponse {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // .pb.InvokeResponse response = 3;


    pub fn get_response(&self) -> &InvokeResponse {
        self.response.as_ref().unwrap_or_else(|| InvokeResponse::default_instance())
    }
    pub fn clear_response(&mut self) {
        self.response.clear();
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: InvokeResponse) {
        self.response = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut InvokeResponse {
        if self.response.is_none() {
            self.response.set_default();
        }
        self.response.as_mut().unwrap()
    }

    // Take field
    pub fn take_response(&mut self) -> InvokeResponse {
        self.response.take().unwrap_or_else(|| InvokeResponse::new())
    }
}

impl ::protobuf::Message for InvokeRPCResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.response)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if let Some(ref v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if let Some(ref v) = self.response.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InvokeRPCResponse {
        InvokeRPCResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &InvokeRPCResponse| { &m.header },
                    |m: &mut InvokeRPCResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &InvokeRPCResponse| { &m.bcname },
                    |m: &mut InvokeRPCResponse| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InvokeResponse>>(
                    "response",
                    |m: &InvokeRPCResponse| { &m.response },
                    |m: &mut InvokeRPCResponse| { &mut m.response },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<InvokeRPCResponse>(
                    "InvokeRPCResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InvokeRPCResponse {
        static mut instance: ::protobuf::lazy::Lazy<InvokeRPCResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(InvokeRPCResponse::new)
        }
    }
}

impl ::protobuf::Clear for InvokeRPCResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.response.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InvokeRPCResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvokeRPCResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct InvokeRequest {
    // message fields
    pub module_name: ::std::string::String,
    pub contract_name: ::std::string::String,
    pub method_name: ::std::string::String,
    #[serde(serialize_with = "crate::wallet::serialize_ordered_map")]
    #[serde(deserialize_with = "crate::wallet::deserialize_ordered_map")]
    pub args: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>,
    pub resource_limits: ::protobuf::RepeatedField<ResourceLimit>,
    pub amount: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InvokeRequest {
    fn default() -> &'a InvokeRequest {
        <InvokeRequest as ::protobuf::Message>::default_instance()
    }
}

impl InvokeRequest {
    pub fn new() -> InvokeRequest {
        ::std::default::Default::default()
    }

    // string module_name = 1;


    pub fn get_module_name(&self) -> &str {
        &self.module_name
    }
    pub fn clear_module_name(&mut self) {
        self.module_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_module_name(&mut self, v: ::std::string::String) {
        self.module_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_module_name(&mut self) -> &mut ::std::string::String {
        &mut self.module_name
    }

    // Take field
    pub fn take_module_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.module_name, ::std::string::String::new())
    }

    // string contract_name = 2;


    pub fn get_contract_name(&self) -> &str {
        &self.contract_name
    }
    pub fn clear_contract_name(&mut self) {
        self.contract_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_name(&mut self, v: ::std::string::String) {
        self.contract_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_name(&mut self) -> &mut ::std::string::String {
        &mut self.contract_name
    }

    // Take field
    pub fn take_contract_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contract_name, ::std::string::String::new())
    }

    // string method_name = 3;


    pub fn get_method_name(&self) -> &str {
        &self.method_name
    }
    pub fn clear_method_name(&mut self) {
        self.method_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_method_name(&mut self, v: ::std::string::String) {
        self.method_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_method_name(&mut self) -> &mut ::std::string::String {
        &mut self.method_name
    }

    // Take field
    pub fn take_method_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.method_name, ::std::string::String::new())
    }

    // repeated .pb.InvokeRequest.ArgsEntry args = 4;


    pub fn get_args(&self) -> &::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        &self.args
    }
    pub fn clear_args(&mut self) {
        self.args.clear();
    }

    // Param is passed by value, moved
    pub fn set_args(&mut self, v: ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>>) {
        self.args = v;
    }

    // Mutable pointer to the field.
    pub fn mut_args(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        &mut self.args
    }

    // Take field
    pub fn take_args(&mut self) -> ::std::collections::HashMap<::std::string::String, ::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.args, ::std::collections::HashMap::new())
    }

    // repeated .pb.ResourceLimit resource_limits = 5;


    pub fn get_resource_limits(&self) -> &[ResourceLimit] {
        &self.resource_limits
    }
    pub fn clear_resource_limits(&mut self) {
        self.resource_limits.clear();
    }

    // Param is passed by value, moved
    pub fn set_resource_limits(&mut self, v: ::protobuf::RepeatedField<ResourceLimit>) {
        self.resource_limits = v;
    }

    // Mutable pointer to the field.
    pub fn mut_resource_limits(&mut self) -> &mut ::protobuf::RepeatedField<ResourceLimit> {
        &mut self.resource_limits
    }

    // Take field
    pub fn take_resource_limits(&mut self) -> ::protobuf::RepeatedField<ResourceLimit> {
        ::std::mem::replace(&mut self.resource_limits, ::protobuf::RepeatedField::new())
    }

    // string amount = 6;


    pub fn get_amount(&self) -> &str {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::string::String) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::string::String {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.amount, ::std::string::String::new())
    }
}

impl ::protobuf::Message for InvokeRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.resource_limits {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.module_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.contract_name)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.method_name)?;
                },
                4 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(wire_type, is, &mut self.args)?;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.resource_limits)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.module_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.module_name);
        }
        if !self.contract_name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.contract_name);
        }
        if !self.method_name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.method_name);
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(4, &self.args);
        for value in &self.resource_limits {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.amount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.module_name.is_empty() {
            os.write_string(1, &self.module_name)?;
        }
        if !self.contract_name.is_empty() {
            os.write_string(2, &self.contract_name)?;
        }
        if !self.method_name.is_empty() {
            os.write_string(3, &self.method_name)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(4, &self.args, os)?;
        for v in &self.resource_limits {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        if !self.amount.is_empty() {
            os.write_string(6, &self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InvokeRequest {
        InvokeRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "module_name",
                    |m: &InvokeRequest| { &m.module_name },
                    |m: &mut InvokeRequest| { &mut m.module_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "contract_name",
                    |m: &InvokeRequest| { &m.contract_name },
                    |m: &mut InvokeRequest| { &mut m.contract_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "method_name",
                    |m: &InvokeRequest| { &m.method_name },
                    |m: &mut InvokeRequest| { &mut m.method_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeBytes>(
                    "args",
                    |m: &InvokeRequest| { &m.args },
                    |m: &mut InvokeRequest| { &mut m.args },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ResourceLimit>>(
                    "resource_limits",
                    |m: &InvokeRequest| { &m.resource_limits },
                    |m: &mut InvokeRequest| { &mut m.resource_limits },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "amount",
                    |m: &InvokeRequest| { &m.amount },
                    |m: &mut InvokeRequest| { &mut m.amount },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<InvokeRequest>(
                    "InvokeRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InvokeRequest {
        static mut instance: ::protobuf::lazy::Lazy<InvokeRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(InvokeRequest::new)
        }
    }
}

impl ::protobuf::Clear for InvokeRequest {
    fn clear(&mut self) {
        self.module_name.clear();
        self.contract_name.clear();
        self.method_name.clear();
        self.args.clear();
        self.resource_limits.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InvokeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvokeRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct InvokeResponse {
    // message fields
    #[serde(default)]
    pub inputs: ::protobuf::RepeatedField<TxInputExt>,
    #[serde(default)]
    pub outputs: ::protobuf::RepeatedField<TxOutputExt>,
    #[serde(default)]
    #[serde(serialize_with = "crate::wallet::serialize_bytes_arr")]
    #[serde(deserialize_with = "crate::wallet::deserialize_bytes_arr")]
    pub response: ::protobuf::RepeatedField<::std::vec::Vec<u8>>,
    #[serde(default)]
    pub gas_used: i64,
    #[serde(default)]
    pub requests: ::protobuf::RepeatedField<InvokeRequest>,
    #[serde(default)]
    pub responses: ::protobuf::RepeatedField<ContractResponse>,
    #[serde(default)]
    pub utxoInputs: ::protobuf::RepeatedField<TxInput>,
    #[serde(default)]
    pub utxoOutputs: ::protobuf::RepeatedField<TxOutput>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a InvokeResponse {
    fn default() -> &'a InvokeResponse {
        <InvokeResponse as ::protobuf::Message>::default_instance()
    }
}

impl InvokeResponse {
    pub fn new() -> InvokeResponse {
        ::std::default::Default::default()
    }

    // repeated .pb.TxInputExt inputs = 1;


    pub fn get_inputs(&self) -> &[TxInputExt] {
        &self.inputs
    }
    pub fn clear_inputs(&mut self) {
        self.inputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_inputs(&mut self, v: ::protobuf::RepeatedField<TxInputExt>) {
        self.inputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_inputs(&mut self) -> &mut ::protobuf::RepeatedField<TxInputExt> {
        &mut self.inputs
    }

    // Take field
    pub fn take_inputs(&mut self) -> ::protobuf::RepeatedField<TxInputExt> {
        ::std::mem::replace(&mut self.inputs, ::protobuf::RepeatedField::new())
    }

    // repeated .pb.TxOutputExt outputs = 2;


    pub fn get_outputs(&self) -> &[TxOutputExt] {
        &self.outputs
    }
    pub fn clear_outputs(&mut self) {
        self.outputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_outputs(&mut self, v: ::protobuf::RepeatedField<TxOutputExt>) {
        self.outputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_outputs(&mut self) -> &mut ::protobuf::RepeatedField<TxOutputExt> {
        &mut self.outputs
    }

    // Take field
    pub fn take_outputs(&mut self) -> ::protobuf::RepeatedField<TxOutputExt> {
        ::std::mem::replace(&mut self.outputs, ::protobuf::RepeatedField::new())
    }

    // repeated bytes response = 3;


    pub fn get_response(&self) -> &[::std::vec::Vec<u8>] {
        &self.response
    }
    pub fn clear_response(&mut self) {
        self.response.clear();
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: ::protobuf::RepeatedField<::std::vec::Vec<u8>>) {
        self.response = v;
    }

    // Mutable pointer to the field.
    pub fn mut_response(&mut self) -> &mut ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        &mut self.response
    }

    // Take field
    pub fn take_response(&mut self) -> ::protobuf::RepeatedField<::std::vec::Vec<u8>> {
        ::std::mem::replace(&mut self.response, ::protobuf::RepeatedField::new())
    }

    // int64 gas_used = 4;


    pub fn get_gas_used(&self) -> i64 {
        self.gas_used
    }
    pub fn clear_gas_used(&mut self) {
        self.gas_used = 0;
    }

    // Param is passed by value, moved
    pub fn set_gas_used(&mut self, v: i64) {
        self.gas_used = v;
    }

    // repeated .pb.InvokeRequest requests = 5;


    pub fn get_requests(&self) -> &[InvokeRequest] {
        &self.requests
    }
    pub fn clear_requests(&mut self) {
        self.requests.clear();
    }

    // Param is passed by value, moved
    pub fn set_requests(&mut self, v: ::protobuf::RepeatedField<InvokeRequest>) {
        self.requests = v;
    }

    // Mutable pointer to the field.
    pub fn mut_requests(&mut self) -> &mut ::protobuf::RepeatedField<InvokeRequest> {
        &mut self.requests
    }

    // Take field
    pub fn take_requests(&mut self) -> ::protobuf::RepeatedField<InvokeRequest> {
        ::std::mem::replace(&mut self.requests, ::protobuf::RepeatedField::new())
    }

    // repeated .pb.ContractResponse responses = 6;


    pub fn get_responses(&self) -> &[ContractResponse] {
        &self.responses
    }
    pub fn clear_responses(&mut self) {
        self.responses.clear();
    }

    // Param is passed by value, moved
    pub fn set_responses(&mut self, v: ::protobuf::RepeatedField<ContractResponse>) {
        self.responses = v;
    }

    // Mutable pointer to the field.
    pub fn mut_responses(&mut self) -> &mut ::protobuf::RepeatedField<ContractResponse> {
        &mut self.responses
    }

    // Take field
    pub fn take_responses(&mut self) -> ::protobuf::RepeatedField<ContractResponse> {
        ::std::mem::replace(&mut self.responses, ::protobuf::RepeatedField::new())
    }

    // repeated .pb.TxInput utxoInputs = 7;


    pub fn get_utxoInputs(&self) -> &[TxInput] {
        &self.utxoInputs
    }
    pub fn clear_utxoInputs(&mut self) {
        self.utxoInputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_utxoInputs(&mut self, v: ::protobuf::RepeatedField<TxInput>) {
        self.utxoInputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_utxoInputs(&mut self) -> &mut ::protobuf::RepeatedField<TxInput> {
        &mut self.utxoInputs
    }

    // Take field
    pub fn take_utxoInputs(&mut self) -> ::protobuf::RepeatedField<TxInput> {
        ::std::mem::replace(&mut self.utxoInputs, ::protobuf::RepeatedField::new())
    }

    // repeated .pb.TxOutput utxoOutputs = 8;


    pub fn get_utxoOutputs(&self) -> &[TxOutput] {
        &self.utxoOutputs
    }
    pub fn clear_utxoOutputs(&mut self) {
        self.utxoOutputs.clear();
    }

    // Param is passed by value, moved
    pub fn set_utxoOutputs(&mut self, v: ::protobuf::RepeatedField<TxOutput>) {
        self.utxoOutputs = v;
    }

    // Mutable pointer to the field.
    pub fn mut_utxoOutputs(&mut self) -> &mut ::protobuf::RepeatedField<TxOutput> {
        &mut self.utxoOutputs
    }

    // Take field
    pub fn take_utxoOutputs(&mut self) -> ::protobuf::RepeatedField<TxOutput> {
        ::std::mem::replace(&mut self.utxoOutputs, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for InvokeResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.inputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.outputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.requests {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.responses {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.utxoInputs {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.utxoOutputs {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.inputs)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.outputs)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_bytes_into(wire_type, is, &mut self.response)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.gas_used = tmp;
                },
                5 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.requests)?;
                },
                6 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.responses)?;
                },
                7 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.utxoInputs)?;
                },
                8 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.utxoOutputs)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.inputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.outputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.response {
            my_size += ::protobuf::rt::bytes_size(3, &value);
        };
        if self.gas_used != 0 {
            my_size += ::protobuf::rt::value_size(4, self.gas_used, ::protobuf::wire_format::WireTypeVarint);
        }
        for value in &self.requests {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.responses {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.utxoInputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        for value in &self.utxoOutputs {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.inputs {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.outputs {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.response {
            os.write_bytes(3, &v)?;
        };
        if self.gas_used != 0 {
            os.write_int64(4, self.gas_used)?;
        }
        for v in &self.requests {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.responses {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.utxoInputs {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        for v in &self.utxoOutputs {
            os.write_tag(8, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> InvokeResponse {
        InvokeResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TxInputExt>>(
                    "inputs",
                    |m: &InvokeResponse| { &m.inputs },
                    |m: &mut InvokeResponse| { &mut m.inputs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TxOutputExt>>(
                    "outputs",
                    |m: &InvokeResponse| { &m.outputs },
                    |m: &mut InvokeResponse| { &mut m.outputs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "response",
                    |m: &InvokeResponse| { &m.response },
                    |m: &mut InvokeResponse| { &mut m.response },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "gas_used",
                    |m: &InvokeResponse| { &m.gas_used },
                    |m: &mut InvokeResponse| { &mut m.gas_used },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InvokeRequest>>(
                    "requests",
                    |m: &InvokeResponse| { &m.requests },
                    |m: &mut InvokeResponse| { &mut m.requests },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContractResponse>>(
                    "responses",
                    |m: &InvokeResponse| { &m.responses },
                    |m: &mut InvokeResponse| { &mut m.responses },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TxInput>>(
                    "utxoInputs",
                    |m: &InvokeResponse| { &m.utxoInputs },
                    |m: &mut InvokeResponse| { &mut m.utxoInputs },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<TxOutput>>(
                    "utxoOutputs",
                    |m: &InvokeResponse| { &m.utxoOutputs },
                    |m: &mut InvokeResponse| { &mut m.utxoOutputs },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<InvokeResponse>(
                    "InvokeResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static InvokeResponse {
        static mut instance: ::protobuf::lazy::Lazy<InvokeResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(InvokeResponse::new)
        }
    }
}

impl ::protobuf::Clear for InvokeResponse {
    fn clear(&mut self) {
        self.inputs.clear();
        self.outputs.clear();
        self.response.clear();
        self.gas_used = 0;
        self.requests.clear();
        self.responses.clear();
        self.utxoInputs.clear();
        self.utxoOutputs.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for InvokeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for InvokeResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TxInputExt {
    // message fields
    pub bucket: ::std::string::String,
    #[serde(serialize_with = "crate::wallet::serialize_bytes")]
    #[serde(deserialize_with = "crate::wallet::deserialize_bytes")]
    pub key: ::std::vec::Vec<u8>,
    #[serde(serialize_with = "crate::wallet::serialize_bytes")]
    #[serde(deserialize_with = "crate::wallet::deserialize_bytes")]
    pub ref_txid: ::std::vec::Vec<u8>,
    #[serde(default)]
    pub ref_offset: i32,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxInputExt {
    fn default() -> &'a TxInputExt {
        <TxInputExt as ::protobuf::Message>::default_instance()
    }
}

impl TxInputExt {
    pub fn new() -> TxInputExt {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // bytes key = 2;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes ref_txid = 3;


    pub fn get_ref_txid(&self) -> &[u8] {
        &self.ref_txid
    }
    pub fn clear_ref_txid(&mut self) {
        self.ref_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_ref_txid(&mut self, v: ::std::vec::Vec<u8>) {
        self.ref_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_ref_txid(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.ref_txid
    }

    // Take field
    pub fn take_ref_txid(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.ref_txid, ::std::vec::Vec::new())
    }

    // int32 ref_offset = 4;


    pub fn get_ref_offset(&self) -> i32 {
        self.ref_offset
    }
    pub fn clear_ref_offset(&mut self) {
        self.ref_offset = 0;
    }

    // Param is passed by value, moved
    pub fn set_ref_offset(&mut self, v: i32) {
        self.ref_offset = v;
    }
}

impl ::protobuf::Message for TxInputExt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.ref_txid)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.ref_offset = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        if !self.ref_txid.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.ref_txid);
        }
        if self.ref_offset != 0 {
            my_size += ::protobuf::rt::value_size(4, self.ref_offset, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        if !self.ref_txid.is_empty() {
            os.write_bytes(3, &self.ref_txid)?;
        }
        if self.ref_offset != 0 {
            os.write_int32(4, self.ref_offset)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxInputExt {
        TxInputExt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bucket",
                    |m: &TxInputExt| { &m.bucket },
                    |m: &mut TxInputExt| { &mut m.bucket },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "key",
                    |m: &TxInputExt| { &m.key },
                    |m: &mut TxInputExt| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "ref_txid",
                    |m: &TxInputExt| { &m.ref_txid },
                    |m: &mut TxInputExt| { &mut m.ref_txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "ref_offset",
                    |m: &TxInputExt| { &m.ref_offset },
                    |m: &mut TxInputExt| { &mut m.ref_offset },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TxInputExt>(
                    "TxInputExt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TxInputExt {
        static mut instance: ::protobuf::lazy::Lazy<TxInputExt> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TxInputExt::new)
        }
    }
}

impl ::protobuf::Clear for TxInputExt {
    fn clear(&mut self) {
        self.bucket.clear();
        self.key.clear();
        self.ref_txid.clear();
        self.ref_offset = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxInputExt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxInputExt {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct TxOutputExt {
    // message fields
    pub bucket: ::std::string::String,
    #[serde(serialize_with = "crate::wallet::serialize_bytes")]
    #[serde(deserialize_with = "crate::wallet::deserialize_bytes")]
    pub key: ::std::vec::Vec<u8>,
    #[serde(serialize_with = "crate::wallet::serialize_bytes")]
    #[serde(deserialize_with = "crate::wallet::deserialize_bytes")]
    pub value: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a TxOutputExt {
    fn default() -> &'a TxOutputExt {
        <TxOutputExt as ::protobuf::Message>::default_instance()
    }
}

impl TxOutputExt {
    pub fn new() -> TxOutputExt {
        ::std::default::Default::default()
    }

    // string bucket = 1;


    pub fn get_bucket(&self) -> &str {
        &self.bucket
    }
    pub fn clear_bucket(&mut self) {
        self.bucket.clear();
    }

    // Param is passed by value, moved
    pub fn set_bucket(&mut self, v: ::std::string::String) {
        self.bucket = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bucket(&mut self) -> &mut ::std::string::String {
        &mut self.bucket
    }

    // Take field
    pub fn take_bucket(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bucket, ::std::string::String::new())
    }

    // bytes key = 2;


    pub fn get_key(&self) -> &[u8] {
        &self.key
    }
    pub fn clear_key(&mut self) {
        self.key.clear();
    }

    // Param is passed by value, moved
    pub fn set_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.key
    }

    // Take field
    pub fn take_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.key, ::std::vec::Vec::new())
    }

    // bytes value = 3;


    pub fn get_value(&self) -> &[u8] {
        &self.value
    }
    pub fn clear_value(&mut self) {
        self.value.clear();
    }

    // Param is passed by value, moved
    pub fn set_value(&mut self, v: ::std::vec::Vec<u8>) {
        self.value = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_value(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.value
    }

    // Take field
    pub fn take_value(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.value, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for TxOutputExt {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bucket)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.key)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.value)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.bucket.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.bucket);
        }
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.bucket.is_empty() {
            os.write_string(1, &self.bucket)?;
        }
        if !self.key.is_empty() {
            os.write_bytes(2, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_bytes(3, &self.value)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> TxOutputExt {
        TxOutputExt::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bucket",
                    |m: &TxOutputExt| { &m.bucket },
                    |m: &mut TxOutputExt| { &mut m.bucket },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "key",
                    |m: &TxOutputExt| { &m.key },
                    |m: &mut TxOutputExt| { &mut m.key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "value",
                    |m: &TxOutputExt| { &m.value },
                    |m: &mut TxOutputExt| { &mut m.value },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<TxOutputExt>(
                    "TxOutputExt",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static TxOutputExt {
        static mut instance: ::protobuf::lazy::Lazy<TxOutputExt> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(TxOutputExt::new)
        }
    }
}

impl ::protobuf::Clear for TxOutputExt {
    fn clear(&mut self) {
        self.bucket.clear();
        self.key.clear();
        self.value.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for TxOutputExt {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TxOutputExt {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct SignatureInfo {
    // message fields
    pub PublicKey: ::std::string::String,
    #[serde(serialize_with = "crate::wallet::serialize_bytes")]
    #[serde(deserialize_with = "crate::wallet::deserialize_bytes")]
    pub Sign: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a SignatureInfo {
    fn default() -> &'a SignatureInfo {
        <SignatureInfo as ::protobuf::Message>::default_instance()
    }
}

impl SignatureInfo {
    pub fn new() -> SignatureInfo {
        ::std::default::Default::default()
    }

    // string PublicKey = 1;


    pub fn get_PublicKey(&self) -> &str {
        &self.PublicKey
    }
    pub fn clear_PublicKey(&mut self) {
        self.PublicKey.clear();
    }

    // Param is passed by value, moved
    pub fn set_PublicKey(&mut self, v: ::std::string::String) {
        self.PublicKey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_PublicKey(&mut self) -> &mut ::std::string::String {
        &mut self.PublicKey
    }

    // Take field
    pub fn take_PublicKey(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.PublicKey, ::std::string::String::new())
    }

    // bytes Sign = 2;


    pub fn get_Sign(&self) -> &[u8] {
        &self.Sign
    }
    pub fn clear_Sign(&mut self) {
        self.Sign.clear();
    }

    // Param is passed by value, moved
    pub fn set_Sign(&mut self, v: ::std::vec::Vec<u8>) {
        self.Sign = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_Sign(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.Sign
    }

    // Take field
    pub fn take_Sign(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.Sign, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for SignatureInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.PublicKey)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.Sign)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.PublicKey.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.PublicKey);
        }
        if !self.Sign.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.Sign);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.PublicKey.is_empty() {
            os.write_string(1, &self.PublicKey)?;
        }
        if !self.Sign.is_empty() {
            os.write_bytes(2, &self.Sign)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> SignatureInfo {
        SignatureInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "PublicKey",
                    |m: &SignatureInfo| { &m.PublicKey },
                    |m: &mut SignatureInfo| { &mut m.PublicKey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "Sign",
                    |m: &SignatureInfo| { &m.Sign },
                    |m: &mut SignatureInfo| { &mut m.Sign },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<SignatureInfo>(
                    "SignatureInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static SignatureInfo {
        static mut instance: ::protobuf::lazy::Lazy<SignatureInfo> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(SignatureInfo::new)
        }
    }
}

impl ::protobuf::Clear for SignatureInfo {
    fn clear(&mut self) {
        self.PublicKey.clear();
        self.Sign.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for SignatureInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SignatureInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PermissionModel {
    // message fields
    pub rule: PermissionRule,
    pub acceptValue: f64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PermissionModel {
    fn default() -> &'a PermissionModel {
        <PermissionModel as ::protobuf::Message>::default_instance()
    }
}

impl PermissionModel {
    pub fn new() -> PermissionModel {
        ::std::default::Default::default()
    }

    // .pb.PermissionRule rule = 1;


    pub fn get_rule(&self) -> PermissionRule {
        self.rule
    }
    pub fn clear_rule(&mut self) {
        self.rule = PermissionRule::NULL;
    }

    // Param is passed by value, moved
    pub fn set_rule(&mut self, v: PermissionRule) {
        self.rule = v;
    }

    // double acceptValue = 2;


    pub fn get_acceptValue(&self) -> f64 {
        self.acceptValue
    }
    pub fn clear_acceptValue(&mut self) {
        self.acceptValue = 0.;
    }

    // Param is passed by value, moved
    pub fn set_acceptValue(&mut self, v: f64) {
        self.acceptValue = v;
    }
}

impl ::protobuf::Message for PermissionModel {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.rule, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeFixed64 {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_double()?;
                    self.acceptValue = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.rule != PermissionRule::NULL {
            my_size += ::protobuf::rt::enum_size(1, self.rule);
        }
        if self.acceptValue != 0. {
            my_size += 9;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.rule != PermissionRule::NULL {
            os.write_enum(1, self.rule.value())?;
        }
        if self.acceptValue != 0. {
            os.write_double(2, self.acceptValue)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PermissionModel {
        PermissionModel::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<PermissionRule>>(
                    "rule",
                    |m: &PermissionModel| { &m.rule },
                    |m: &mut PermissionModel| { &mut m.rule },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeDouble>(
                    "acceptValue",
                    |m: &PermissionModel| { &m.acceptValue },
                    |m: &mut PermissionModel| { &mut m.acceptValue },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<PermissionModel>(
                    "PermissionModel",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PermissionModel {
        static mut instance: ::protobuf::lazy::Lazy<PermissionModel> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PermissionModel::new)
        }
    }
}

impl ::protobuf::Clear for PermissionModel {
    fn clear(&mut self) {
        self.rule = PermissionRule::NULL;
        self.acceptValue = 0.;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PermissionModel {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionModel {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AkSet {
    // message fields
    pub aks: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AkSet {
    fn default() -> &'a AkSet {
        <AkSet as ::protobuf::Message>::default_instance()
    }
}

impl AkSet {
    pub fn new() -> AkSet {
        ::std::default::Default::default()
    }

    // repeated string aks = 1;


    pub fn get_aks(&self) -> &[::std::string::String] {
        &self.aks
    }
    pub fn clear_aks(&mut self) {
        self.aks.clear();
    }

    // Param is passed by value, moved
    pub fn set_aks(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.aks = v;
    }

    // Mutable pointer to the field.
    pub fn mut_aks(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.aks
    }

    // Take field
    pub fn take_aks(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.aks, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AkSet {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.aks)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.aks {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.aks {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AkSet {
        AkSet::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "aks",
                    |m: &AkSet| { &m.aks },
                    |m: &mut AkSet| { &mut m.aks },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AkSet>(
                    "AkSet",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AkSet {
        static mut instance: ::protobuf::lazy::Lazy<AkSet> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AkSet::new)
        }
    }
}

impl ::protobuf::Clear for AkSet {
    fn clear(&mut self) {
        self.aks.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AkSet {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AkSet {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AkSets {
    // message fields
    pub sets: ::std::collections::HashMap<::std::string::String, AkSet>,
    pub expression: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AkSets {
    fn default() -> &'a AkSets {
        <AkSets as ::protobuf::Message>::default_instance()
    }
}

impl AkSets {
    pub fn new() -> AkSets {
        ::std::default::Default::default()
    }

    // repeated .pb.AkSets.SetsEntry sets = 1;


    pub fn get_sets(&self) -> &::std::collections::HashMap<::std::string::String, AkSet> {
        &self.sets
    }
    pub fn clear_sets(&mut self) {
        self.sets.clear();
    }

    // Param is passed by value, moved
    pub fn set_sets(&mut self, v: ::std::collections::HashMap<::std::string::String, AkSet>) {
        self.sets = v;
    }

    // Mutable pointer to the field.
    pub fn mut_sets(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, AkSet> {
        &mut self.sets
    }

    // Take field
    pub fn take_sets(&mut self) -> ::std::collections::HashMap<::std::string::String, AkSet> {
        ::std::mem::replace(&mut self.sets, ::std::collections::HashMap::new())
    }

    // string expression = 2;


    pub fn get_expression(&self) -> &str {
        &self.expression
    }
    pub fn clear_expression(&mut self) {
        self.expression.clear();
    }

    // Param is passed by value, moved
    pub fn set_expression(&mut self, v: ::std::string::String) {
        self.expression = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_expression(&mut self) -> &mut ::std::string::String {
        &mut self.expression
    }

    // Take field
    pub fn take_expression(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.expression, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AkSets {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<AkSet>>(wire_type, is, &mut self.sets)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.expression)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<AkSet>>(1, &self.sets);
        if !self.expression.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.expression);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<AkSet>>(1, &self.sets, os)?;
        if !self.expression.is_empty() {
            os.write_string(2, &self.expression)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AkSets {
        AkSets::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeMessage<AkSet>>(
                    "sets",
                    |m: &AkSets| { &m.sets },
                    |m: &mut AkSets| { &mut m.sets },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "expression",
                    |m: &AkSets| { &m.expression },
                    |m: &mut AkSets| { &mut m.expression },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AkSets>(
                    "AkSets",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AkSets {
        static mut instance: ::protobuf::lazy::Lazy<AkSets> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AkSets::new)
        }
    }
}

impl ::protobuf::Clear for AkSets {
    fn clear(&mut self) {
        self.sets.clear();
        self.expression.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AkSets {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AkSets {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct Acl {
    // message fields
    pub pm: ::protobuf::SingularPtrField<PermissionModel>,
    pub aksWeight: ::std::collections::HashMap<::std::string::String, f64>,
    pub akSets: ::protobuf::SingularPtrField<AkSets>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a Acl {
    fn default() -> &'a Acl {
        <Acl as ::protobuf::Message>::default_instance()
    }
}

impl Acl {
    pub fn new() -> Acl {
        ::std::default::Default::default()
    }

    // .pb.PermissionModel pm = 1;


    pub fn get_pm(&self) -> &PermissionModel {
        self.pm.as_ref().unwrap_or_else(|| PermissionModel::default_instance())
    }
    pub fn clear_pm(&mut self) {
        self.pm.clear();
    }

    pub fn has_pm(&self) -> bool {
        self.pm.is_some()
    }

    // Param is passed by value, moved
    pub fn set_pm(&mut self, v: PermissionModel) {
        self.pm = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pm(&mut self) -> &mut PermissionModel {
        if self.pm.is_none() {
            self.pm.set_default();
        }
        self.pm.as_mut().unwrap()
    }

    // Take field
    pub fn take_pm(&mut self) -> PermissionModel {
        self.pm.take().unwrap_or_else(|| PermissionModel::new())
    }

    // repeated .pb.Acl.AksWeightEntry aksWeight = 2;


    pub fn get_aksWeight(&self) -> &::std::collections::HashMap<::std::string::String, f64> {
        &self.aksWeight
    }
    pub fn clear_aksWeight(&mut self) {
        self.aksWeight.clear();
    }

    // Param is passed by value, moved
    pub fn set_aksWeight(&mut self, v: ::std::collections::HashMap<::std::string::String, f64>) {
        self.aksWeight = v;
    }

    // Mutable pointer to the field.
    pub fn mut_aksWeight(&mut self) -> &mut ::std::collections::HashMap<::std::string::String, f64> {
        &mut self.aksWeight
    }

    // Take field
    pub fn take_aksWeight(&mut self) -> ::std::collections::HashMap<::std::string::String, f64> {
        ::std::mem::replace(&mut self.aksWeight, ::std::collections::HashMap::new())
    }

    // .pb.AkSets akSets = 3;


    pub fn get_akSets(&self) -> &AkSets {
        self.akSets.as_ref().unwrap_or_else(|| AkSets::default_instance())
    }
    pub fn clear_akSets(&mut self) {
        self.akSets.clear();
    }

    pub fn has_akSets(&self) -> bool {
        self.akSets.is_some()
    }

    // Param is passed by value, moved
    pub fn set_akSets(&mut self, v: AkSets) {
        self.akSets = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_akSets(&mut self) -> &mut AkSets {
        if self.akSets.is_none() {
            self.akSets.set_default();
        }
        self.akSets.as_mut().unwrap()
    }

    // Take field
    pub fn take_akSets(&mut self) -> AkSets {
        self.akSets.take().unwrap_or_else(|| AkSets::new())
    }
}

impl ::protobuf::Message for Acl {
    fn is_initialized(&self) -> bool {
        for v in &self.pm {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.akSets {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.pm)?;
                },
                2 => {
                    ::protobuf::rt::read_map_into::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(wire_type, is, &mut self.aksWeight)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.akSets)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.pm.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::compute_map_size::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(2, &self.aksWeight);
        if let Some(ref v) = self.akSets.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.pm.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        ::protobuf::rt::write_map_with_cached_sizes::<::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(2, &self.aksWeight, os)?;
        if let Some(ref v) = self.akSets.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> Acl {
        Acl::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<PermissionModel>>(
                    "pm",
                    |m: &Acl| { &m.pm },
                    |m: &mut Acl| { &mut m.pm },
                ));
                fields.push(::protobuf::reflect::accessor::make_map_accessor::<_, ::protobuf::types::ProtobufTypeString, ::protobuf::types::ProtobufTypeDouble>(
                    "aksWeight",
                    |m: &Acl| { &m.aksWeight },
                    |m: &mut Acl| { &mut m.aksWeight },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<AkSets>>(
                    "akSets",
                    |m: &Acl| { &m.akSets },
                    |m: &mut Acl| { &mut m.akSets },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<Acl>(
                    "Acl",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static Acl {
        static mut instance: ::protobuf::lazy::Lazy<Acl> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(Acl::new)
        }
    }
}

impl ::protobuf::Clear for Acl {
    fn clear(&mut self) {
        self.pm.clear();
        self.aksWeight.clear();
        self.akSets.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for Acl {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for Acl {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AclStatus {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub accountName: ::std::string::String,
    pub contractName: ::std::string::String,
    pub methodName: ::std::string::String,
    pub confirmed: bool,
    pub acl: ::protobuf::SingularPtrField<Acl>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AclStatus {
    fn default() -> &'a AclStatus {
        <AclStatus as ::protobuf::Message>::default_instance()
    }
}

impl AclStatus {
    pub fn new() -> AclStatus {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // string accountName = 3;


    pub fn get_accountName(&self) -> &str {
        &self.accountName
    }
    pub fn clear_accountName(&mut self) {
        self.accountName.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountName(&mut self, v: ::std::string::String) {
        self.accountName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountName(&mut self) -> &mut ::std::string::String {
        &mut self.accountName
    }

    // Take field
    pub fn take_accountName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountName, ::std::string::String::new())
    }

    // string contractName = 4;


    pub fn get_contractName(&self) -> &str {
        &self.contractName
    }
    pub fn clear_contractName(&mut self) {
        self.contractName.clear();
    }

    // Param is passed by value, moved
    pub fn set_contractName(&mut self, v: ::std::string::String) {
        self.contractName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contractName(&mut self) -> &mut ::std::string::String {
        &mut self.contractName
    }

    // Take field
    pub fn take_contractName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contractName, ::std::string::String::new())
    }

    // string methodName = 5;


    pub fn get_methodName(&self) -> &str {
        &self.methodName
    }
    pub fn clear_methodName(&mut self) {
        self.methodName.clear();
    }

    // Param is passed by value, moved
    pub fn set_methodName(&mut self, v: ::std::string::String) {
        self.methodName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_methodName(&mut self) -> &mut ::std::string::String {
        &mut self.methodName
    }

    // Take field
    pub fn take_methodName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.methodName, ::std::string::String::new())
    }

    // bool confirmed = 6;


    pub fn get_confirmed(&self) -> bool {
        self.confirmed
    }
    pub fn clear_confirmed(&mut self) {
        self.confirmed = false;
    }

    // Param is passed by value, moved
    pub fn set_confirmed(&mut self, v: bool) {
        self.confirmed = v;
    }

    // .pb.Acl acl = 7;


    pub fn get_acl(&self) -> &Acl {
        self.acl.as_ref().unwrap_or_else(|| Acl::default_instance())
    }
    pub fn clear_acl(&mut self) {
        self.acl.clear();
    }

    pub fn has_acl(&self) -> bool {
        self.acl.is_some()
    }

    // Param is passed by value, moved
    pub fn set_acl(&mut self, v: Acl) {
        self.acl = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_acl(&mut self) -> &mut Acl {
        if self.acl.is_none() {
            self.acl.set_default();
        }
        self.acl.as_mut().unwrap()
    }

    // Take field
    pub fn take_acl(&mut self) -> Acl {
        self.acl.take().unwrap_or_else(|| Acl::new())
    }
}

impl ::protobuf::Message for AclStatus {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.acl {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.contractName)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.methodName)?;
                },
                6 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.confirmed = tmp;
                },
                7 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.acl)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if !self.accountName.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.accountName);
        }
        if !self.contractName.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.contractName);
        }
        if !self.methodName.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.methodName);
        }
        if self.confirmed != false {
            my_size += 2;
        }
        if let Some(ref v) = self.acl.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if !self.accountName.is_empty() {
            os.write_string(3, &self.accountName)?;
        }
        if !self.contractName.is_empty() {
            os.write_string(4, &self.contractName)?;
        }
        if !self.methodName.is_empty() {
            os.write_string(5, &self.methodName)?;
        }
        if self.confirmed != false {
            os.write_bool(6, self.confirmed)?;
        }
        if let Some(ref v) = self.acl.as_ref() {
            os.write_tag(7, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AclStatus {
        AclStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &AclStatus| { &m.header },
                    |m: &mut AclStatus| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &AclStatus| { &m.bcname },
                    |m: &mut AclStatus| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "accountName",
                    |m: &AclStatus| { &m.accountName },
                    |m: &mut AclStatus| { &mut m.accountName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "contractName",
                    |m: &AclStatus| { &m.contractName },
                    |m: &mut AclStatus| { &mut m.contractName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "methodName",
                    |m: &AclStatus| { &m.methodName },
                    |m: &mut AclStatus| { &mut m.methodName },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "confirmed",
                    |m: &AclStatus| { &m.confirmed },
                    |m: &mut AclStatus| { &mut m.confirmed },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Acl>>(
                    "acl",
                    |m: &AclStatus| { &m.acl },
                    |m: &mut AclStatus| { &mut m.acl },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AclStatus>(
                    "AclStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AclStatus {
        static mut instance: ::protobuf::lazy::Lazy<AclStatus> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AclStatus::new)
        }
    }
}

impl ::protobuf::Clear for AclStatus {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.accountName.clear();
        self.contractName.clear();
        self.methodName.clear();
        self.confirmed = false;
        self.acl.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AclStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AclStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IdentityAuth {
    // message fields
    pub sign: ::std::vec::Vec<u8>,
    pub pubkey: ::std::vec::Vec<u8>,
    pub addr: ::std::string::String,
    pub peerID: ::std::string::String,
    pub timestamp: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IdentityAuth {
    fn default() -> &'a IdentityAuth {
        <IdentityAuth as ::protobuf::Message>::default_instance()
    }
}

impl IdentityAuth {
    pub fn new() -> IdentityAuth {
        ::std::default::Default::default()
    }

    // bytes sign = 1;


    pub fn get_sign(&self) -> &[u8] {
        &self.sign
    }
    pub fn clear_sign(&mut self) {
        self.sign.clear();
    }

    // Param is passed by value, moved
    pub fn set_sign(&mut self, v: ::std::vec::Vec<u8>) {
        self.sign = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sign(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.sign
    }

    // Take field
    pub fn take_sign(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.sign, ::std::vec::Vec::new())
    }

    // bytes pubkey = 2;


    pub fn get_pubkey(&self) -> &[u8] {
        &self.pubkey
    }
    pub fn clear_pubkey(&mut self) {
        self.pubkey.clear();
    }

    // Param is passed by value, moved
    pub fn set_pubkey(&mut self, v: ::std::vec::Vec<u8>) {
        self.pubkey = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_pubkey(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.pubkey
    }

    // Take field
    pub fn take_pubkey(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.pubkey, ::std::vec::Vec::new())
    }

    // string addr = 3;


    pub fn get_addr(&self) -> &str {
        &self.addr
    }
    pub fn clear_addr(&mut self) {
        self.addr.clear();
    }

    // Param is passed by value, moved
    pub fn set_addr(&mut self, v: ::std::string::String) {
        self.addr = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_addr(&mut self) -> &mut ::std::string::String {
        &mut self.addr
    }

    // Take field
    pub fn take_addr(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.addr, ::std::string::String::new())
    }

    // string peerID = 4;


    pub fn get_peerID(&self) -> &str {
        &self.peerID
    }
    pub fn clear_peerID(&mut self) {
        self.peerID.clear();
    }

    // Param is passed by value, moved
    pub fn set_peerID(&mut self, v: ::std::string::String) {
        self.peerID = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_peerID(&mut self) -> &mut ::std::string::String {
        &mut self.peerID
    }

    // Take field
    pub fn take_peerID(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.peerID, ::std::string::String::new())
    }

    // string timestamp = 5;


    pub fn get_timestamp(&self) -> &str {
        &self.timestamp
    }
    pub fn clear_timestamp(&mut self) {
        self.timestamp.clear();
    }

    // Param is passed by value, moved
    pub fn set_timestamp(&mut self, v: ::std::string::String) {
        self.timestamp = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_timestamp(&mut self) -> &mut ::std::string::String {
        &mut self.timestamp
    }

    // Take field
    pub fn take_timestamp(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.timestamp, ::std::string::String::new())
    }
}

impl ::protobuf::Message for IdentityAuth {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.sign)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.pubkey)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.addr)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.peerID)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.timestamp)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.sign.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.sign);
        }
        if !self.pubkey.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.pubkey);
        }
        if !self.addr.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.addr);
        }
        if !self.peerID.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.peerID);
        }
        if !self.timestamp.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.timestamp);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.sign.is_empty() {
            os.write_bytes(1, &self.sign)?;
        }
        if !self.pubkey.is_empty() {
            os.write_bytes(2, &self.pubkey)?;
        }
        if !self.addr.is_empty() {
            os.write_string(3, &self.addr)?;
        }
        if !self.peerID.is_empty() {
            os.write_string(4, &self.peerID)?;
        }
        if !self.timestamp.is_empty() {
            os.write_string(5, &self.timestamp)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IdentityAuth {
        IdentityAuth::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "sign",
                    |m: &IdentityAuth| { &m.sign },
                    |m: &mut IdentityAuth| { &mut m.sign },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "pubkey",
                    |m: &IdentityAuth| { &m.pubkey },
                    |m: &mut IdentityAuth| { &mut m.pubkey },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "addr",
                    |m: &IdentityAuth| { &m.addr },
                    |m: &mut IdentityAuth| { &mut m.addr },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "peerID",
                    |m: &IdentityAuth| { &m.peerID },
                    |m: &mut IdentityAuth| { &mut m.peerID },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "timestamp",
                    |m: &IdentityAuth| { &m.timestamp },
                    |m: &mut IdentityAuth| { &mut m.timestamp },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<IdentityAuth>(
                    "IdentityAuth",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IdentityAuth {
        static mut instance: ::protobuf::lazy::Lazy<IdentityAuth> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(IdentityAuth::new)
        }
    }
}

impl ::protobuf::Clear for IdentityAuth {
    fn clear(&mut self) {
        self.sign.clear();
        self.pubkey.clear();
        self.addr.clear();
        self.peerID.clear();
        self.timestamp.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IdentityAuth {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdentityAuth {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct IdentityAuths {
    // message fields
    pub auth: ::protobuf::RepeatedField<IdentityAuth>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a IdentityAuths {
    fn default() -> &'a IdentityAuths {
        <IdentityAuths as ::protobuf::Message>::default_instance()
    }
}

impl IdentityAuths {
    pub fn new() -> IdentityAuths {
        ::std::default::Default::default()
    }

    // repeated .pb.IdentityAuth auth = 1;


    pub fn get_auth(&self) -> &[IdentityAuth] {
        &self.auth
    }
    pub fn clear_auth(&mut self) {
        self.auth.clear();
    }

    // Param is passed by value, moved
    pub fn set_auth(&mut self, v: ::protobuf::RepeatedField<IdentityAuth>) {
        self.auth = v;
    }

    // Mutable pointer to the field.
    pub fn mut_auth(&mut self) -> &mut ::protobuf::RepeatedField<IdentityAuth> {
        &mut self.auth
    }

    // Take field
    pub fn take_auth(&mut self) -> ::protobuf::RepeatedField<IdentityAuth> {
        ::std::mem::replace(&mut self.auth, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for IdentityAuths {
    fn is_initialized(&self) -> bool {
        for v in &self.auth {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.auth)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        for value in &self.auth {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        for v in &self.auth {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> IdentityAuths {
        IdentityAuths::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<IdentityAuth>>(
                    "auth",
                    |m: &IdentityAuths| { &m.auth },
                    |m: &mut IdentityAuths| { &mut m.auth },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<IdentityAuths>(
                    "IdentityAuths",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static IdentityAuths {
        static mut instance: ::protobuf::lazy::Lazy<IdentityAuths> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(IdentityAuths::new)
        }
    }
}

impl ::protobuf::Clear for IdentityAuths {
    fn clear(&mut self) {
        self.auth.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for IdentityAuths {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for IdentityAuths {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ResourceLimit {
    // message fields
    #[serde(rename = "type", default)]
    #[serde(skip_serializing_if = "crate::wallet::is_CPU")]
    pub field_type: ResourceType,
    #[serde(default)]
    #[serde(skip_serializing_if = "crate::wallet::is_zero")]
    pub limit: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ResourceLimit {
    fn default() -> &'a ResourceLimit {
        <ResourceLimit as ::protobuf::Message>::default_instance()
    }
}

impl ResourceLimit {
    pub fn new() -> ResourceLimit {
        ::std::default::Default::default()
    }

    // .pb.ResourceType type = 1;


    pub fn get_field_type(&self) -> ResourceType {
        self.field_type
    }
    pub fn clear_field_type(&mut self) {
        self.field_type = ResourceType::CPU;
    }

    // Param is passed by value, moved
    pub fn set_field_type(&mut self, v: ResourceType) {
        self.field_type = v;
    }

    // int64 limit = 2;


    pub fn get_limit(&self) -> i64 {
        self.limit
    }
    pub fn clear_limit(&mut self) {
        self.limit = 0;
    }

    // Param is passed by value, moved
    pub fn set_limit(&mut self, v: i64) {
        self.limit = v;
    }
}

impl ::protobuf::Message for ResourceLimit {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_proto3_enum_with_unknown_fields_into(wire_type, is, &mut self.field_type, 1, &mut self.unknown_fields)?
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.limit = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.field_type != ResourceType::CPU {
            my_size += ::protobuf::rt::enum_size(1, self.field_type);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::value_size(2, self.limit, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.field_type != ResourceType::CPU {
            os.write_enum(1, self.field_type.value())?;
        }
        if self.limit != 0 {
            os.write_int64(2, self.limit)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ResourceLimit {
        ResourceLimit::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeEnum<ResourceType>>(
                    "type",
                    |m: &ResourceLimit| { &m.field_type },
                    |m: &mut ResourceLimit| { &mut m.field_type },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "limit",
                    |m: &ResourceLimit| { &m.limit },
                    |m: &mut ResourceLimit| { &mut m.limit },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ResourceLimit>(
                    "ResourceLimit",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ResourceLimit {
        static mut instance: ::protobuf::lazy::Lazy<ResourceLimit> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ResourceLimit::new)
        }
    }
}

impl ::protobuf::Clear for ResourceLimit {
    fn clear(&mut self) {
        self.field_type = ResourceType::CPU;
        self.limit = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ResourceLimit {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceLimit {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AK2AccountRequest {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub address: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AK2AccountRequest {
    fn default() -> &'a AK2AccountRequest {
        <AK2AccountRequest as ::protobuf::Message>::default_instance()
    }
}

impl AK2AccountRequest {
    pub fn new() -> AK2AccountRequest {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }
}

impl ::protobuf::Message for AK2AccountRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AK2AccountRequest {
        AK2AccountRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &AK2AccountRequest| { &m.header },
                    |m: &mut AK2AccountRequest| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &AK2AccountRequest| { &m.bcname },
                    |m: &mut AK2AccountRequest| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &AK2AccountRequest| { &m.address },
                    |m: &mut AK2AccountRequest| { &mut m.address },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AK2AccountRequest>(
                    "AK2AccountRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AK2AccountRequest {
        static mut instance: ::protobuf::lazy::Lazy<AK2AccountRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AK2AccountRequest::new)
        }
    }
}

impl ::protobuf::Clear for AK2AccountRequest {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.address.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AK2AccountRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AK2AccountRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct AK2AccountResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub account: ::protobuf::RepeatedField<::std::string::String>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a AK2AccountResponse {
    fn default() -> &'a AK2AccountResponse {
        <AK2AccountResponse as ::protobuf::Message>::default_instance()
    }
}

impl AK2AccountResponse {
    pub fn new() -> AK2AccountResponse {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // repeated string account = 3;


    pub fn get_account(&self) -> &[::std::string::String] {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::protobuf::RepeatedField<::std::string::String>) {
        self.account = v;
    }

    // Mutable pointer to the field.
    pub fn mut_account(&mut self) -> &mut ::protobuf::RepeatedField<::std::string::String> {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::protobuf::RepeatedField<::std::string::String> {
        ::std::mem::replace(&mut self.account, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for AK2AccountResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_string_into(wire_type, is, &mut self.account)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        for value in &self.account {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        for v in &self.account {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> AK2AccountResponse {
        AK2AccountResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &AK2AccountResponse| { &m.header },
                    |m: &mut AK2AccountResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &AK2AccountResponse| { &m.bcname },
                    |m: &mut AK2AccountResponse| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "account",
                    |m: &AK2AccountResponse| { &m.account },
                    |m: &mut AK2AccountResponse| { &mut m.account },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<AK2AccountResponse>(
                    "AK2AccountResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static AK2AccountResponse {
        static mut instance: ::protobuf::lazy::Lazy<AK2AccountResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(AK2AccountResponse::new)
        }
    }
}

impl ::protobuf::Clear for AK2AccountResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.account.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for AK2AccountResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AK2AccountResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetAccountContractsRequest {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub account: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAccountContractsRequest {
    fn default() -> &'a GetAccountContractsRequest {
        <GetAccountContractsRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetAccountContractsRequest {
    pub fn new() -> GetAccountContractsRequest {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // string account = 3;


    pub fn get_account(&self) -> &str {
        &self.account
    }
    pub fn clear_account(&mut self) {
        self.account.clear();
    }

    // Param is passed by value, moved
    pub fn set_account(&mut self, v: ::std::string::String) {
        self.account = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_account(&mut self) -> &mut ::std::string::String {
        &mut self.account
    }

    // Take field
    pub fn take_account(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.account, ::std::string::String::new())
    }
}

impl ::protobuf::Message for GetAccountContractsRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.account)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if !self.account.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.account);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if !self.account.is_empty() {
            os.write_string(3, &self.account)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAccountContractsRequest {
        GetAccountContractsRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &GetAccountContractsRequest| { &m.header },
                    |m: &mut GetAccountContractsRequest| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &GetAccountContractsRequest| { &m.bcname },
                    |m: &mut GetAccountContractsRequest| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "account",
                    |m: &GetAccountContractsRequest| { &m.account },
                    |m: &mut GetAccountContractsRequest| { &mut m.account },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAccountContractsRequest>(
                    "GetAccountContractsRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetAccountContractsRequest {
        static mut instance: ::protobuf::lazy::Lazy<GetAccountContractsRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetAccountContractsRequest::new)
        }
    }
}

impl ::protobuf::Clear for GetAccountContractsRequest {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.account.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAccountContractsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAccountContractsRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct GetAccountContractsResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub contracts_status: ::protobuf::RepeatedField<ContractStatus>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a GetAccountContractsResponse {
    fn default() -> &'a GetAccountContractsResponse {
        <GetAccountContractsResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetAccountContractsResponse {
    pub fn new() -> GetAccountContractsResponse {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // repeated .pb.ContractStatus contracts_status = 2;


    pub fn get_contracts_status(&self) -> &[ContractStatus] {
        &self.contracts_status
    }
    pub fn clear_contracts_status(&mut self) {
        self.contracts_status.clear();
    }

    // Param is passed by value, moved
    pub fn set_contracts_status(&mut self, v: ::protobuf::RepeatedField<ContractStatus>) {
        self.contracts_status = v;
    }

    // Mutable pointer to the field.
    pub fn mut_contracts_status(&mut self) -> &mut ::protobuf::RepeatedField<ContractStatus> {
        &mut self.contracts_status
    }

    // Take field
    pub fn take_contracts_status(&mut self) -> ::protobuf::RepeatedField<ContractStatus> {
        ::std::mem::replace(&mut self.contracts_status, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for GetAccountContractsResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.contracts_status {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.contracts_status)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        for value in &self.contracts_status {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        for v in &self.contracts_status {
            os.write_tag(2, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> GetAccountContractsResponse {
        GetAccountContractsResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &GetAccountContractsResponse| { &m.header },
                    |m: &mut GetAccountContractsResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContractStatus>>(
                    "contracts_status",
                    |m: &GetAccountContractsResponse| { &m.contracts_status },
                    |m: &mut GetAccountContractsResponse| { &mut m.contracts_status },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<GetAccountContractsResponse>(
                    "GetAccountContractsResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static GetAccountContractsResponse {
        static mut instance: ::protobuf::lazy::Lazy<GetAccountContractsResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(GetAccountContractsResponse::new)
        }
    }
}

impl ::protobuf::Clear for GetAccountContractsResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.contracts_status.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for GetAccountContractsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetAccountContractsResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ContractStatus {
    // message fields
    pub contract_name: ::std::string::String,
    pub txid: ::std::string::String,
    pub desc: ::std::vec::Vec<u8>,
    pub is_banned: bool,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContractStatus {
    fn default() -> &'a ContractStatus {
        <ContractStatus as ::protobuf::Message>::default_instance()
    }
}

impl ContractStatus {
    pub fn new() -> ContractStatus {
        ::std::default::Default::default()
    }

    // string contract_name = 1;


    pub fn get_contract_name(&self) -> &str {
        &self.contract_name
    }
    pub fn clear_contract_name(&mut self) {
        self.contract_name.clear();
    }

    // Param is passed by value, moved
    pub fn set_contract_name(&mut self, v: ::std::string::String) {
        self.contract_name = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_contract_name(&mut self) -> &mut ::std::string::String {
        &mut self.contract_name
    }

    // Take field
    pub fn take_contract_name(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.contract_name, ::std::string::String::new())
    }

    // string txid = 2;


    pub fn get_txid(&self) -> &str {
        &self.txid
    }
    pub fn clear_txid(&mut self) {
        self.txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_txid(&mut self, v: ::std::string::String) {
        self.txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_txid(&mut self) -> &mut ::std::string::String {
        &mut self.txid
    }

    // Take field
    pub fn take_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.txid, ::std::string::String::new())
    }

    // bytes desc = 3;


    pub fn get_desc(&self) -> &[u8] {
        &self.desc
    }
    pub fn clear_desc(&mut self) {
        self.desc.clear();
    }

    // Param is passed by value, moved
    pub fn set_desc(&mut self, v: ::std::vec::Vec<u8>) {
        self.desc = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_desc(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.desc
    }

    // Take field
    pub fn take_desc(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.desc, ::std::vec::Vec::new())
    }

    // bool is_banned = 4;


    pub fn get_is_banned(&self) -> bool {
        self.is_banned
    }
    pub fn clear_is_banned(&mut self) {
        self.is_banned = false;
    }

    // Param is passed by value, moved
    pub fn set_is_banned(&mut self, v: bool) {
        self.is_banned = v;
    }
}

impl ::protobuf::Message for ContractStatus {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.contract_name)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.txid)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.desc)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.is_banned = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.contract_name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.contract_name);
        }
        if !self.txid.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.txid);
        }
        if !self.desc.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.desc);
        }
        if self.is_banned != false {
            my_size += 2;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.contract_name.is_empty() {
            os.write_string(1, &self.contract_name)?;
        }
        if !self.txid.is_empty() {
            os.write_string(2, &self.txid)?;
        }
        if !self.desc.is_empty() {
            os.write_bytes(3, &self.desc)?;
        }
        if self.is_banned != false {
            os.write_bool(4, self.is_banned)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractStatus {
        ContractStatus::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "contract_name",
                    |m: &ContractStatus| { &m.contract_name },
                    |m: &mut ContractStatus| { &mut m.contract_name },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "txid",
                    |m: &ContractStatus| { &m.txid },
                    |m: &mut ContractStatus| { &mut m.txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "desc",
                    |m: &ContractStatus| { &m.desc },
                    |m: &mut ContractStatus| { &mut m.desc },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "is_banned",
                    |m: &ContractStatus| { &m.is_banned },
                    |m: &mut ContractStatus| { &mut m.is_banned },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContractStatus>(
                    "ContractStatus",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContractStatus {
        static mut instance: ::protobuf::lazy::Lazy<ContractStatus> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ContractStatus::new)
        }
    }
}

impl ::protobuf::Clear for ContractStatus {
    fn clear(&mut self) {
        self.contract_name.clear();
        self.txid.clear();
        self.desc.clear();
        self.is_banned = false;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContractStatus {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PreExecWithSelectUTXORequest {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub address: ::std::string::String,
    pub totalAmount: i64,
    pub signInfo: ::protobuf::SingularPtrField<SignatureInfo>,
    pub needLock: bool,
    pub request: ::protobuf::SingularPtrField<InvokeRPCRequest>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreExecWithSelectUTXORequest {
    fn default() -> &'a PreExecWithSelectUTXORequest {
        <PreExecWithSelectUTXORequest as ::protobuf::Message>::default_instance()
    }
}

impl PreExecWithSelectUTXORequest {
    pub fn new() -> PreExecWithSelectUTXORequest {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // string address = 3;


    pub fn get_address(&self) -> &str {
        &self.address
    }
    pub fn clear_address(&mut self) {
        self.address.clear();
    }

    // Param is passed by value, moved
    pub fn set_address(&mut self, v: ::std::string::String) {
        self.address = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_address(&mut self) -> &mut ::std::string::String {
        &mut self.address
    }

    // Take field
    pub fn take_address(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.address, ::std::string::String::new())
    }

    // int64 totalAmount = 4;


    pub fn get_totalAmount(&self) -> i64 {
        self.totalAmount
    }
    pub fn clear_totalAmount(&mut self) {
        self.totalAmount = 0;
    }

    // Param is passed by value, moved
    pub fn set_totalAmount(&mut self, v: i64) {
        self.totalAmount = v;
    }

    // .pb.SignatureInfo signInfo = 6;


    pub fn get_signInfo(&self) -> &SignatureInfo {
        self.signInfo.as_ref().unwrap_or_else(|| SignatureInfo::default_instance())
    }
    pub fn clear_signInfo(&mut self) {
        self.signInfo.clear();
    }

    pub fn has_signInfo(&self) -> bool {
        self.signInfo.is_some()
    }

    // Param is passed by value, moved
    pub fn set_signInfo(&mut self, v: SignatureInfo) {
        self.signInfo = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_signInfo(&mut self) -> &mut SignatureInfo {
        if self.signInfo.is_none() {
            self.signInfo.set_default();
        }
        self.signInfo.as_mut().unwrap()
    }

    // Take field
    pub fn take_signInfo(&mut self) -> SignatureInfo {
        self.signInfo.take().unwrap_or_else(|| SignatureInfo::new())
    }

    // bool needLock = 7;


    pub fn get_needLock(&self) -> bool {
        self.needLock
    }
    pub fn clear_needLock(&mut self) {
        self.needLock = false;
    }

    // Param is passed by value, moved
    pub fn set_needLock(&mut self, v: bool) {
        self.needLock = v;
    }

    // .pb.InvokeRPCRequest request = 5;


    pub fn get_request(&self) -> &InvokeRPCRequest {
        self.request.as_ref().unwrap_or_else(|| InvokeRPCRequest::default_instance())
    }
    pub fn clear_request(&mut self) {
        self.request.clear();
    }

    pub fn has_request(&self) -> bool {
        self.request.is_some()
    }

    // Param is passed by value, moved
    pub fn set_request(&mut self, v: InvokeRPCRequest) {
        self.request = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_request(&mut self) -> &mut InvokeRPCRequest {
        if self.request.is_none() {
            self.request.set_default();
        }
        self.request.as_mut().unwrap()
    }

    // Take field
    pub fn take_request(&mut self) -> InvokeRPCRequest {
        self.request.take().unwrap_or_else(|| InvokeRPCRequest::new())
    }
}

impl ::protobuf::Message for PreExecWithSelectUTXORequest {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.signInfo {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.request {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.address)?;
                },
                4 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.totalAmount = tmp;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.signInfo)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.needLock = tmp;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.request)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if !self.address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.address);
        }
        if self.totalAmount != 0 {
            my_size += ::protobuf::rt::value_size(4, self.totalAmount, ::protobuf::wire_format::WireTypeVarint);
        }
        if let Some(ref v) = self.signInfo.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.needLock != false {
            my_size += 2;
        }
        if let Some(ref v) = self.request.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if !self.address.is_empty() {
            os.write_string(3, &self.address)?;
        }
        if self.totalAmount != 0 {
            os.write_int64(4, self.totalAmount)?;
        }
        if let Some(ref v) = self.signInfo.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.needLock != false {
            os.write_bool(7, self.needLock)?;
        }
        if let Some(ref v) = self.request.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreExecWithSelectUTXORequest {
        PreExecWithSelectUTXORequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &PreExecWithSelectUTXORequest| { &m.header },
                    |m: &mut PreExecWithSelectUTXORequest| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &PreExecWithSelectUTXORequest| { &m.bcname },
                    |m: &mut PreExecWithSelectUTXORequest| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "address",
                    |m: &PreExecWithSelectUTXORequest| { &m.address },
                    |m: &mut PreExecWithSelectUTXORequest| { &mut m.address },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "totalAmount",
                    |m: &PreExecWithSelectUTXORequest| { &m.totalAmount },
                    |m: &mut PreExecWithSelectUTXORequest| { &mut m.totalAmount },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<SignatureInfo>>(
                    "signInfo",
                    |m: &PreExecWithSelectUTXORequest| { &m.signInfo },
                    |m: &mut PreExecWithSelectUTXORequest| { &mut m.signInfo },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "needLock",
                    |m: &PreExecWithSelectUTXORequest| { &m.needLock },
                    |m: &mut PreExecWithSelectUTXORequest| { &mut m.needLock },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InvokeRPCRequest>>(
                    "request",
                    |m: &PreExecWithSelectUTXORequest| { &m.request },
                    |m: &mut PreExecWithSelectUTXORequest| { &mut m.request },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreExecWithSelectUTXORequest>(
                    "PreExecWithSelectUTXORequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PreExecWithSelectUTXORequest {
        static mut instance: ::protobuf::lazy::Lazy<PreExecWithSelectUTXORequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PreExecWithSelectUTXORequest::new)
        }
    }
}

impl ::protobuf::Clear for PreExecWithSelectUTXORequest {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.address.clear();
        self.totalAmount = 0;
        self.signInfo.clear();
        self.needLock = false;
        self.request.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreExecWithSelectUTXORequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreExecWithSelectUTXORequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct PreExecWithSelectUTXOResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub response: ::protobuf::SingularPtrField<InvokeResponse>,
    pub utxoOutput: ::protobuf::SingularPtrField<UtxoOutput>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a PreExecWithSelectUTXOResponse {
    fn default() -> &'a PreExecWithSelectUTXOResponse {
        <PreExecWithSelectUTXOResponse as ::protobuf::Message>::default_instance()
    }
}

impl PreExecWithSelectUTXOResponse {
    pub fn new() -> PreExecWithSelectUTXOResponse {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // .pb.InvokeResponse response = 3;


    pub fn get_response(&self) -> &InvokeResponse {
        self.response.as_ref().unwrap_or_else(|| InvokeResponse::default_instance())
    }
    pub fn clear_response(&mut self) {
        self.response.clear();
    }

    pub fn has_response(&self) -> bool {
        self.response.is_some()
    }

    // Param is passed by value, moved
    pub fn set_response(&mut self, v: InvokeResponse) {
        self.response = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_response(&mut self) -> &mut InvokeResponse {
        if self.response.is_none() {
            self.response.set_default();
        }
        self.response.as_mut().unwrap()
    }

    // Take field
    pub fn take_response(&mut self) -> InvokeResponse {
        self.response.take().unwrap_or_else(|| InvokeResponse::new())
    }

    // .pb.UtxoOutput utxoOutput = 4;


    pub fn get_utxoOutput(&self) -> &UtxoOutput {
        self.utxoOutput.as_ref().unwrap_or_else(|| UtxoOutput::default_instance())
    }
    pub fn clear_utxoOutput(&mut self) {
        self.utxoOutput.clear();
    }

    pub fn has_utxoOutput(&self) -> bool {
        self.utxoOutput.is_some()
    }

    // Param is passed by value, moved
    pub fn set_utxoOutput(&mut self, v: UtxoOutput) {
        self.utxoOutput = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_utxoOutput(&mut self) -> &mut UtxoOutput {
        if self.utxoOutput.is_none() {
            self.utxoOutput.set_default();
        }
        self.utxoOutput.as_mut().unwrap()
    }

    // Take field
    pub fn take_utxoOutput(&mut self) -> UtxoOutput {
        self.utxoOutput.take().unwrap_or_else(|| UtxoOutput::new())
    }
}

impl ::protobuf::Message for PreExecWithSelectUTXOResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.response {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.utxoOutput {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.response)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.utxoOutput)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if let Some(ref v) = self.response.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.utxoOutput.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if let Some(ref v) = self.response.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.utxoOutput.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> PreExecWithSelectUTXOResponse {
        PreExecWithSelectUTXOResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &PreExecWithSelectUTXOResponse| { &m.header },
                    |m: &mut PreExecWithSelectUTXOResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &PreExecWithSelectUTXOResponse| { &m.bcname },
                    |m: &mut PreExecWithSelectUTXOResponse| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<InvokeResponse>>(
                    "response",
                    |m: &PreExecWithSelectUTXOResponse| { &m.response },
                    |m: &mut PreExecWithSelectUTXOResponse| { &mut m.response },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UtxoOutput>>(
                    "utxoOutput",
                    |m: &PreExecWithSelectUTXOResponse| { &m.utxoOutput },
                    |m: &mut PreExecWithSelectUTXOResponse| { &mut m.utxoOutput },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<PreExecWithSelectUTXOResponse>(
                    "PreExecWithSelectUTXOResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static PreExecWithSelectUTXOResponse {
        static mut instance: ::protobuf::lazy::Lazy<PreExecWithSelectUTXOResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(PreExecWithSelectUTXOResponse::new)
        }
    }
}

impl ::protobuf::Clear for PreExecWithSelectUTXOResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.response.clear();
        self.utxoOutput.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for PreExecWithSelectUTXOResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PreExecWithSelectUTXOResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ContractResponse {
    // message fields
    pub status: i32,
    #[serde(default)]
    pub message: ::std::string::String,
    #[serde(default)]
    #[serde(serialize_with = "crate::wallet::serialize_bytes")]
    #[serde(deserialize_with = "crate::wallet::deserialize_bytes")]
    pub body: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContractResponse {
    fn default() -> &'a ContractResponse {
        <ContractResponse as ::protobuf::Message>::default_instance()
    }
}

impl ContractResponse {
    pub fn new() -> ContractResponse {
        ::std::default::Default::default()
    }

    // int32 status = 1;


    pub fn get_status(&self) -> i32 {
        self.status
    }
    pub fn clear_status(&mut self) {
        self.status = 0;
    }

    // Param is passed by value, moved
    pub fn set_status(&mut self, v: i32) {
        self.status = v;
    }

    // string message = 2;


    pub fn get_message(&self) -> &str {
        &self.message
    }
    pub fn clear_message(&mut self) {
        self.message.clear();
    }

    // Param is passed by value, moved
    pub fn set_message(&mut self, v: ::std::string::String) {
        self.message = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_message(&mut self) -> &mut ::std::string::String {
        &mut self.message
    }

    // Take field
    pub fn take_message(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.message, ::std::string::String::new())
    }

    // bytes body = 3;


    pub fn get_body(&self) -> &[u8] {
        &self.body
    }
    pub fn clear_body(&mut self) {
        self.body.clear();
    }

    // Param is passed by value, moved
    pub fn set_body(&mut self, v: ::std::vec::Vec<u8>) {
        self.body = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_body(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.body
    }

    // Take field
    pub fn take_body(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.body, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for ContractResponse {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int32()?;
                    self.status = tmp;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.message)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.body)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.status != 0 {
            my_size += ::protobuf::rt::value_size(1, self.status, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.message);
        }
        if !self.body.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.body);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.status != 0 {
            os.write_int32(1, self.status)?;
        }
        if !self.message.is_empty() {
            os.write_string(2, &self.message)?;
        }
        if !self.body.is_empty() {
            os.write_bytes(3, &self.body)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractResponse {
        ContractResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt32>(
                    "status",
                    |m: &ContractResponse| { &m.status },
                    |m: &mut ContractResponse| { &mut m.status },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "message",
                    |m: &ContractResponse| { &m.message },
                    |m: &mut ContractResponse| { &mut m.message },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "body",
                    |m: &ContractResponse| { &m.body },
                    |m: &mut ContractResponse| { &mut m.body },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContractResponse>(
                    "ContractResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContractResponse {
        static mut instance: ::protobuf::lazy::Lazy<ContractResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ContractResponse::new)
        }
    }
}

impl ::protobuf::Clear for ContractResponse {
    fn clear(&mut self) {
        self.status = 0;
        self.message.clear();
        self.body.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContractResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ModifyBlock {
    // message fields
    pub effective_txid: ::std::string::String,
    pub marked: bool,
    pub effective_height: i64,
    pub public_key: ::std::string::String,
    pub sign: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ModifyBlock {
    fn default() -> &'a ModifyBlock {
        <ModifyBlock as ::protobuf::Message>::default_instance()
    }
}

impl ModifyBlock {
    pub fn new() -> ModifyBlock {
        ::std::default::Default::default()
    }

    // string effective_txid = 1;


    pub fn get_effective_txid(&self) -> &str {
        &self.effective_txid
    }
    pub fn clear_effective_txid(&mut self) {
        self.effective_txid.clear();
    }

    // Param is passed by value, moved
    pub fn set_effective_txid(&mut self, v: ::std::string::String) {
        self.effective_txid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_effective_txid(&mut self) -> &mut ::std::string::String {
        &mut self.effective_txid
    }

    // Take field
    pub fn take_effective_txid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.effective_txid, ::std::string::String::new())
    }

    // bool marked = 2;


    pub fn get_marked(&self) -> bool {
        self.marked
    }
    pub fn clear_marked(&mut self) {
        self.marked = false;
    }

    // Param is passed by value, moved
    pub fn set_marked(&mut self, v: bool) {
        self.marked = v;
    }

    // int64 effective_height = 3;


    pub fn get_effective_height(&self) -> i64 {
        self.effective_height
    }
    pub fn clear_effective_height(&mut self) {
        self.effective_height = 0;
    }

    // Param is passed by value, moved
    pub fn set_effective_height(&mut self, v: i64) {
        self.effective_height = v;
    }

    // string public_key = 4;


    pub fn get_public_key(&self) -> &str {
        &self.public_key
    }
    pub fn clear_public_key(&mut self) {
        self.public_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_public_key(&mut self, v: ::std::string::String) {
        self.public_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_public_key(&mut self) -> &mut ::std::string::String {
        &mut self.public_key
    }

    // Take field
    pub fn take_public_key(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.public_key, ::std::string::String::new())
    }

    // string sign = 5;


    pub fn get_sign(&self) -> &str {
        &self.sign
    }
    pub fn clear_sign(&mut self) {
        self.sign.clear();
    }

    // Param is passed by value, moved
    pub fn set_sign(&mut self, v: ::std::string::String) {
        self.sign = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_sign(&mut self) -> &mut ::std::string::String {
        &mut self.sign
    }

    // Take field
    pub fn take_sign(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.sign, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ModifyBlock {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.effective_txid)?;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_bool()?;
                    self.marked = tmp;
                },
                3 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.effective_height = tmp;
                },
                4 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.public_key)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.sign)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.effective_txid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.effective_txid);
        }
        if self.marked != false {
            my_size += 2;
        }
        if self.effective_height != 0 {
            my_size += ::protobuf::rt::value_size(3, self.effective_height, ::protobuf::wire_format::WireTypeVarint);
        }
        if !self.public_key.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.public_key);
        }
        if !self.sign.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.sign);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.effective_txid.is_empty() {
            os.write_string(1, &self.effective_txid)?;
        }
        if self.marked != false {
            os.write_bool(2, self.marked)?;
        }
        if self.effective_height != 0 {
            os.write_int64(3, self.effective_height)?;
        }
        if !self.public_key.is_empty() {
            os.write_string(4, &self.public_key)?;
        }
        if !self.sign.is_empty() {
            os.write_string(5, &self.sign)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ModifyBlock {
        ModifyBlock::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "effective_txid",
                    |m: &ModifyBlock| { &m.effective_txid },
                    |m: &mut ModifyBlock| { &mut m.effective_txid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBool>(
                    "marked",
                    |m: &ModifyBlock| { &m.marked },
                    |m: &mut ModifyBlock| { &mut m.marked },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "effective_height",
                    |m: &ModifyBlock| { &m.effective_height },
                    |m: &mut ModifyBlock| { &mut m.effective_height },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "public_key",
                    |m: &ModifyBlock| { &m.public_key },
                    |m: &mut ModifyBlock| { &mut m.public_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "sign",
                    |m: &ModifyBlock| { &m.sign },
                    |m: &mut ModifyBlock| { &mut m.sign },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ModifyBlock>(
                    "ModifyBlock",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ModifyBlock {
        static mut instance: ::protobuf::lazy::Lazy<ModifyBlock> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ModifyBlock::new)
        }
    }
}

impl ::protobuf::Clear for ModifyBlock {
    fn clear(&mut self) {
        self.effective_txid.clear();
        self.marked = false;
        self.effective_height = 0;
        self.public_key.clear();
        self.sign.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ModifyBlock {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ModifyBlock {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct HDInfo {
    // message fields
    pub hd_public_key: ::std::vec::Vec<u8>,
    pub original_hash: ::std::vec::Vec<u8>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a HDInfo {
    fn default() -> &'a HDInfo {
        <HDInfo as ::protobuf::Message>::default_instance()
    }
}

impl HDInfo {
    pub fn new() -> HDInfo {
        ::std::default::Default::default()
    }

    // bytes hd_public_key = 1;


    pub fn get_hd_public_key(&self) -> &[u8] {
        &self.hd_public_key
    }
    pub fn clear_hd_public_key(&mut self) {
        self.hd_public_key.clear();
    }

    // Param is passed by value, moved
    pub fn set_hd_public_key(&mut self, v: ::std::vec::Vec<u8>) {
        self.hd_public_key = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_hd_public_key(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.hd_public_key
    }

    // Take field
    pub fn take_hd_public_key(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.hd_public_key, ::std::vec::Vec::new())
    }

    // bytes original_hash = 2;


    pub fn get_original_hash(&self) -> &[u8] {
        &self.original_hash
    }
    pub fn clear_original_hash(&mut self) {
        self.original_hash.clear();
    }

    // Param is passed by value, moved
    pub fn set_original_hash(&mut self, v: ::std::vec::Vec<u8>) {
        self.original_hash = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_original_hash(&mut self) -> &mut ::std::vec::Vec<u8> {
        &mut self.original_hash
    }

    // Take field
    pub fn take_original_hash(&mut self) -> ::std::vec::Vec<u8> {
        ::std::mem::replace(&mut self.original_hash, ::std::vec::Vec::new())
    }
}

impl ::protobuf::Message for HDInfo {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.hd_public_key)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_bytes_into(wire_type, is, &mut self.original_hash)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.hd_public_key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.hd_public_key);
        }
        if !self.original_hash.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.original_hash);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.hd_public_key.is_empty() {
            os.write_bytes(1, &self.hd_public_key)?;
        }
        if !self.original_hash.is_empty() {
            os.write_bytes(2, &self.original_hash)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> HDInfo {
        HDInfo::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "hd_public_key",
                    |m: &HDInfo| { &m.hd_public_key },
                    |m: &mut HDInfo| { &mut m.hd_public_key },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeBytes>(
                    "original_hash",
                    |m: &HDInfo| { &m.original_hash },
                    |m: &mut HDInfo| { &mut m.original_hash },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<HDInfo>(
                    "HDInfo",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static HDInfo {
        static mut instance: ::protobuf::lazy::Lazy<HDInfo> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(HDInfo::new)
        }
    }
}

impl ::protobuf::Clear for HDInfo {
    fn clear(&mut self) {
        self.hd_public_key.clear();
        self.original_hash.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for HDInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HDInfo {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UtxoRecordDetail {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub accountName: ::std::string::String,
    pub openUtxoRecord: ::protobuf::SingularPtrField<UtxoRecord>,
    pub lockedUtxoRecord: ::protobuf::SingularPtrField<UtxoRecord>,
    pub frozenUtxoRecord: ::protobuf::SingularPtrField<UtxoRecord>,
    pub displayCount: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UtxoRecordDetail {
    fn default() -> &'a UtxoRecordDetail {
        <UtxoRecordDetail as ::protobuf::Message>::default_instance()
    }
}

impl UtxoRecordDetail {
    pub fn new() -> UtxoRecordDetail {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // string accountName = 3;


    pub fn get_accountName(&self) -> &str {
        &self.accountName
    }
    pub fn clear_accountName(&mut self) {
        self.accountName.clear();
    }

    // Param is passed by value, moved
    pub fn set_accountName(&mut self, v: ::std::string::String) {
        self.accountName = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_accountName(&mut self) -> &mut ::std::string::String {
        &mut self.accountName
    }

    // Take field
    pub fn take_accountName(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.accountName, ::std::string::String::new())
    }

    // .pb.UtxoRecord openUtxoRecord = 4;


    pub fn get_openUtxoRecord(&self) -> &UtxoRecord {
        self.openUtxoRecord.as_ref().unwrap_or_else(|| UtxoRecord::default_instance())
    }
    pub fn clear_openUtxoRecord(&mut self) {
        self.openUtxoRecord.clear();
    }

    pub fn has_openUtxoRecord(&self) -> bool {
        self.openUtxoRecord.is_some()
    }

    // Param is passed by value, moved
    pub fn set_openUtxoRecord(&mut self, v: UtxoRecord) {
        self.openUtxoRecord = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_openUtxoRecord(&mut self) -> &mut UtxoRecord {
        if self.openUtxoRecord.is_none() {
            self.openUtxoRecord.set_default();
        }
        self.openUtxoRecord.as_mut().unwrap()
    }

    // Take field
    pub fn take_openUtxoRecord(&mut self) -> UtxoRecord {
        self.openUtxoRecord.take().unwrap_or_else(|| UtxoRecord::new())
    }

    // .pb.UtxoRecord lockedUtxoRecord = 5;


    pub fn get_lockedUtxoRecord(&self) -> &UtxoRecord {
        self.lockedUtxoRecord.as_ref().unwrap_or_else(|| UtxoRecord::default_instance())
    }
    pub fn clear_lockedUtxoRecord(&mut self) {
        self.lockedUtxoRecord.clear();
    }

    pub fn has_lockedUtxoRecord(&self) -> bool {
        self.lockedUtxoRecord.is_some()
    }

    // Param is passed by value, moved
    pub fn set_lockedUtxoRecord(&mut self, v: UtxoRecord) {
        self.lockedUtxoRecord = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_lockedUtxoRecord(&mut self) -> &mut UtxoRecord {
        if self.lockedUtxoRecord.is_none() {
            self.lockedUtxoRecord.set_default();
        }
        self.lockedUtxoRecord.as_mut().unwrap()
    }

    // Take field
    pub fn take_lockedUtxoRecord(&mut self) -> UtxoRecord {
        self.lockedUtxoRecord.take().unwrap_or_else(|| UtxoRecord::new())
    }

    // .pb.UtxoRecord frozenUtxoRecord = 6;


    pub fn get_frozenUtxoRecord(&self) -> &UtxoRecord {
        self.frozenUtxoRecord.as_ref().unwrap_or_else(|| UtxoRecord::default_instance())
    }
    pub fn clear_frozenUtxoRecord(&mut self) {
        self.frozenUtxoRecord.clear();
    }

    pub fn has_frozenUtxoRecord(&self) -> bool {
        self.frozenUtxoRecord.is_some()
    }

    // Param is passed by value, moved
    pub fn set_frozenUtxoRecord(&mut self, v: UtxoRecord) {
        self.frozenUtxoRecord = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_frozenUtxoRecord(&mut self) -> &mut UtxoRecord {
        if self.frozenUtxoRecord.is_none() {
            self.frozenUtxoRecord.set_default();
        }
        self.frozenUtxoRecord.as_mut().unwrap()
    }

    // Take field
    pub fn take_frozenUtxoRecord(&mut self) -> UtxoRecord {
        self.frozenUtxoRecord.take().unwrap_or_else(|| UtxoRecord::new())
    }

    // int64 displayCount = 7;


    pub fn get_displayCount(&self) -> i64 {
        self.displayCount
    }
    pub fn clear_displayCount(&mut self) {
        self.displayCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_displayCount(&mut self, v: i64) {
        self.displayCount = v;
    }
}

impl ::protobuf::Message for UtxoRecordDetail {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.openUtxoRecord {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.lockedUtxoRecord {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.frozenUtxoRecord {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.accountName)?;
                },
                4 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.openUtxoRecord)?;
                },
                5 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.lockedUtxoRecord)?;
                },
                6 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.frozenUtxoRecord)?;
                },
                7 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.displayCount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if !self.accountName.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.accountName);
        }
        if let Some(ref v) = self.openUtxoRecord.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.lockedUtxoRecord.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if let Some(ref v) = self.frozenUtxoRecord.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if self.displayCount != 0 {
            my_size += ::protobuf::rt::value_size(7, self.displayCount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if !self.accountName.is_empty() {
            os.write_string(3, &self.accountName)?;
        }
        if let Some(ref v) = self.openUtxoRecord.as_ref() {
            os.write_tag(4, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.lockedUtxoRecord.as_ref() {
            os.write_tag(5, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if let Some(ref v) = self.frozenUtxoRecord.as_ref() {
            os.write_tag(6, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if self.displayCount != 0 {
            os.write_int64(7, self.displayCount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UtxoRecordDetail {
        UtxoRecordDetail::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &UtxoRecordDetail| { &m.header },
                    |m: &mut UtxoRecordDetail| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &UtxoRecordDetail| { &m.bcname },
                    |m: &mut UtxoRecordDetail| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "accountName",
                    |m: &UtxoRecordDetail| { &m.accountName },
                    |m: &mut UtxoRecordDetail| { &mut m.accountName },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UtxoRecord>>(
                    "openUtxoRecord",
                    |m: &UtxoRecordDetail| { &m.openUtxoRecord },
                    |m: &mut UtxoRecordDetail| { &mut m.openUtxoRecord },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UtxoRecord>>(
                    "lockedUtxoRecord",
                    |m: &UtxoRecordDetail| { &m.lockedUtxoRecord },
                    |m: &mut UtxoRecordDetail| { &mut m.lockedUtxoRecord },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UtxoRecord>>(
                    "frozenUtxoRecord",
                    |m: &UtxoRecordDetail| { &m.frozenUtxoRecord },
                    |m: &mut UtxoRecordDetail| { &mut m.frozenUtxoRecord },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "displayCount",
                    |m: &UtxoRecordDetail| { &m.displayCount },
                    |m: &mut UtxoRecordDetail| { &mut m.displayCount },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UtxoRecordDetail>(
                    "UtxoRecordDetail",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UtxoRecordDetail {
        static mut instance: ::protobuf::lazy::Lazy<UtxoRecordDetail> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UtxoRecordDetail::new)
        }
    }
}

impl ::protobuf::Clear for UtxoRecordDetail {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.accountName.clear();
        self.openUtxoRecord.clear();
        self.lockedUtxoRecord.clear();
        self.frozenUtxoRecord.clear();
        self.displayCount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UtxoRecordDetail {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UtxoRecordDetail {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UtxoRecord {
    // message fields
    pub utxoCount: ::std::string::String,
    pub utxoAmount: ::std::string::String,
    pub item: ::protobuf::RepeatedField<UtxoKey>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UtxoRecord {
    fn default() -> &'a UtxoRecord {
        <UtxoRecord as ::protobuf::Message>::default_instance()
    }
}

impl UtxoRecord {
    pub fn new() -> UtxoRecord {
        ::std::default::Default::default()
    }

    // string utxoCount = 1;


    pub fn get_utxoCount(&self) -> &str {
        &self.utxoCount
    }
    pub fn clear_utxoCount(&mut self) {
        self.utxoCount.clear();
    }

    // Param is passed by value, moved
    pub fn set_utxoCount(&mut self, v: ::std::string::String) {
        self.utxoCount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_utxoCount(&mut self) -> &mut ::std::string::String {
        &mut self.utxoCount
    }

    // Take field
    pub fn take_utxoCount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.utxoCount, ::std::string::String::new())
    }

    // string utxoAmount = 2;


    pub fn get_utxoAmount(&self) -> &str {
        &self.utxoAmount
    }
    pub fn clear_utxoAmount(&mut self) {
        self.utxoAmount.clear();
    }

    // Param is passed by value, moved
    pub fn set_utxoAmount(&mut self, v: ::std::string::String) {
        self.utxoAmount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_utxoAmount(&mut self) -> &mut ::std::string::String {
        &mut self.utxoAmount
    }

    // Take field
    pub fn take_utxoAmount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.utxoAmount, ::std::string::String::new())
    }

    // repeated .pb.UtxoKey item = 3;


    pub fn get_item(&self) -> &[UtxoKey] {
        &self.item
    }
    pub fn clear_item(&mut self) {
        self.item.clear();
    }

    // Param is passed by value, moved
    pub fn set_item(&mut self, v: ::protobuf::RepeatedField<UtxoKey>) {
        self.item = v;
    }

    // Mutable pointer to the field.
    pub fn mut_item(&mut self) -> &mut ::protobuf::RepeatedField<UtxoKey> {
        &mut self.item
    }

    // Take field
    pub fn take_item(&mut self) -> ::protobuf::RepeatedField<UtxoKey> {
        ::std::mem::replace(&mut self.item, ::protobuf::RepeatedField::new())
    }
}

impl ::protobuf::Message for UtxoRecord {
    fn is_initialized(&self) -> bool {
        for v in &self.item {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.utxoCount)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.utxoAmount)?;
                },
                3 => {
                    ::protobuf::rt::read_repeated_message_into(wire_type, is, &mut self.item)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.utxoCount.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.utxoCount);
        }
        if !self.utxoAmount.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.utxoAmount);
        }
        for value in &self.item {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.utxoCount.is_empty() {
            os.write_string(1, &self.utxoCount)?;
        }
        if !self.utxoAmount.is_empty() {
            os.write_string(2, &self.utxoAmount)?;
        }
        for v in &self.item {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        };
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UtxoRecord {
        UtxoRecord::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "utxoCount",
                    |m: &UtxoRecord| { &m.utxoCount },
                    |m: &mut UtxoRecord| { &mut m.utxoCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "utxoAmount",
                    |m: &UtxoRecord| { &m.utxoAmount },
                    |m: &mut UtxoRecord| { &mut m.utxoAmount },
                ));
                fields.push(::protobuf::reflect::accessor::make_repeated_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<UtxoKey>>(
                    "item",
                    |m: &UtxoRecord| { &m.item },
                    |m: &mut UtxoRecord| { &mut m.item },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UtxoRecord>(
                    "UtxoRecord",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UtxoRecord {
        static mut instance: ::protobuf::lazy::Lazy<UtxoRecord> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UtxoRecord::new)
        }
    }
}

impl ::protobuf::Clear for UtxoRecord {
    fn clear(&mut self) {
        self.utxoCount.clear();
        self.utxoAmount.clear();
        self.item.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UtxoRecord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UtxoRecord {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct UtxoKey {
    // message fields
    pub refTxid: ::std::string::String,
    pub offset: ::std::string::String,
    pub amount: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a UtxoKey {
    fn default() -> &'a UtxoKey {
        <UtxoKey as ::protobuf::Message>::default_instance()
    }
}

impl UtxoKey {
    pub fn new() -> UtxoKey {
        ::std::default::Default::default()
    }

    // string refTxid = 1;


    pub fn get_refTxid(&self) -> &str {
        &self.refTxid
    }
    pub fn clear_refTxid(&mut self) {
        self.refTxid.clear();
    }

    // Param is passed by value, moved
    pub fn set_refTxid(&mut self, v: ::std::string::String) {
        self.refTxid = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_refTxid(&mut self) -> &mut ::std::string::String {
        &mut self.refTxid
    }

    // Take field
    pub fn take_refTxid(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.refTxid, ::std::string::String::new())
    }

    // string offset = 2;


    pub fn get_offset(&self) -> &str {
        &self.offset
    }
    pub fn clear_offset(&mut self) {
        self.offset.clear();
    }

    // Param is passed by value, moved
    pub fn set_offset(&mut self, v: ::std::string::String) {
        self.offset = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_offset(&mut self) -> &mut ::std::string::String {
        &mut self.offset
    }

    // Take field
    pub fn take_offset(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.offset, ::std::string::String::new())
    }

    // string amount = 3;


    pub fn get_amount(&self) -> &str {
        &self.amount
    }
    pub fn clear_amount(&mut self) {
        self.amount.clear();
    }

    // Param is passed by value, moved
    pub fn set_amount(&mut self, v: ::std::string::String) {
        self.amount = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_amount(&mut self) -> &mut ::std::string::String {
        &mut self.amount
    }

    // Take field
    pub fn take_amount(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.amount, ::std::string::String::new())
    }
}

impl ::protobuf::Message for UtxoKey {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.refTxid)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.offset)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.amount)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if !self.refTxid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.refTxid);
        }
        if !self.offset.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.offset);
        }
        if !self.amount.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.amount);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if !self.refTxid.is_empty() {
            os.write_string(1, &self.refTxid)?;
        }
        if !self.offset.is_empty() {
            os.write_string(2, &self.offset)?;
        }
        if !self.amount.is_empty() {
            os.write_string(3, &self.amount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> UtxoKey {
        UtxoKey::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "refTxid",
                    |m: &UtxoKey| { &m.refTxid },
                    |m: &mut UtxoKey| { &mut m.refTxid },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "offset",
                    |m: &UtxoKey| { &m.offset },
                    |m: &mut UtxoKey| { &mut m.offset },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "amount",
                    |m: &UtxoKey| { &m.amount },
                    |m: &mut UtxoKey| { &mut m.amount },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<UtxoKey>(
                    "UtxoKey",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static UtxoKey {
        static mut instance: ::protobuf::lazy::Lazy<UtxoKey> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(UtxoKey::new)
        }
    }
}

impl ::protobuf::Clear for UtxoKey {
    fn clear(&mut self) {
        self.refTxid.clear();
        self.offset.clear();
        self.amount.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for UtxoKey {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UtxoKey {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ContractStatDataRequest {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContractStatDataRequest {
    fn default() -> &'a ContractStatDataRequest {
        <ContractStatDataRequest as ::protobuf::Message>::default_instance()
    }
}

impl ContractStatDataRequest {
    pub fn new() -> ContractStatDataRequest {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }
}

impl ::protobuf::Message for ContractStatDataRequest {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractStatDataRequest {
        ContractStatDataRequest::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &ContractStatDataRequest| { &m.header },
                    |m: &mut ContractStatDataRequest| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &ContractStatDataRequest| { &m.bcname },
                    |m: &mut ContractStatDataRequest| { &mut m.bcname },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContractStatDataRequest>(
                    "ContractStatDataRequest",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContractStatDataRequest {
        static mut instance: ::protobuf::lazy::Lazy<ContractStatDataRequest> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ContractStatDataRequest::new)
        }
    }
}

impl ::protobuf::Clear for ContractStatDataRequest {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContractStatDataRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractStatDataRequest {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ContractStatDataResponse {
    // message fields
    pub header: ::protobuf::SingularPtrField<Header>,
    pub bcname: ::std::string::String,
    pub data: ::protobuf::SingularPtrField<ContractStatData>,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContractStatDataResponse {
    fn default() -> &'a ContractStatDataResponse {
        <ContractStatDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl ContractStatDataResponse {
    pub fn new() -> ContractStatDataResponse {
        ::std::default::Default::default()
    }

    // .pb.Header header = 1;


    pub fn get_header(&self) -> &Header {
        self.header.as_ref().unwrap_or_else(|| Header::default_instance())
    }
    pub fn clear_header(&mut self) {
        self.header.clear();
    }

    pub fn has_header(&self) -> bool {
        self.header.is_some()
    }

    // Param is passed by value, moved
    pub fn set_header(&mut self, v: Header) {
        self.header = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_header(&mut self) -> &mut Header {
        if self.header.is_none() {
            self.header.set_default();
        }
        self.header.as_mut().unwrap()
    }

    // Take field
    pub fn take_header(&mut self) -> Header {
        self.header.take().unwrap_or_else(|| Header::new())
    }

    // string bcname = 2;


    pub fn get_bcname(&self) -> &str {
        &self.bcname
    }
    pub fn clear_bcname(&mut self) {
        self.bcname.clear();
    }

    // Param is passed by value, moved
    pub fn set_bcname(&mut self, v: ::std::string::String) {
        self.bcname = v;
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_bcname(&mut self) -> &mut ::std::string::String {
        &mut self.bcname
    }

    // Take field
    pub fn take_bcname(&mut self) -> ::std::string::String {
        ::std::mem::replace(&mut self.bcname, ::std::string::String::new())
    }

    // .pb.ContractStatData data = 3;


    pub fn get_data(&self) -> &ContractStatData {
        self.data.as_ref().unwrap_or_else(|| ContractStatData::default_instance())
    }
    pub fn clear_data(&mut self) {
        self.data.clear();
    }

    pub fn has_data(&self) -> bool {
        self.data.is_some()
    }

    // Param is passed by value, moved
    pub fn set_data(&mut self, v: ContractStatData) {
        self.data = ::protobuf::SingularPtrField::some(v);
    }

    // Mutable pointer to the field.
    // If field is not initialized, it is initialized with default value first.
    pub fn mut_data(&mut self) -> &mut ContractStatData {
        if self.data.is_none() {
            self.data.set_default();
        }
        self.data.as_mut().unwrap()
    }

    // Take field
    pub fn take_data(&mut self) -> ContractStatData {
        self.data.take().unwrap_or_else(|| ContractStatData::new())
    }
}

impl ::protobuf::Message for ContractStatDataResponse {
    fn is_initialized(&self) -> bool {
        for v in &self.header {
            if !v.is_initialized() {
                return false;
            }
        };
        for v in &self.data {
            if !v.is_initialized() {
                return false;
            }
        };
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.header)?;
                },
                2 => {
                    ::protobuf::rt::read_singular_proto3_string_into(wire_type, is, &mut self.bcname)?;
                },
                3 => {
                    ::protobuf::rt::read_singular_message_into(wire_type, is, &mut self.data)?;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if let Some(ref v) = self.header.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        if !self.bcname.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.bcname);
        }
        if let Some(ref v) = self.data.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint32_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if let Some(ref v) = self.header.as_ref() {
            os.write_tag(1, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        if !self.bcname.is_empty() {
            os.write_string(2, &self.bcname)?;
        }
        if let Some(ref v) = self.data.as_ref() {
            os.write_tag(3, ::protobuf::wire_format::WireTypeLengthDelimited)?;
            os.write_raw_varint32(v.get_cached_size())?;
            v.write_to_with_cached_sizes(os)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractStatDataResponse {
        ContractStatDataResponse::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<Header>>(
                    "header",
                    |m: &ContractStatDataResponse| { &m.header },
                    |m: &mut ContractStatDataResponse| { &mut m.header },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeString>(
                    "bcname",
                    |m: &ContractStatDataResponse| { &m.bcname },
                    |m: &mut ContractStatDataResponse| { &mut m.bcname },
                ));
                fields.push(::protobuf::reflect::accessor::make_singular_ptr_field_accessor::<_, ::protobuf::types::ProtobufTypeMessage<ContractStatData>>(
                    "data",
                    |m: &ContractStatDataResponse| { &m.data },
                    |m: &mut ContractStatDataResponse| { &mut m.data },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContractStatDataResponse>(
                    "ContractStatDataResponse",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContractStatDataResponse {
        static mut instance: ::protobuf::lazy::Lazy<ContractStatDataResponse> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ContractStatDataResponse::new)
        }
    }
}

impl ::protobuf::Clear for ContractStatDataResponse {
    fn clear(&mut self) {
        self.header.clear();
        self.bcname.clear();
        self.data.clear();
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContractStatDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractStatDataResponse {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(PartialEq,Clone,Default)]
#[cfg_attr(feature = "with-serde", derive(Serialize, Deserialize))]
pub struct ContractStatData {
    // message fields
    pub accountCount: i64,
    pub contractCount: i64,
    // special fields
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub unknown_fields: ::protobuf::UnknownFields,
    #[cfg_attr(feature = "with-serde", serde(skip))]
    pub cached_size: ::protobuf::CachedSize,
}

impl<'a> ::std::default::Default for &'a ContractStatData {
    fn default() -> &'a ContractStatData {
        <ContractStatData as ::protobuf::Message>::default_instance()
    }
}

impl ContractStatData {
    pub fn new() -> ContractStatData {
        ::std::default::Default::default()
    }

    // int64 accountCount = 1;


    pub fn get_accountCount(&self) -> i64 {
        self.accountCount
    }
    pub fn clear_accountCount(&mut self) {
        self.accountCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_accountCount(&mut self, v: i64) {
        self.accountCount = v;
    }

    // int64 contractCount = 2;


    pub fn get_contractCount(&self) -> i64 {
        self.contractCount
    }
    pub fn clear_contractCount(&mut self) {
        self.contractCount = 0;
    }

    // Param is passed by value, moved
    pub fn set_contractCount(&mut self, v: i64) {
        self.contractCount = v;
    }
}

impl ::protobuf::Message for ContractStatData {
    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        while !is.eof()? {
            let (field_number, wire_type) = is.read_tag_unpack()?;
            match field_number {
                1 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.accountCount = tmp;
                },
                2 => {
                    if wire_type != ::protobuf::wire_format::WireTypeVarint {
                        return ::std::result::Result::Err(::protobuf::rt::unexpected_wire_type(wire_type));
                    }
                    let tmp = is.read_int64()?;
                    self.contractCount = tmp;
                },
                _ => {
                    ::protobuf::rt::read_unknown_or_skip_group(field_number, wire_type, is, self.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u32 {
        let mut my_size = 0;
        if self.accountCount != 0 {
            my_size += ::protobuf::rt::value_size(1, self.accountCount, ::protobuf::wire_format::WireTypeVarint);
        }
        if self.contractCount != 0 {
            my_size += ::protobuf::rt::value_size(2, self.contractCount, ::protobuf::wire_format::WireTypeVarint);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.get_unknown_fields());
        self.cached_size.set(my_size);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::ProtobufResult<()> {
        if self.accountCount != 0 {
            os.write_int64(1, self.accountCount)?;
        }
        if self.contractCount != 0 {
            os.write_int64(2, self.contractCount)?;
        }
        os.write_unknown_fields(self.get_unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn get_cached_size(&self) -> u32 {
        self.cached_size.get()
    }

    fn get_unknown_fields(&self) -> &::protobuf::UnknownFields {
        &self.unknown_fields
    }

    fn mut_unknown_fields(&mut self) -> &mut ::protobuf::UnknownFields {
        &mut self.unknown_fields
    }

    fn as_any(&self) -> &dyn (::std::any::Any) {
        self as &dyn (::std::any::Any)
    }
    fn as_any_mut(&mut self) -> &mut dyn (::std::any::Any) {
        self as &mut dyn (::std::any::Any)
    }
    fn into_any(self: Box<Self>) -> ::std::boxed::Box<dyn (::std::any::Any)> {
        self
    }

    fn descriptor(&self) -> &'static ::protobuf::reflect::MessageDescriptor {
        Self::descriptor_static()
    }

    fn new() -> ContractStatData {
        ContractStatData::new()
    }

    fn descriptor_static() -> &'static ::protobuf::reflect::MessageDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                let mut fields = ::std::vec::Vec::new();
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "accountCount",
                    |m: &ContractStatData| { &m.accountCount },
                    |m: &mut ContractStatData| { &mut m.accountCount },
                ));
                fields.push(::protobuf::reflect::accessor::make_simple_field_accessor::<_, ::protobuf::types::ProtobufTypeInt64>(
                    "contractCount",
                    |m: &ContractStatData| { &m.contractCount },
                    |m: &mut ContractStatData| { &mut m.contractCount },
                ));
                ::protobuf::reflect::MessageDescriptor::new_pb_name::<ContractStatData>(
                    "ContractStatData",
                    fields,
                    file_descriptor_proto()
                )
            })
        }
    }

    fn default_instance() -> &'static ContractStatData {
        static mut instance: ::protobuf::lazy::Lazy<ContractStatData> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            instance.get(ContractStatData::new)
        }
    }
}

impl ::protobuf::Clear for ContractStatData {
    fn clear(&mut self) {
        self.accountCount = 0;
        self.contractCount = 0;
        self.unknown_fields.clear();
    }
}

impl ::std::fmt::Debug for ContractStatData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ContractStatData {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Message(self)
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize_repr, Deserialize_repr))]
#[repr(u8)]
pub enum XChainErrorEnum {
    SUCCESS = 0,
    UNKNOW_ERROR = 1,
    CONNECT_REFUSE = 2,
    NOT_ENOUGH_UTXO_ERROR = 3,
    UTXOVM_ALREADY_UNCONFIRM_ERROR = 4,
    UTXOVM_NOT_FOUND_ERROR = 5,
    INPUT_OUTPUT_NOT_EQUAL_ERROR = 6,
    TX_NOT_FOUND_ERROR = 7,
    TX_SIGN_ERROR = 8,
    BLOCKCHAIN_NOTEXIST = 9,
    VALIDATE_ERROR = 10,
    CANNOT_SYNC_BLOCK_ERROR = 11,
    CONFIRM_BLOCK_ERROR = 12,
    UTXOVM_PLAY_ERROR = 13,
    WALK_ERROR = 14,
    NOT_READY_ERROR = 15,
    BLOCK_EXIST_ERROR = 16,
    ROOT_BLOCK_EXIST_ERROR = 17,
    TX_DUPLICATE_ERROR = 19,
    SERVICE_REFUSED_ERROR = 20,
    TXDATA_SIGN_ERROR = 21,
    TX_SLE_ERROR = 25,
    TX_FEE_NOT_ENOUGH_ERROR = 26,
    UTXO_SIGN_ERROR = 28,
    DPOS_QUERY_ERROR = 31,
    RWSET_INVALID_ERROR = 33,
    RWACL_INVALID_ERROR = 34,
    GAS_NOT_ENOUGH_ERROR = 35,
    TX_VERSION_INVALID_ERROR = 36,
    COMPLIANCE_CHECK_NOT_APPROVED = 37,
    ACCOUNT_CONTRACT_STATUS_ERROR = 38,
    TX_VERIFICATION_ERROR = 40,
}

impl ::protobuf::ProtobufEnum for XChainErrorEnum {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<XChainErrorEnum> {
        match value {
            0 => ::std::option::Option::Some(XChainErrorEnum::SUCCESS),
            1 => ::std::option::Option::Some(XChainErrorEnum::UNKNOW_ERROR),
            2 => ::std::option::Option::Some(XChainErrorEnum::CONNECT_REFUSE),
            3 => ::std::option::Option::Some(XChainErrorEnum::NOT_ENOUGH_UTXO_ERROR),
            4 => ::std::option::Option::Some(XChainErrorEnum::UTXOVM_ALREADY_UNCONFIRM_ERROR),
            5 => ::std::option::Option::Some(XChainErrorEnum::UTXOVM_NOT_FOUND_ERROR),
            6 => ::std::option::Option::Some(XChainErrorEnum::INPUT_OUTPUT_NOT_EQUAL_ERROR),
            7 => ::std::option::Option::Some(XChainErrorEnum::TX_NOT_FOUND_ERROR),
            8 => ::std::option::Option::Some(XChainErrorEnum::TX_SIGN_ERROR),
            9 => ::std::option::Option::Some(XChainErrorEnum::BLOCKCHAIN_NOTEXIST),
            10 => ::std::option::Option::Some(XChainErrorEnum::VALIDATE_ERROR),
            11 => ::std::option::Option::Some(XChainErrorEnum::CANNOT_SYNC_BLOCK_ERROR),
            12 => ::std::option::Option::Some(XChainErrorEnum::CONFIRM_BLOCK_ERROR),
            13 => ::std::option::Option::Some(XChainErrorEnum::UTXOVM_PLAY_ERROR),
            14 => ::std::option::Option::Some(XChainErrorEnum::WALK_ERROR),
            15 => ::std::option::Option::Some(XChainErrorEnum::NOT_READY_ERROR),
            16 => ::std::option::Option::Some(XChainErrorEnum::BLOCK_EXIST_ERROR),
            17 => ::std::option::Option::Some(XChainErrorEnum::ROOT_BLOCK_EXIST_ERROR),
            19 => ::std::option::Option::Some(XChainErrorEnum::TX_DUPLICATE_ERROR),
            20 => ::std::option::Option::Some(XChainErrorEnum::SERVICE_REFUSED_ERROR),
            21 => ::std::option::Option::Some(XChainErrorEnum::TXDATA_SIGN_ERROR),
            25 => ::std::option::Option::Some(XChainErrorEnum::TX_SLE_ERROR),
            26 => ::std::option::Option::Some(XChainErrorEnum::TX_FEE_NOT_ENOUGH_ERROR),
            28 => ::std::option::Option::Some(XChainErrorEnum::UTXO_SIGN_ERROR),
            31 => ::std::option::Option::Some(XChainErrorEnum::DPOS_QUERY_ERROR),
            33 => ::std::option::Option::Some(XChainErrorEnum::RWSET_INVALID_ERROR),
            34 => ::std::option::Option::Some(XChainErrorEnum::RWACL_INVALID_ERROR),
            35 => ::std::option::Option::Some(XChainErrorEnum::GAS_NOT_ENOUGH_ERROR),
            36 => ::std::option::Option::Some(XChainErrorEnum::TX_VERSION_INVALID_ERROR),
            37 => ::std::option::Option::Some(XChainErrorEnum::COMPLIANCE_CHECK_NOT_APPROVED),
            38 => ::std::option::Option::Some(XChainErrorEnum::ACCOUNT_CONTRACT_STATUS_ERROR),
            40 => ::std::option::Option::Some(XChainErrorEnum::TX_VERIFICATION_ERROR),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [XChainErrorEnum] = &[
            XChainErrorEnum::SUCCESS,
            XChainErrorEnum::UNKNOW_ERROR,
            XChainErrorEnum::CONNECT_REFUSE,
            XChainErrorEnum::NOT_ENOUGH_UTXO_ERROR,
            XChainErrorEnum::UTXOVM_ALREADY_UNCONFIRM_ERROR,
            XChainErrorEnum::UTXOVM_NOT_FOUND_ERROR,
            XChainErrorEnum::INPUT_OUTPUT_NOT_EQUAL_ERROR,
            XChainErrorEnum::TX_NOT_FOUND_ERROR,
            XChainErrorEnum::TX_SIGN_ERROR,
            XChainErrorEnum::BLOCKCHAIN_NOTEXIST,
            XChainErrorEnum::VALIDATE_ERROR,
            XChainErrorEnum::CANNOT_SYNC_BLOCK_ERROR,
            XChainErrorEnum::CONFIRM_BLOCK_ERROR,
            XChainErrorEnum::UTXOVM_PLAY_ERROR,
            XChainErrorEnum::WALK_ERROR,
            XChainErrorEnum::NOT_READY_ERROR,
            XChainErrorEnum::BLOCK_EXIST_ERROR,
            XChainErrorEnum::ROOT_BLOCK_EXIST_ERROR,
            XChainErrorEnum::TX_DUPLICATE_ERROR,
            XChainErrorEnum::SERVICE_REFUSED_ERROR,
            XChainErrorEnum::TXDATA_SIGN_ERROR,
            XChainErrorEnum::TX_SLE_ERROR,
            XChainErrorEnum::TX_FEE_NOT_ENOUGH_ERROR,
            XChainErrorEnum::UTXO_SIGN_ERROR,
            XChainErrorEnum::DPOS_QUERY_ERROR,
            XChainErrorEnum::RWSET_INVALID_ERROR,
            XChainErrorEnum::RWACL_INVALID_ERROR,
            XChainErrorEnum::GAS_NOT_ENOUGH_ERROR,
            XChainErrorEnum::TX_VERSION_INVALID_ERROR,
            XChainErrorEnum::COMPLIANCE_CHECK_NOT_APPROVED,
            XChainErrorEnum::ACCOUNT_CONTRACT_STATUS_ERROR,
            XChainErrorEnum::TX_VERIFICATION_ERROR,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<XChainErrorEnum>("XChainErrorEnum", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for XChainErrorEnum {
}

impl ::std::default::Default for XChainErrorEnum {
    fn default() -> Self {
        XChainErrorEnum::SUCCESS
    }
}

impl ::protobuf::reflect::ProtobufValue for XChainErrorEnum {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize_repr, Deserialize_repr))]
#[repr(u8)]
pub enum TransactionStatus {
    UNDEFINE = 0,
    NOEXIST = 1,
    CONFIRM = 2,
    FURCATION = 3,
    UNCONFIRM = 4,
    FAILED = 5,
}

impl ::protobuf::ProtobufEnum for TransactionStatus {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TransactionStatus> {
        match value {
            0 => ::std::option::Option::Some(TransactionStatus::UNDEFINE),
            1 => ::std::option::Option::Some(TransactionStatus::NOEXIST),
            2 => ::std::option::Option::Some(TransactionStatus::CONFIRM),
            3 => ::std::option::Option::Some(TransactionStatus::FURCATION),
            4 => ::std::option::Option::Some(TransactionStatus::UNCONFIRM),
            5 => ::std::option::Option::Some(TransactionStatus::FAILED),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [TransactionStatus] = &[
            TransactionStatus::UNDEFINE,
            TransactionStatus::NOEXIST,
            TransactionStatus::CONFIRM,
            TransactionStatus::FURCATION,
            TransactionStatus::UNCONFIRM,
            TransactionStatus::FAILED,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<TransactionStatus>("TransactionStatus", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for TransactionStatus {
}

impl ::std::default::Default for TransactionStatus {
    fn default() -> Self {
        TransactionStatus::UNDEFINE
    }
}

impl ::protobuf::reflect::ProtobufValue for TransactionStatus {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize_repr, Deserialize_repr))]
#[repr(u8)]
pub enum PermissionRule {
    NULL = 0,
    SIGN_THRESHOLD = 1,
    SIGN_AKSET = 2,
    SIGN_RATE = 3,
    SIGN_SUM = 4,
    CA_SERVER = 5,
    COMMUNITY_VOTE = 6,
}

impl ::protobuf::ProtobufEnum for PermissionRule {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<PermissionRule> {
        match value {
            0 => ::std::option::Option::Some(PermissionRule::NULL),
            1 => ::std::option::Option::Some(PermissionRule::SIGN_THRESHOLD),
            2 => ::std::option::Option::Some(PermissionRule::SIGN_AKSET),
            3 => ::std::option::Option::Some(PermissionRule::SIGN_RATE),
            4 => ::std::option::Option::Some(PermissionRule::SIGN_SUM),
            5 => ::std::option::Option::Some(PermissionRule::CA_SERVER),
            6 => ::std::option::Option::Some(PermissionRule::COMMUNITY_VOTE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [PermissionRule] = &[
            PermissionRule::NULL,
            PermissionRule::SIGN_THRESHOLD,
            PermissionRule::SIGN_AKSET,
            PermissionRule::SIGN_RATE,
            PermissionRule::SIGN_SUM,
            PermissionRule::CA_SERVER,
            PermissionRule::COMMUNITY_VOTE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<PermissionRule>("PermissionRule", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for PermissionRule {
}

impl ::std::default::Default for PermissionRule {
    fn default() -> Self {
        PermissionRule::NULL
    }
}

impl ::protobuf::reflect::ProtobufValue for PermissionRule {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

#[derive(Clone,PartialEq,Eq,Debug,Hash)]
#[cfg_attr(feature = "with-serde", derive(Serialize_repr, Deserialize_repr))]
#[repr(u8)]
pub enum ResourceType {
    CPU = 0,
    MEMORY = 1,
    DISK = 2,
    XFEE = 3,
}

impl ::protobuf::ProtobufEnum for ResourceType {
    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ResourceType> {
        match value {
            0 => ::std::option::Option::Some(ResourceType::CPU),
            1 => ::std::option::Option::Some(ResourceType::MEMORY),
            2 => ::std::option::Option::Some(ResourceType::DISK),
            3 => ::std::option::Option::Some(ResourceType::XFEE),
            _ => ::std::option::Option::None
        }
    }

    fn values() -> &'static [Self] {
        static values: &'static [ResourceType] = &[
            ResourceType::CPU,
            ResourceType::MEMORY,
            ResourceType::DISK,
            ResourceType::XFEE,
        ];
        values
    }

    fn enum_descriptor_static() -> &'static ::protobuf::reflect::EnumDescriptor {
        static mut descriptor: ::protobuf::lazy::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::lazy::Lazy::INIT;
        unsafe {
            descriptor.get(|| {
                ::protobuf::reflect::EnumDescriptor::new_pb_name::<ResourceType>("ResourceType", file_descriptor_proto())
            })
        }
    }
}

impl ::std::marker::Copy for ResourceType {
}

impl ::std::default::Default for ResourceType {
    fn default() -> Self {
        ResourceType::CPU
    }
}

impl ::protobuf::reflect::ProtobufValue for ResourceType {
    fn as_ref(&self) -> ::protobuf::reflect::ReflectValueRef {
        ::protobuf::reflect::ReflectValueRef::Enum(self.descriptor())
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\x0cxchain.proto\x12\x02pb\x1a\x10chainedbft.proto\"f\n\x06Header\x12\
    \x14\n\x05logid\x18\x01\x20\x01(\tR\x05logid\x12\x1b\n\tfrom_node\x18\
    \x02\x20\x01(\tR\x08fromNode\x12)\n\x05error\x18\x03\x20\x01(\x0e2\x13.p\
    b.XChainErrorEnumR\x05error\"f\n\rTxDataAccount\x12\x18\n\x07address\x18\
    \x01\x20\x01(\tR\x07address\x12\x16\n\x06amount\x18\x02\x20\x01(\tR\x06a\
    mount\x12#\n\rfrozen_height\x18\x03\x20\x01(\x03R\x0cfrozenHeight\"\xe3\
    \x02\n\x06TxData\x12\"\n\x06header\x18\r\x20\x01(\x0b2\n.pb.HeaderR\x06h\
    eader\x12\x12\n\x04txid\x18\x01\x20\x01(\x0cR\x04txid\x12\x16\n\x06bcnam\
    e\x18\x02\x20\x01(\tR\x06bcname\x12\x1b\n\tfrom_addr\x18\x03\x20\x01(\tR\
    \x08fromAddr\x12\x1f\n\x0bfrom_pubkey\x18\x04\x20\x01(\tR\nfromPubkey\
    \x12\x1f\n\x0bfrom_scrkey\x18\x05\x20\x01(\tR\nfromScrkey\x12\x1b\n\tuse\
    r_sign\x18\x0e\x20\x01(\x0cR\x08userSign\x12+\n\x07account\x18\x06\x20\
    \x03(\x0b2\x11.pb.TxDataAccountR\x07account\x12\x14\n\x05nonce\x18\x08\
    \x20\x01(\tR\x05nonce\x12\x1c\n\ttimestamp\x18\t\x20\x01(\x03R\ttimestam\
    p\x12\x12\n\x04desc\x18\x0c\x20\x01(\x0cR\x04desc\x12\x18\n\x07version\
    \x18\x0f\x20\x01(\x05R\x07version\"\xc6\x01\n\x08TxStatus\x12\"\n\x06hea\
    der\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x16\n\x06bcname\x18\
    \x02\x20\x01(\tR\x06bcname\x12\x12\n\x04txid\x18\x03\x20\x01(\x0cR\x04tx\
    id\x12-\n\x06status\x18\x04\x20\x01(\x0e2\x15.pb.TransactionStatusR\x06s\
    tatus\x12\x1a\n\x08distance\x18\x05\x20\x01(\x03R\x08distance\x12\x1f\n\
    \x02tx\x18\x07\x20\x01(\x0b2\x0f.pb.TransactionR\x02tx\"N\n\x08BatchTxs\
    \x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x1e\
    \n\x03Txs\x18\x02\x20\x03(\x0b2\x0c.pb.TxStatusR\x03Txs\"\xf5\x01\n\x05B\
    lock\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\
    \x16\n\x06bcname\x18\x02\x20\x01(\tR\x06bcname\x12\x18\n\x07blockid\x18\
    \x03\x20\x01(\x0cR\x07blockid\x12.\n\x06status\x18\x04\x20\x01(\x0e2\x16\
    .pb.Block.EBlockStatusR\x06status\x12'\n\x05block\x18\x05\x20\x01(\x0b2\
    \x11.pb.InternalBlockR\x05block\"=\n\x0cEBlockStatus\x12\t\n\x05ERROR\
    \x10\0\x12\t\n\x05TRUNK\x10\x01\x12\n\n\x06BRANCH\x10\x02\x12\x0b\n\x07N\
    OEXIST\x10\x03\"\x82\x01\n\x07BlockID\x12\"\n\x06header\x18\x04\x20\x01(\
    \x0b2\n.pb.HeaderR\x06header\x12\x16\n\x06bcname\x18\x01\x20\x01(\tR\x06\
    bcname\x12\x18\n\x07blockid\x18\x02\x20\x01(\x0cR\x07blockid\x12!\n\x0cn\
    eed_content\x18\x03\x20\x01(\x08R\x0bneedContent\"a\n\x0bBlockHeight\x12\
    \"\n\x06header\x18\x03\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x16\n\
    \x06bcname\x18\x01\x20\x01(\tR\x06bcname\x12\x16\n\x06height\x18\x02\x20\
    \x01(\x03R\x06height\"1\n\x0bCommonReply\x12\"\n\x06header\x18\x01\x20\
    \x01(\x0b2\n.pb.HeaderR\x06header\".\n\x08CommonIn\x12\"\n\x06header\x18\
    \x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\"j\n\x0bTokenDetail\x12\x16\n\
    \x06bcname\x18\x01\x20\x01(\tR\x06bcname\x12\x18\n\x07balance\x18\x02\
    \x20\x01(\tR\x07balance\x12)\n\x05error\x18\x03\x20\x01(\x0e2\x13.pb.XCh\
    ainErrorEnumR\x05error\"p\n\rAddressStatus\x12\"\n\x06header\x18\x01\x20\
    \x01(\x0b2\n.pb.HeaderR\x06header\x12\x18\n\x07address\x18\x02\x20\x01(\
    \tR\x07address\x12!\n\x03bcs\x18\x03\x20\x03(\x0b2\x0f.pb.TokenDetailR\
    \x03bcs\"I\n\x11TokenFrozenDetail\x12\x18\n\x07balance\x18\x01\x20\x01(\
    \tR\x07balance\x12\x1a\n\x08isFrozen\x18\x02\x20\x01(\x08R\x08isFrozen\"\
    \x80\x01\n\x12TokenFrozenDetails\x12\x16\n\x06bcname\x18\x01\x20\x01(\tR\
    \x06bcname\x12'\n\x03tfd\x18\x02\x20\x03(\x0b2\x15.pb.TokenFrozenDetailR\
    \x03tfd\x12)\n\x05error\x18\x03\x20\x01(\x0e2\x13.pb.XChainErrorEnumR\
    \x05error\"\x80\x01\n\x14AddressBalanceStatus\x12\"\n\x06header\x18\x01\
    \x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x18\n\x07address\x18\x02\x20\
    \x01(\tR\x07address\x12*\n\x04tfds\x18\x03\x20\x03(\x0b2\x16.pb.TokenFro\
    zenDetailsR\x04tfds\"\x9d\x01\n\x07TxInput\x12\x19\n\x08ref_txid\x18\x01\
    \x20\x01(\x0cR\x07refTxid\x12\x1d\n\nref_offset\x18\x02\x20\x01(\x05R\tr\
    efOffset\x12\x1b\n\tfrom_addr\x18\x05\x20\x01(\x0cR\x08fromAddr\x12\x16\
    \n\x06amount\x18\x06\x20\x01(\x0cR\x06amount\x12#\n\rfrozen_height\x18\
    \x07\x20\x01(\x03R\x0cfrozenHeight\"`\n\x08TxOutput\x12\x16\n\x06amount\
    \x18\x01\x20\x01(\x0cR\x06amount\x12\x17\n\x07to_addr\x18\x02\x20\x01(\
    \x0cR\x06toAddr\x12#\n\rfrozen_height\x18\x04\x20\x01(\x03R\x0cfrozenHei\
    ght\"O\n\x0eXuperSignature\x12\x1f\n\x0bpublic_keys\x18\x01\x20\x03(\x0c\
    R\npublicKeys\x12\x1c\n\tsignature\x18\x02\x20\x01(\x0cR\tsignature\"\
    \xce\x06\n\x0bTransaction\x12\x12\n\x04txid\x18\x01\x20\x01(\x0cR\x04txi\
    d\x12\x18\n\x07blockid\x18\x02\x20\x01(\x0cR\x07blockid\x12(\n\ttx_input\
    s\x18\x03\x20\x03(\x0b2\x0b.pb.TxInputR\x08txInputs\x12+\n\ntx_outputs\
    \x18\x04\x20\x03(\x0b2\x0c.pb.TxOutputR\ttxOutputs\x12\x12\n\x04desc\x18\
    \x06\x20\x01(\x0cR\x04desc\x12\x1a\n\x08coinbase\x18\x07\x20\x01(\x08R\
    \x08coinbase\x12\x14\n\x05nonce\x18\x08\x20\x01(\tR\x05nonce\x12\x1c\n\t\
    timestamp\x18\t\x20\x01(\x03R\ttimestamp\x12\x18\n\x07version\x18\n\x20\
    \x01(\x05R\x07version\x12\x18\n\x07autogen\x18\x0b\x20\x01(\x08R\x07auto\
    gen\x122\n\rtx_inputs_ext\x18\x17\x20\x03(\x0b2\x0e.pb.TxInputExtR\x0btx\
    InputsExt\x125\n\x0etx_outputs_ext\x18\x18\x20\x03(\x0b2\x0f.pb.TxOutput\
    ExtR\x0ctxOutputsExt\x12>\n\x11contract_requests\x18\x19\x20\x03(\x0b2\
    \x11.pb.InvokeRequestR\x10contractRequests\x12\x1c\n\tinitiator\x18\x1a\
    \x20\x01(\tR\tinitiator\x12!\n\x0cauth_require\x18\x1b\x20\x03(\tR\x0bau\
    thRequire\x12:\n\x0finitiator_signs\x18\x1c\x20\x03(\x0b2\x11.pb.Signatu\
    reInfoR\x0einitiatorSigns\x12?\n\x12auth_require_signs\x18\x1d\x20\x03(\
    \x0b2\x11.pb.SignatureInfoR\x10authRequireSigns\x12-\n\x12received_times\
    tamp\x18\x1e\x20\x01(\x03R\x11receivedTimestamp\x121\n\nxuper_sign\x18\
    \x1f\x20\x01(\x0b2\x12.pb.XuperSignatureR\txuperSign\x122\n\x0cmodify_bl\
    ock\x18\x20\x20\x01(\x0b2\x0f.pb.ModifyBlockR\x0bmodifyBlock\x12#\n\x07H\
    D_info\x18!\x20\x01(\x0b2\n.pb.HDInfoR\x06HDInfo\"s\n\nLedgerMeta\x12!\n\
    \x0croot_blockid\x18\x01\x20\x01(\x0cR\x0brootBlockid\x12\x1f\n\x0btip_b\
    lockid\x18\x02\x20\x01(\x0cR\ntipBlockid\x12!\n\x0ctrunk_height\x18\x03\
    \x20\x01(\x03R\x0btrunkHeight\"\x8a\x05\n\x08UtxoMeta\x12%\n\x0elatest_b\
    lockid\x18\x01\x20\x01(\x0cR\rlatestBlockid\x12\"\n\rlock_key_list\x18\
    \x02\x20\x03(\tR\x0blockKeyList\x12\x1d\n\nutxo_total\x18\x03\x20\x01(\t\
    R\tutxoTotal\x12\x1a\n\x08avgDelay\x18\x04\x20\x01(\x03R\x08avgDelay\x12\
    ,\n\x11unconfirmTxAmount\x18\x05\x20\x01(\x03R\x11unconfirmTxAmount\x12$\
    \n\x0emax_block_size\x18\x06\x20\x01(\x03R\x0cmaxBlockSize\x12@\n\x12res\
    erved_contracts\x18\x07\x20\x03(\x0b2\x11.pb.InvokeRequestR\x11reservedC\
    ontracts\x12@\n\x12forbidden_contract\x18\x08\x20\x01(\x0b2\x11.pb.Invok\
    eRequestR\x11forbiddenContract\x12=\n\x1bnew_account_resource_amount\x18\
    \t\x20\x01(\x03R\x18newAccountResourceAmount\x128\n\x17irreversibleBlock\
    Height\x18\n\x20\x01(\x03R\x17irreversibleBlockHeight\x128\n\x17irrevers\
    ibleSlideWindow\x18\x0b\x20\x01(\x03R\x17irreversibleSlideWindow\x12(\n\
    \x08gasPrice\x18\x0c\x20\x01(\x0b2\x0c.pb.GasPriceR\x08gasPrice\x12C\n\
    \x14group_chain_contract\x18\r\x20\x01(\x0b2\x11.pb.InvokeRequestR\x12gr\
    oupChainContract\"z\n\x08GasPrice\x12\x19\n\x08cpu_rate\x18\x01\x20\x01(\
    \x03R\x07cpuRate\x12\x19\n\x08mem_rate\x18\x02\x20\x01(\x03R\x07memRate\
    \x12\x1b\n\tdisk_rate\x18\x03\x20\x01(\x03R\x08diskRate\x12\x1b\n\txfee_\
    rate\x18\x04\x20\x01(\x03R\x08xfeeRate\"\xc1\x05\n\rInternalBlock\x12\
    \x18\n\x07version\x18\x01\x20\x01(\x05R\x07version\x12\x14\n\x05nonce\
    \x18\x02\x20\x01(\x05R\x05nonce\x12\x18\n\x07blockid\x18\x03\x20\x01(\
    \x0cR\x07blockid\x12\x19\n\x08pre_hash\x18\x04\x20\x01(\x0cR\x07preHash\
    \x12\x1a\n\x08proposer\x18\x05\x20\x01(\x0cR\x08proposer\x12\x12\n\x04si\
    gn\x18\x06\x20\x01(\x0cR\x04sign\x12\x16\n\x06pubkey\x18\x07\x20\x01(\
    \x0cR\x06pubkey\x12\x1f\n\x0bmerkle_root\x18\x08\x20\x01(\x0cR\nmerkleRo\
    ot\x12\x16\n\x06height\x18\t\x20\x01(\x03R\x06height\x12\x1c\n\ttimestam\
    p\x18\n\x20\x01(\x03R\ttimestamp\x123\n\x0ctransactions\x18\x0b\x20\x03(\
    \x0b2\x0f.pb.TransactionR\x0ctransactions\x12\x19\n\x08tx_count\x18\x0c\
    \x20\x01(\x05R\x07txCount\x12\x1f\n\x0bmerkle_tree\x18\r\x20\x03(\x0cR\n\
    merkleTree\x12\x18\n\x07curTerm\x18\x10\x20\x01(\x03R\x07curTerm\x12\x20\
    \n\x0bcurBlockNum\x18\x11\x20\x01(\x03R\x0bcurBlockNum\x12?\n\nfailed_tx\
    s\x18\x12\x20\x03(\x0b2\x20.pb.InternalBlock.FailedTxsEntryR\tfailedTxs\
    \x12\x1e\n\ntargetBits\x18\x13\x20\x01(\x05R\ntargetBits\x12(\n\x07Justi\
    fy\x18\x14\x20\x01(\x0b2\x0e.pb.QuorumCertR\x07Justify\x12\x19\n\x08in_t\
    runk\x18\x0e\x20\x01(\x08R\x07inTrunk\x12\x1b\n\tnext_hash\x18\x0f\x20\
    \x01(\x0cR\x08nextHash\x1a<\n\x0eFailedTxsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value:\x02\
    8\x01\"\xe3\x01\n\x08BCStatus\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.\
    pb.HeaderR\x06header\x12\x16\n\x06bcname\x18\x02\x20\x01(\tR\x06bcname\
    \x12\"\n\x04meta\x18\x03\x20\x01(\x0b2\x0e.pb.LedgerMetaR\x04meta\x12'\n\
    \x05block\x18\x04\x20\x01(\x0b2\x11.pb.InternalBlockR\x05block\x12(\n\
    \x08utxoMeta\x18\x05\x20\x01(\x0b2\x0c.pb.UtxoMetaR\x08utxoMeta\x12$\n\r\
    branchBlockid\x18\x06\x20\x03(\tR\rbranchBlockid\"S\n\x0bBCTipStatus\x12\
    \"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x20\n\
    \x0cis_trunk_tip\x18\x02\x20\x01(\x08R\nisTrunkTip\"S\n\x0bBlockChains\
    \x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x20\
    \n\x0bblockchains\x18\x02\x20\x03(\tR\x0bblockchains\"\x80\x02\n\x06Spee\
    ds\x127\n\tSumSpeeds\x18\x01\x20\x03(\x0b2\x19.pb.Speeds.SumSpeedsEntryR\
    \tSumSpeeds\x124\n\x08BcSpeeds\x18\x02\x20\x03(\x0b2\x18.pb.Speeds.BcSpe\
    edsEntryR\x08BcSpeeds\x1a<\n\x0eSumSpeedsEntry\x12\x10\n\x03key\x18\x01\
    \x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x01R\x05value:\
    \x028\x01\x1aI\n\rBcSpeedsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03\
    key\x12\"\n\x05value\x18\x02\x20\x01(\x0b2\x0c.pb.BCSpeedsR\x05value:\
    \x028\x01\"{\n\x08BCSpeeds\x123\n\x07BcSpeed\x18\x01\x20\x03(\x0b2\x19.p\
    b.BCSpeeds.BcSpeedEntryR\x07BcSpeed\x1a:\n\x0cBcSpeedEntry\x12\x10\n\x03\
    key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\x02\x20\x01(\x01R\
    \x05value:\x028\x01\"\xa0\x01\n\rSystemsStatus\x12\"\n\x06header\x18\x01\
    \x20\x01(\x0b2\n.pb.HeaderR\x06header\x12+\n\nbcs_status\x18\x02\x20\x03\
    (\x0b2\x0c.pb.BCStatusR\tbcsStatus\x12\"\n\x06speeds\x18\x03\x20\x01(\
    \x0b2\n.pb.SpeedsR\x06speeds\x12\x1a\n\x08peerUrls\x18\x04\x20\x03(\tR\
    \x08peerUrls\"r\n\x12SystemsStatusReply\x12\"\n\x06header\x18\x01\x20\
    \x01(\x0b2\n.pb.HeaderR\x06header\x128\n\x0esystems_status\x18\x02\x20\
    \x01(\x0b2\x11.pb.SystemsStatusR\rsystemsStatus\"D\n\x06RawUrl\x12\"\n\
    \x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x16\n\x06raw\
    Url\x18\x02\x20\x01(\tR\x06rawUrl\"\x8a\x01\n\x04Utxo\x12\x16\n\x06amoun\
    t\x18\x01\x20\x01(\x0cR\x06amount\x12\x16\n\x06toAddr\x18\x02\x20\x01(\
    \x0cR\x06toAddr\x12\x1a\n\x08toPubkey\x18\x03\x20\x01(\x0cR\x08toPubkey\
    \x12\x18\n\x07refTxid\x18\x04\x20\x01(\x0cR\x07refTxid\x12\x1c\n\trefOff\
    set\x18\x05\x20\x01(\x05R\trefOffset\"\xd5\x01\n\tUtxoInput\x12\"\n\x06h\
    eader\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x16\n\x06bcname\
    \x18\x02\x20\x01(\tR\x06bcname\x12\x18\n\x07address\x18\x03\x20\x01(\tR\
    \x07address\x12\x1c\n\tpublickey\x18\x04\x20\x01(\tR\tpublickey\x12\x1c\
    \n\ttotalNeed\x18\x05\x20\x01(\tR\ttotalNeed\x12\x1a\n\x08userSign\x18\
    \x07\x20\x01(\x0cR\x08userSign\x12\x1a\n\x08needLock\x18\x08\x20\x01(\
    \x08R\x08needLock\"|\n\nUtxoOutput\x12\"\n\x06header\x18\x01\x20\x01(\
    \x0b2\n.pb.HeaderR\x06header\x12$\n\x08utxoList\x18\x02\x20\x03(\x0b2\
    \x08.pb.UtxoR\x08utxoList\x12$\n\rtotalSelected\x18\x03\x20\x01(\tR\rtot\
    alSelected\"\xa2\x01\n\x0eNativeCodeDesc\x12\x12\n\x04name\x18\x01\x20\
    \x01(\tR\x04name\x12\x18\n\x07version\x18\x02\x20\x01(\tR\x07version\x12\
    \x16\n\x06digest\x18\x03\x20\x01(\x0cR\x06digest\x12\x20\n\x0bprevVersio\
    n\x18\x04\x20\x01(\tR\x0bprevVersion\x12(\n\x0fxuperApiVersion\x18\x05\
    \x20\x01(\x05R\x0fxuperApiVersion\"}\n\x0cWasmCodeDesc\x12\x18\n\x07runt\
    ime\x18\x01\x20\x01(\tR\x07runtime\x12\x1a\n\x08compiler\x18\x02\x20\x01\
    (\tR\x08compiler\x12\x16\n\x06digest\x18\x03\x20\x01(\x0cR\x06digest\x12\
    \x1f\n\x0bvm_compiler\x18\x04\x20\x01(\tR\nvmCompiler\"\xd7\x01\n\x17Dep\
    loyNativeCodeRequest\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.Header\
    R\x06header\x12\x16\n\x06bcname\x18\x02\x20\x01(\tR\x06bcname\x12&\n\x04\
    desc\x18\x03\x20\x01(\x0b2\x12.pb.NativeCodeDescR\x04desc\x12\x12\n\x04c\
    ode\x18\x04\x20\x01(\x0cR\x04code\x12\x18\n\x07address\x18\x05\x20\x01(\
    \tR\x07address\x12\x16\n\x06pubkey\x18\x06\x20\x01(\x0cR\x06pubkey\x12\
    \x12\n\x04sign\x18\x07\x20\x01(\x0cR\x04sign\">\n\x18DeployNativeCodeRes\
    ponse\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\"l\
    \n\x10NativeCodeStatus\x12&\n\x04desc\x18\x01\x20\x01(\x0b2\x12.pb.Nativ\
    eCodeDescR\x04desc\x12\x16\n\x06status\x18\x02\x20\x01(\x05R\x06status\
    \x12\x18\n\x07healthy\x18\x03\x20\x01(\x08R\x07healthy\"U\n\x17NativeCod\
    eStatusRequest\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06h\
    eader\x12\x16\n\x06bcname\x18\x02\x20\x01(\tR\x06bcname\"l\n\x18NativeCo\
    deStatusResponse\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\
    \x06header\x12,\n\x06status\x18\x02\x20\x03(\x0b2\x14.pb.NativeCodeStatu\
    sR\x06status\"S\n\x15DposCandidatesRequest\x12\"\n\x06header\x18\x01\x20\
    \x01(\x0b2\n.pb.HeaderR\x06header\x12\x16\n\x06bcname\x18\x02\x20\x01(\t\
    R\x06bcname\"d\n\x16DposCandidatesResponse\x12\"\n\x06header\x18\x01\x20\
    \x01(\x0b2\n.pb.HeaderR\x06header\x12&\n\x0ecandidatesInfo\x18\x02\x20\
    \x03(\tR\x0ecandidatesInfo\"r\n\x1aDposNominateRecordsRequest\x12\"\n\
    \x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x16\n\x06bcn\
    ame\x18\x02\x20\x01(\tR\x06bcname\x12\x18\n\x07address\x18\x03\x20\x01(\
    \tR\x07address\"D\n\x10DposNominateInfo\x12\x1c\n\tcandidate\x18\x01\x20\
    \x01(\tR\tcandidate\x12\x12\n\x04txid\x18\x02\x20\x01(\tR\x04txid\"\x81\
    \x01\n\x1bDposNominateRecordsResponse\x12\"\n\x06header\x18\x01\x20\x01(\
    \x0b2\n.pb.HeaderR\x06header\x12>\n\x0fnominateRecords\x18\x02\x20\x03(\
    \x0b2\x14.pb.DposNominateInfoR\x0fnominateRecords\"q\n\x19DposNomineeRec\
    ordsRequest\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06head\
    er\x12\x16\n\x06bcname\x18\x02\x20\x01(\tR\x06bcname\x12\x18\n\x07addres\
    s\x18\x03\x20\x01(\tR\x07address\"T\n\x1aDposNomineeRecordsResponse\x12\
    \"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x12\n\
    \x04txid\x18\x02\x20\x01(\tR\x04txid\"n\n\x16DposVoteRecordsRequest\x12\
    \"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x16\n\
    \x06bcname\x18\x02\x20\x01(\tR\x06bcname\x12\x18\n\x07address\x18\x03\
    \x20\x01(\tR\x07address\">\n\nvoteRecord\x12\x1c\n\tcandidate\x18\x01\
    \x20\x01(\tR\tcandidate\x12\x12\n\x04txid\x18\x02\x20\x01(\tR\x04txid\"w\
    \n\x17DposVoteRecordsResponse\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.\
    pb.HeaderR\x06header\x128\n\x0fvoteTxidRecords\x18\x02\x20\x03(\x0b2\x0e\
    .pb.voteRecordR\x0fvoteTxidRecords\"o\n\x17DposVotedRecordsRequest\x12\"\
    \n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x16\n\x06b\
    cname\x18\x02\x20\x01(\tR\x06bcname\x12\x18\n\x07address\x18\x03\x20\x01\
    (\tR\x07address\"7\n\x0bvotedRecord\x12\x14\n\x05voter\x18\x01\x20\x01(\
    \tR\x05voter\x12\x12\n\x04txid\x18\x02\x20\x01(\tR\x04txid\"{\n\x18DposV\
    otedRecordsResponse\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\
    \x06header\x12;\n\x10votedTxidRecords\x18\x02\x20\x03(\x0b2\x0f.pb.voted\
    RecordR\x10votedTxidRecords\"i\n\x17DposCheckResultsRequest\x12\"\n\x06h\
    eader\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x16\n\x06bcname\
    \x18\x02\x20\x01(\tR\x06bcname\x12\x12\n\x04term\x18\x03\x20\x01(\x03R\
    \x04term\"t\n\x18DposCheckResultsResponse\x12\"\n\x06header\x18\x01\x20\
    \x01(\x0b2\n.pb.HeaderR\x06header\x12\x12\n\x04term\x18\x02\x20\x01(\x03\
    R\x04term\x12\x20\n\x0bcheckResult\x18\x03\x20\x03(\tR\x0bcheckResult\"O\
    \n\x11DposStatusRequest\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.Hea\
    derR\x06header\x12\x16\n\x06bcname\x18\x02\x20\x01(\tR\x06bcname\"`\n\
    \x12DposStatusResponse\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.Head\
    erR\x06header\x12&\n\x06status\x18\x02\x20\x01(\x0b2\x0e.pb.DposStatusR\
    \x06status\"\x9e\x01\n\nDposStatus\x12\x12\n\x04term\x18\x01\x20\x01(\
    \x03R\x04term\x12\x1b\n\tblock_num\x18\x02\x20\x01(\x03R\x08blockNum\x12\
    \x1a\n\x08proposer\x18\x03\x20\x01(\tR\x08proposer\x12!\n\x0cproposer_nu\
    m\x18\x04\x20\x01(\x03R\x0bproposerNum\x12\x20\n\x0bcheckResult\x18\x05\
    \x20\x03(\tR\x0bcheckResult\"\xbe\x01\n\x10InvokeRPCRequest\x12\"\n\x06h\
    eader\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x16\n\x06bcname\
    \x18\x02\x20\x01(\tR\x06bcname\x12-\n\x08requests\x18\x03\x20\x03(\x0b2\
    \x11.pb.InvokeRequestR\x08requests\x12\x1c\n\tinitiator\x18\x04\x20\x01(\
    \tR\tinitiator\x12!\n\x0cauth_require\x18\x05\x20\x03(\tR\x0bauthRequire\
    \"\x7f\n\x11InvokeRPCResponse\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.\
    pb.HeaderR\x06header\x12\x16\n\x06bcname\x18\x02\x20\x01(\tR\x06bcname\
    \x12.\n\x08response\x18\x03\x20\x01(\x0b2\x12.pb.InvokeResponseR\x08resp\
    onse\"\xb4\x02\n\rInvokeRequest\x12\x1f\n\x0bmodule_name\x18\x01\x20\x01\
    (\tR\nmoduleName\x12#\n\rcontract_name\x18\x02\x20\x01(\tR\x0ccontractNa\
    me\x12\x1f\n\x0bmethod_name\x18\x03\x20\x01(\tR\nmethodName\x12/\n\x04ar\
    gs\x18\x04\x20\x03(\x0b2\x1b.pb.InvokeRequest.ArgsEntryR\x04args\x12:\n\
    \x0fresource_limits\x18\x05\x20\x03(\x0b2\x11.pb.ResourceLimitR\x0eresou\
    rceLimits\x12\x16\n\x06amount\x18\x06\x20\x01(\tR\x06amount\x1a7\n\tArgs\
    Entry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\x05value\x18\
    \x02\x20\x01(\x0cR\x05value:\x028\x01\"\xda\x02\n\x0eInvokeResponse\x12&\
    \n\x06inputs\x18\x01\x20\x03(\x0b2\x0e.pb.TxInputExtR\x06inputs\x12)\n\
    \x07outputs\x18\x02\x20\x03(\x0b2\x0f.pb.TxOutputExtR\x07outputs\x12\x1a\
    \n\x08response\x18\x03\x20\x03(\x0cR\x08response\x12\x19\n\x08gas_used\
    \x18\x04\x20\x01(\x03R\x07gasUsed\x12-\n\x08requests\x18\x05\x20\x03(\
    \x0b2\x11.pb.InvokeRequestR\x08requests\x122\n\tresponses\x18\x06\x20\
    \x03(\x0b2\x14.pb.ContractResponseR\tresponses\x12+\n\nutxoInputs\x18\
    \x07\x20\x03(\x0b2\x0b.pb.TxInputR\nutxoInputs\x12.\n\x0butxoOutputs\x18\
    \x08\x20\x03(\x0b2\x0c.pb.TxOutputR\x0butxoOutputs\"p\n\nTxInputExt\x12\
    \x16\n\x06bucket\x18\x01\x20\x01(\tR\x06bucket\x12\x10\n\x03key\x18\x02\
    \x20\x01(\x0cR\x03key\x12\x19\n\x08ref_txid\x18\x03\x20\x01(\x0cR\x07ref\
    Txid\x12\x1d\n\nref_offset\x18\x04\x20\x01(\x05R\trefOffset\"M\n\x0bTxOu\
    tputExt\x12\x16\n\x06bucket\x18\x01\x20\x01(\tR\x06bucket\x12\x10\n\x03k\
    ey\x18\x02\x20\x01(\x0cR\x03key\x12\x14\n\x05value\x18\x03\x20\x01(\x0cR\
    \x05value\"A\n\rSignatureInfo\x12\x1c\n\tPublicKey\x18\x01\x20\x01(\tR\t\
    PublicKey\x12\x12\n\x04Sign\x18\x02\x20\x01(\x0cR\x04Sign\"[\n\x0fPermis\
    sionModel\x12&\n\x04rule\x18\x01\x20\x01(\x0e2\x12.pb.PermissionRuleR\
    \x04rule\x12\x20\n\x0bacceptValue\x18\x02\x20\x01(\x01R\x0bacceptValue\"\
    \x19\n\x05AkSet\x12\x10\n\x03aks\x18\x01\x20\x03(\tR\x03aks\"\x96\x01\n\
    \x06AkSets\x12(\n\x04sets\x18\x01\x20\x03(\x0b2\x14.pb.AkSets.SetsEntryR\
    \x04sets\x12\x1e\n\nexpression\x18\x02\x20\x01(\tR\nexpression\x1aB\n\tS\
    etsEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x1f\n\x05value\
    \x18\x02\x20\x01(\x0b2\t.pb.AkSetR\x05value:\x028\x01\"\xc2\x01\n\x03Acl\
    \x12#\n\x02pm\x18\x01\x20\x01(\x0b2\x13.pb.PermissionModelR\x02pm\x124\n\
    \taksWeight\x18\x02\x20\x03(\x0b2\x16.pb.Acl.AksWeightEntryR\taksWeight\
    \x12\"\n\x06akSets\x18\x03\x20\x01(\x0b2\n.pb.AkSetsR\x06akSets\x1a<\n\
    \x0eAksWeightEntry\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03key\x12\x14\n\
    \x05value\x18\x02\x20\x01(\x01R\x05value:\x028\x01\"\xe6\x01\n\tAclStatu\
    s\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x16\
    \n\x06bcname\x18\x02\x20\x01(\tR\x06bcname\x12\x20\n\x0baccountName\x18\
    \x03\x20\x01(\tR\x0baccountName\x12\"\n\x0ccontractName\x18\x04\x20\x01(\
    \tR\x0ccontractName\x12\x1e\n\nmethodName\x18\x05\x20\x01(\tR\nmethodNam\
    e\x12\x1c\n\tconfirmed\x18\x06\x20\x01(\x08R\tconfirmed\x12\x19\n\x03acl\
    \x18\x07\x20\x01(\x0b2\x07.pb.AclR\x03acl\"\x84\x01\n\x0cIdentityAuth\
    \x12\x12\n\x04sign\x18\x01\x20\x01(\x0cR\x04sign\x12\x16\n\x06pubkey\x18\
    \x02\x20\x01(\x0cR\x06pubkey\x12\x12\n\x04addr\x18\x03\x20\x01(\tR\x04ad\
    dr\x12\x16\n\x06peerID\x18\x04\x20\x01(\tR\x06peerID\x12\x1c\n\ttimestam\
    p\x18\x05\x20\x01(\tR\ttimestamp\"5\n\rIdentityAuths\x12$\n\x04auth\x18\
    \x01\x20\x03(\x0b2\x10.pb.IdentityAuthR\x04auth\"K\n\rResourceLimit\x12$\
    \n\x04type\x18\x01\x20\x01(\x0e2\x10.pb.ResourceTypeR\x04type\x12\x14\n\
    \x05limit\x18\x02\x20\x01(\x03R\x05limit\"i\n\x11AK2AccountRequest\x12\"\
    \n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x16\n\x06b\
    cname\x18\x02\x20\x01(\tR\x06bcname\x12\x18\n\x07address\x18\x03\x20\x01\
    (\tR\x07address\"j\n\x12AK2AccountResponse\x12\"\n\x06header\x18\x01\x20\
    \x01(\x0b2\n.pb.HeaderR\x06header\x12\x16\n\x06bcname\x18\x02\x20\x01(\t\
    R\x06bcname\x12\x18\n\x07account\x18\x03\x20\x03(\tR\x07account\"r\n\x1a\
    GetAccountContractsRequest\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.\
    HeaderR\x06header\x12\x16\n\x06bcname\x18\x02\x20\x01(\tR\x06bcname\x12\
    \x18\n\x07account\x18\x03\x20\x01(\tR\x07account\"\x80\x01\n\x1bGetAccou\
    ntContractsResponse\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\
    \x06header\x12=\n\x10contracts_status\x18\x02\x20\x03(\x0b2\x12.pb.Contr\
    actStatusR\x0fcontractsStatus\"z\n\x0eContractStatus\x12#\n\rcontract_na\
    me\x18\x01\x20\x01(\tR\x0ccontractName\x12\x12\n\x04txid\x18\x02\x20\x01\
    (\tR\x04txid\x12\x12\n\x04desc\x18\x03\x20\x01(\x0cR\x04desc\x12\x1b\n\t\
    is_banned\x18\x04\x20\x01(\x08R\x08isBanned\"\x91\x02\n\x1cPreExecWithSe\
    lectUTXORequest\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06\
    header\x12\x16\n\x06bcname\x18\x02\x20\x01(\tR\x06bcname\x12\x18\n\x07ad\
    dress\x18\x03\x20\x01(\tR\x07address\x12\x20\n\x0btotalAmount\x18\x04\
    \x20\x01(\x03R\x0btotalAmount\x12-\n\x08signInfo\x18\x06\x20\x01(\x0b2\
    \x11.pb.SignatureInfoR\x08signInfo\x12\x1a\n\x08needLock\x18\x07\x20\x01\
    (\x08R\x08needLock\x12.\n\x07request\x18\x05\x20\x01(\x0b2\x14.pb.Invoke\
    RPCRequestR\x07request\"\xbb\x01\n\x1dPreExecWithSelectUTXOResponse\x12\
    \"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x16\n\
    \x06bcname\x18\x02\x20\x01(\tR\x06bcname\x12.\n\x08response\x18\x03\x20\
    \x01(\x0b2\x12.pb.InvokeResponseR\x08response\x12.\n\nutxoOutput\x18\x04\
    \x20\x01(\x0b2\x0e.pb.UtxoOutputR\nutxoOutput\"X\n\x10ContractResponse\
    \x12\x16\n\x06status\x18\x01\x20\x01(\x05R\x06status\x12\x18\n\x07messag\
    e\x18\x02\x20\x01(\tR\x07message\x12\x12\n\x04body\x18\x03\x20\x01(\x0cR\
    \x04body\"\xaa\x01\n\x0bModifyBlock\x12%\n\x0eeffective_txid\x18\x01\x20\
    \x01(\tR\reffectiveTxid\x12\x16\n\x06marked\x18\x02\x20\x01(\x08R\x06mar\
    ked\x12)\n\x10effective_height\x18\x03\x20\x01(\x03R\x0feffectiveHeight\
    \x12\x1d\n\npublic_key\x18\x04\x20\x01(\tR\tpublicKey\x12\x12\n\x04sign\
    \x18\x05\x20\x01(\tR\x04sign\"Q\n\x06HDInfo\x12\"\n\rhd_public_key\x18\
    \x01\x20\x01(\x0cR\x0bhdPublicKey\x12#\n\roriginal_hash\x18\x02\x20\x01(\
    \x0cR\x0coriginalHash\"\xc4\x02\n\x10UtxoRecordDetail\x12\"\n\x06header\
    \x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06header\x12\x16\n\x06bcname\x18\
    \x02\x20\x01(\tR\x06bcname\x12\x20\n\x0baccountName\x18\x03\x20\x01(\tR\
    \x0baccountName\x126\n\x0eopenUtxoRecord\x18\x04\x20\x01(\x0b2\x0e.pb.Ut\
    xoRecordR\x0eopenUtxoRecord\x12:\n\x10lockedUtxoRecord\x18\x05\x20\x01(\
    \x0b2\x0e.pb.UtxoRecordR\x10lockedUtxoRecord\x12:\n\x10frozenUtxoRecord\
    \x18\x06\x20\x01(\x0b2\x0e.pb.UtxoRecordR\x10frozenUtxoRecord\x12\"\n\
    \x0cdisplayCount\x18\x07\x20\x01(\x03R\x0cdisplayCount\"k\n\nUtxoRecord\
    \x12\x1c\n\tutxoCount\x18\x01\x20\x01(\tR\tutxoCount\x12\x1e\n\nutxoAmou\
    nt\x18\x02\x20\x01(\tR\nutxoAmount\x12\x1f\n\x04item\x18\x03\x20\x03(\
    \x0b2\x0b.pb.UtxoKeyR\x04item\"S\n\x07UtxoKey\x12\x18\n\x07refTxid\x18\
    \x01\x20\x01(\tR\x07refTxid\x12\x16\n\x06offset\x18\x02\x20\x01(\tR\x06o\
    ffset\x12\x16\n\x06amount\x18\x03\x20\x01(\tR\x06amount\"U\n\x17Contract\
    StatDataRequest\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.HeaderR\x06\
    header\x12\x16\n\x06bcname\x18\x02\x20\x01(\tR\x06bcname\"\x80\x01\n\x18\
    ContractStatDataResponse\x12\"\n\x06header\x18\x01\x20\x01(\x0b2\n.pb.He\
    aderR\x06header\x12\x16\n\x06bcname\x18\x02\x20\x01(\tR\x06bcname\x12(\n\
    \x04data\x18\x03\x20\x01(\x0b2\x14.pb.ContractStatDataR\x04data\"\\\n\
    \x10ContractStatData\x12\"\n\x0caccountCount\x18\x01\x20\x01(\x03R\x0cac\
    countCount\x12$\n\rcontractCount\x18\x02\x20\x01(\x03R\rcontractCount*\
    \xad\x06\n\x0fXChainErrorEnum\x12\x0b\n\x07SUCCESS\x10\0\x12\x10\n\x0cUN\
    KNOW_ERROR\x10\x01\x12\x12\n\x0eCONNECT_REFUSE\x10\x02\x12\x19\n\x15NOT_\
    ENOUGH_UTXO_ERROR\x10\x03\x12\"\n\x1eUTXOVM_ALREADY_UNCONFIRM_ERROR\x10\
    \x04\x12\x1a\n\x16UTXOVM_NOT_FOUND_ERROR\x10\x05\x12\x20\n\x1cINPUT_OUTP\
    UT_NOT_EQUAL_ERROR\x10\x06\x12\x16\n\x12TX_NOT_FOUND_ERROR\x10\x07\x12\
    \x11\n\rTX_SIGN_ERROR\x10\x08\x12\x17\n\x13BLOCKCHAIN_NOTEXIST\x10\t\x12\
    \x12\n\x0eVALIDATE_ERROR\x10\n\x12\x1b\n\x17CANNOT_SYNC_BLOCK_ERROR\x10\
    \x0b\x12\x17\n\x13CONFIRM_BLOCK_ERROR\x10\x0c\x12\x15\n\x11UTXOVM_PLAY_E\
    RROR\x10\r\x12\x0e\n\nWALK_ERROR\x10\x0e\x12\x13\n\x0fNOT_READY_ERROR\
    \x10\x0f\x12\x15\n\x11BLOCK_EXIST_ERROR\x10\x10\x12\x1a\n\x16ROOT_BLOCK_\
    EXIST_ERROR\x10\x11\x12\x16\n\x12TX_DUPLICATE_ERROR\x10\x13\x12\x19\n\
    \x15SERVICE_REFUSED_ERROR\x10\x14\x12\x15\n\x11TXDATA_SIGN_ERROR\x10\x15\
    \x12\x10\n\x0cTX_SLE_ERROR\x10\x19\x12\x1b\n\x17TX_FEE_NOT_ENOUGH_ERROR\
    \x10\x1a\x12\x13\n\x0fUTXO_SIGN_ERROR\x10\x1c\x12\x14\n\x10DPOS_QUERY_ER\
    ROR\x10\x1f\x12\x17\n\x13RWSET_INVALID_ERROR\x10!\x12\x17\n\x13RWACL_INV\
    ALID_ERROR\x10\"\x12\x18\n\x14GAS_NOT_ENOUGH_ERROR\x10#\x12\x1c\n\x18TX_\
    VERSION_INVALID_ERROR\x10$\x12!\n\x1dCOMPLIANCE_CHECK_NOT_APPROVED\x10%\
    \x12!\n\x1dACCOUNT_CONTRACT_STATUS_ERROR\x10&\x12\x19\n\x15TX_VERIFICATI\
    ON_ERROR\x10(*e\n\x11TransactionStatus\x12\x0c\n\x08UNDEFINE\x10\0\x12\
    \x0b\n\x07NOEXIST\x10\x01\x12\x0b\n\x07CONFIRM\x10\x02\x12\r\n\tFURCATIO\
    N\x10\x03\x12\r\n\tUNCONFIRM\x10\x04\x12\n\n\x06FAILED\x10\x05*~\n\x0ePe\
    rmissionRule\x12\x08\n\x04NULL\x10\0\x12\x12\n\x0eSIGN_THRESHOLD\x10\x01\
    \x12\x0e\n\nSIGN_AKSET\x10\x02\x12\r\n\tSIGN_RATE\x10\x03\x12\x0c\n\x08S\
    IGN_SUM\x10\x04\x12\r\n\tCA_SERVER\x10\x05\x12\x12\n\x0eCOMMUNITY_VOTE\
    \x10\x06*7\n\x0cResourceType\x12\x07\n\x03CPU\x10\0\x12\n\n\x06MEMORY\
    \x10\x01\x12\x08\n\x04DISK\x10\x02\x12\x08\n\x04XFEE\x10\x032\xd5\x0e\n\
    \x06Xchain\x123\n\x10SelectUTXOBySize\x12\r.pb.UtxoInput\x1a\x0e.pb.Utxo\
    Output\"\0\x12)\n\x06PostTx\x12\x0c.pb.TxStatus\x1a\x0f.pb.CommonReply\"\
    \0\x12*\n\x08QueryACL\x12\r.pb.AclStatus\x1a\r.pb.AclStatus\"\0\x12?\n\
    \x0fQueryUtxoRecord\x12\x14.pb.UtxoRecordDetail\x1a\x14.pb.UtxoRecordDet\
    ail\"\0\x12T\n\x15QueryContractStatData\x12\x1b.pb.ContractStatDataReque\
    st\x1a\x1c.pb.ContractStatDataResponse\"\0\x12X\n\x13GetAccountContracts\
    \x12\x1e.pb.GetAccountContractsRequest\x1a\x1f.pb.GetAccountContractsRes\
    ponse\"\0\x12'\n\x07QueryTx\x12\x0c.pb.TxStatus\x1a\x0c.pb.TxStatus\"\0\
    \x124\n\nGetBalance\x12\x11.pb.AddressStatus\x1a\x11.pb.AddressStatus\"\
    \0\x12H\n\x10GetBalanceDetail\x12\x18.pb.AddressBalanceStatus\x1a\x18.pb\
    .AddressBalanceStatus\"\0\x12:\n\x10GetFrozenBalance\x12\x11.pb.AddressS\
    tatus\x1a\x11.pb.AddressStatus\"\0\x12$\n\x08GetBlock\x12\x0b.pb.BlockID\
    \x1a\t.pb.Block\"\0\x120\n\x10GetBlockByHeight\x12\x0f.pb.BlockHeight\
    \x1a\t.pb.Block\"\0\x123\n\x13GetBlockChainStatus\x12\x0c.pb.BCStatus\
    \x1a\x0c.pb.BCStatus\"\0\x121\n\x0eGetBlockChains\x12\x0c.pb.CommonIn\
    \x1a\x0f.pb.BlockChains\"\0\x129\n\x0fGetSystemStatus\x12\x0c.pb.CommonI\
    n\x1a\x16.pb.SystemsStatusReply\"\0\x12'\n\tGetNetURL\x12\x0c.pb.CommonI\
    n\x1a\n.pb.RawUrl\"\0\x12-\n\nSelectUTXO\x12\r.pb.UtxoInput\x1a\x0e.pb.U\
    txoOutput\"\0\x12^\n\x15PreExecWithSelectUTXO\x12\x20.pb.PreExecWithSele\
    ctUTXORequest\x1a!.pb.PreExecWithSelectUTXOResponse\"\0\x12M\n\x10Deploy\
    NativeCode\x12\x1b.pb.DeployNativeCodeRequest\x1a\x1c.pb.DeployNativeCod\
    eResponse\x12M\n\x10NativeCodeStatus\x12\x1b.pb.NativeCodeStatusRequest\
    \x1a\x1c.pb.NativeCodeStatusResponse\x12G\n\x0eDposCandidates\x12\x19.pb\
    .DposCandidatesRequest\x1a\x1a.pb.DposCandidatesResponse\x12V\n\x13DposN\
    ominateRecords\x12\x1e.pb.DposNominateRecordsRequest\x1a\x1f.pb.DposNomi\
    nateRecordsResponse\x12S\n\x12DposNomineeRecords\x12\x1d.pb.DposNomineeR\
    ecordsRequest\x1a\x1e.pb.DposNomineeRecordsResponse\x12J\n\x0fDposVoteRe\
    cords\x12\x1a.pb.DposVoteRecordsRequest\x1a\x1b.pb.DposVoteRecordsRespon\
    se\x12M\n\x10DposVotedRecords\x12\x1b.pb.DposVotedRecordsRequest\x1a\x1c\
    .pb.DposVotedRecordsResponse\x12M\n\x10DposCheckResults\x12\x1b.pb.DposC\
    heckResultsRequest\x1a\x1c.pb.DposCheckResultsResponse\x12;\n\nDposStatu\
    s\x12\x15.pb.DposStatusRequest\x1a\x16.pb.DposStatusResponse\x12A\n\x0eG\
    etAccountByAK\x12\x15.pb.AK2AccountRequest\x1a\x16.pb.AK2AccountResponse\
    \"\0\x128\n\x07PreExec\x12\x14.pb.InvokeRPCRequest\x1a\x15.pb.InvokeRPCR\
    esponse\"\0b\x06proto3\
";

static mut file_descriptor_proto_lazy: ::protobuf::lazy::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::lazy::Lazy::INIT;

fn parse_descriptor_proto() -> ::protobuf::descriptor::FileDescriptorProto {
    ::protobuf::parse_from_bytes(file_descriptor_proto_data).unwrap()
}

pub fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    unsafe {
        file_descriptor_proto_lazy.get(|| {
            parse_descriptor_proto()
        })
    }
}
